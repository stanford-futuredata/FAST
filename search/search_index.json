{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FAST User Guide \u00b6 Welcome to FAST's documentation \u00b6 FAST is an end-to-end and unsupervised earthquake detection pipeline. It is a useful tool for seismologists to extract more small earthquakes from continuous seismic data. Github development page: \u00b6 https://github.com/stanford-futuredata/FAST Contents \u00b6 FAST Overview . Click here for a summary of the FAST algorithm and why you might want to use it on your seismic data. Install Go here to learn how to install and run the FAST software on your computer. Google Colab Linux Docker Tutorial Learn how FAST detects earthquakes on the Hector Mine data set. How to Set Parameters Click here to learn how to test FAST on your own data sets. FAST Checklist Getting Seismic Data Input and Preprocessing Fingerprint Similarity Search Network Detection FAST Output Phase Picking Earthquake Location Example Parameters Click here to see data sets FAST has been used on to detect earthquakes. References Read publications about FAST here.","title":"FAST User Guide"},{"location":"#fast-user-guide","text":"","title":"FAST User Guide"},{"location":"#welcome-to-fasts-documentation","text":"FAST is an end-to-end and unsupervised earthquake detection pipeline. It is a useful tool for seismologists to extract more small earthquakes from continuous seismic data.","title":"Welcome to FAST's documentation"},{"location":"#github-development-page","text":"https://github.com/stanford-futuredata/FAST","title":"Github development page:"},{"location":"#contents","text":"FAST Overview . Click here for a summary of the FAST algorithm and why you might want to use it on your seismic data. Install Go here to learn how to install and run the FAST software on your computer. Google Colab Linux Docker Tutorial Learn how FAST detects earthquakes on the Hector Mine data set. How to Set Parameters Click here to learn how to test FAST on your own data sets. FAST Checklist Getting Seismic Data Input and Preprocessing Fingerprint Similarity Search Network Detection FAST Output Phase Picking Earthquake Location Example Parameters Click here to see data sets FAST has been used on to detect earthquakes. References Read publications about FAST here.","title":"Contents"},{"location":"FAST_checklist/","text":"Checklist for running FAST on Your Own Dataset \u00b6 Info Follow along with the tutorial section to make sure you follow the correct steps for FAST while using your own dataset. In most cases, if something does not run correctly, there is likely an issue with the file path or file name that users must fix. Follow install instructions: Google Colab , Linux , or Docker Get seismic data Put seismic data folder in ~/FAST/data/ Plot sample spectrograms to decided decimate factor and min/max frequency. Python script found in ~/FAST/utils/preprocess : plot_sample_spectrograms.py Check sampling rate of waveform data for decimate value >>> st = read(\u201cAZ.TONN*\u201c) >>> print(st) 3 Trace(s) in Stream: AZ.TONN..HNE | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples AZ.TONN..HNN | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples AZ.TONN..HNZ | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples >>> st = read(\u201cCI.CRR*\u201c) >>> print(st) 3 Trace(s) in Stream: CI.CRR..HHE | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples CI.CRR..HHN | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples CI.CRR..HHZ | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples Choose sampling rate for fingerprinting: If chosen sampling rate is 25 Hz, and trace sampling rate is 200 Hz, choose a decimate factor of 8 If chosen sampling rate is 25 Hz, and trace sampling rate is 100 Hz, choose a decimate factor of 4 Use ~/FAST/utils/preprocess/bandpass_filter_decimate.py and create a bash script similar to ~/FAST/utils/preprocess/mdl_bandpass_filter.sh to filter waveforms. Make sure to change input directory and consider creating an output directory for the decimated waveform files. Change input directory in ~/FAST/utils/preprocess/bandpass_filter_decimate.py 65 66 67 68 69 70 ts_dir = '/lfs/1/ceyoon/TimeSeries/NEP/waveforms' + station + '/' # change input directory to reference where your waveforms are out_dir = '../../data/waveforms_decimated/' # consider creating an output directory if not os . path . exists ( out_dir ): # create directory if it doesn't exist os . mkdir ( out_dir ) Change where output files are written 114 st . write ( ts_dir + str_prefix + file_str , format = format_str ) # change ts_dir to out_dir >>> st = read(\u201cAZ.TONN*\u201c) >>> print(st) 3 Trace(s) in Stream: AZ.TONN..HNE | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples AZ.TONN..HNN | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples AZ.TONN..HNZ | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples The above waveform is 200 Hz, so the decimate factor should be 8, for the FAST fingerprint sampling rate to be 25 Hz: python bandpass_filter_decimate.py AZ TONN HNZ 4 12 8 # 4: min frequency # 12: max frequency # 8: decimate value 4 - 12 Hz is a good general min/max frequency range for most waveform files. The decimate value depends on the sampling rate. Follow the guide above to choose this value. Create fingerprint input json files for each channel at each station in your dataset. Example: { \"fingerprint\": { \"sampling_rate\": 25, # final sampling rate after decimating \"min_freq\": 4.0, \"max_freq\": 12.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 1, \"mad_sample_interval\": 86400 }, \"performance\": { \"num_fp_thread\": 16, \"partition_len\": 86400 }, \"data\": { \"station\": \"WLA06\", \"channel\": \"HNE\", \"start_time\": \"21-06-05T00:00:00.0\", \"end_time\": \"21-06-06T00:00:00.0\", \"folder\": \"data/waveforms/\", # folder where decimated waveform files are located \"fingerprint_files\": [ \"Deci4.bp2to20.YR.ED04..HHZ.D.2016.303\"], \"MAD_sample_files\": [ \"Deci4.bp2to20.YR.ED04..HHZ.D.2016.303\"] } } Put all fp_input_NETWORK_STATION_CHANNEL.json files in ~/FAST/config.json and ~/FAST/parameters/fingerprint/your_dataset_folder/global_indices.json ; Example: { \"index_folder\": \"../data/global_indices/\", \"fp_param_dir\": \"../parameters/fingerprint/your_dataset_folder/\", # fp_input_NETWORK_STATION_CHANNEL.json directory \"fp_params\": [\"fp_input_CI_TPC_EHZ.json\", \"fp_input_CI_RMR_EHZ.json\", \"fp_input_CI_RMM_EHZ.json\", \"fp_input_CI_HEC_BHE.json\", \"fp_input_CI_HEC_BHN.json\", \"fp_input_CI_HEC_BHZ.json\", \"fp_input_CI_CPM_EHZ.json\", \"fp_input_CI_GTM_EHZ.json\", \"fp_input_CI_CDY_EHZ.json\"] } After your data is ready, you can begin fingerprinting. Make sure your fp_input_NETWORK_STATION_CHANNEL.json files are pointing to the correct decimated waveform files and directory otherwise FAST will not write to global index. Fingerprinting is complete when you see: If you get an error when FAST tries to write global index, check global_indices.json to make sure there are not any disceprencies between config.json and globali_indices.sjon , such as a station being included in config.json but left out of global_indices.json Now you can begin similarity search Create an output_Dataset_pairs.sh script similar to ~/FAST/parameters/postprocess/output_HectorMine_pairs.sh for your dataset. Create an combine_Dataset_pairs.sh script similar to ~/FAST/parameters/postprocess/combine_HectorMine_pairs.sh for your dataset. Follow instructions for running output_Dataset_pairs.sh and combine_Dataset_pairs.sh in Tutorial . If a station and its channels are stuck when merging files while running combine_Dataset_pairs.sh , remove it from output_Dataset_pairs.sh . Rerun output_Dataset_pairs.sh then combine_Dataset_pairs.sh . Configure parameters in ~/FAST/parameters/postprocess/7sta_2stathresh_network_params.json for your dataset. Change the 7 in the file name to the number of stations in your dataset. Run python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json Clean up results: Change file path in arrange_network_detection_results.py if you changed the file name of 7sta_2stathresh_network_params.json Change nsta to number of stations in your dataset in arrange_network_detection_results.py and n_sta in delete_overlap_network_detections.py Also change file path name in remove_duplicates_after_network.sh , delete_overlap_network_detections.py , and final_network_sort_nsta_peaksum.sh ~/FAST$ cd utils/network/ ~/FAST/utils/network$ python arrange_network_detection_results.py ~/FAST/utils/network$ ./remove_duplicates_after_network.sh ~/FAST/utils/network$ python delete_overlap_network_detections.py ~/FAST/utils/network$ ./final_network_sort_nsta_peaksum.sh Continue with next steps in tutorial Plot detected earthquakes (change file paths in PARTIALplot_detected_waveforms_HectorMine.py ): 24 25 [ det_start_ind , det_end_ind , dL , nevents , nsta , tot_ndets , max_ndets , tot_vol , max_vol , peaksum , num_sta , diff_ind ] = np . loadtxt ( times_dir + 'sort_nsta_peaksum_6sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt' , usecols = ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ), unpack = True ) # change file name out_dir = times_dir + '6sta_2stathresh_NetworkWaveformPlots/' # change file name * Change start time 39 init_time = UTCDateTime ( '2021-06-05T00:00:00.00' ) # global start time for all channels Change directory for waveform files and change format if different 50 st = read ( ts_dir + 'waveforms_priority_BP/Deci*' , format = 'MSEED' ) (Steps in tutorial) ~/FAST/utils/network$ cd .. ~/FAST/utils$ cd events/ ~/FAST/utils/events$ python PARTIALplot_detected_waveforms_HectorMine.py 0 100 Continue with next step of setting threshold Make changes to output_final_detection_list.py : 10 11 12 infile_name = 'EQ_sort_nsta_peaksum_6sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt' outfile_name = times_dir + 'FINAL_Detection_List_HectorMine_6sta_2stathresh.txt' init_time = UTCDateTime ( '2021-06-05T00:00:00.00' ) # global start time for all channels Now, follow the steps in Phase Picking and Earthquake Location .","title":"FAST Checklist"},{"location":"FAST_checklist/#checklist-for-running-fast-on-your-own-dataset","text":"Info Follow along with the tutorial section to make sure you follow the correct steps for FAST while using your own dataset. In most cases, if something does not run correctly, there is likely an issue with the file path or file name that users must fix. Follow install instructions: Google Colab , Linux , or Docker Get seismic data Put seismic data folder in ~/FAST/data/ Plot sample spectrograms to decided decimate factor and min/max frequency. Python script found in ~/FAST/utils/preprocess : plot_sample_spectrograms.py Check sampling rate of waveform data for decimate value >>> st = read(\u201cAZ.TONN*\u201c) >>> print(st) 3 Trace(s) in Stream: AZ.TONN..HNE | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples AZ.TONN..HNN | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples AZ.TONN..HNZ | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples >>> st = read(\u201cCI.CRR*\u201c) >>> print(st) 3 Trace(s) in Stream: CI.CRR..HHE | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples CI.CRR..HHN | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples CI.CRR..HHZ | 2021-06-05T00:00:00.008300Z - 2021-06-05T23:59:59.998300Z | 100.0 Hz, 8640000 samples Choose sampling rate for fingerprinting: If chosen sampling rate is 25 Hz, and trace sampling rate is 200 Hz, choose a decimate factor of 8 If chosen sampling rate is 25 Hz, and trace sampling rate is 100 Hz, choose a decimate factor of 4 Use ~/FAST/utils/preprocess/bandpass_filter_decimate.py and create a bash script similar to ~/FAST/utils/preprocess/mdl_bandpass_filter.sh to filter waveforms. Make sure to change input directory and consider creating an output directory for the decimated waveform files. Change input directory in ~/FAST/utils/preprocess/bandpass_filter_decimate.py 65 66 67 68 69 70 ts_dir = '/lfs/1/ceyoon/TimeSeries/NEP/waveforms' + station + '/' # change input directory to reference where your waveforms are out_dir = '../../data/waveforms_decimated/' # consider creating an output directory if not os . path . exists ( out_dir ): # create directory if it doesn't exist os . mkdir ( out_dir ) Change where output files are written 114 st . write ( ts_dir + str_prefix + file_str , format = format_str ) # change ts_dir to out_dir >>> st = read(\u201cAZ.TONN*\u201c) >>> print(st) 3 Trace(s) in Stream: AZ.TONN..HNE | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples AZ.TONN..HNN | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples AZ.TONN..HNZ | 2021-06-05T00:00:00.001900Z - 2021-06-05T23:59:59.990308Z | 200.0 Hz, 17280000 samples The above waveform is 200 Hz, so the decimate factor should be 8, for the FAST fingerprint sampling rate to be 25 Hz: python bandpass_filter_decimate.py AZ TONN HNZ 4 12 8 # 4: min frequency # 12: max frequency # 8: decimate value 4 - 12 Hz is a good general min/max frequency range for most waveform files. The decimate value depends on the sampling rate. Follow the guide above to choose this value. Create fingerprint input json files for each channel at each station in your dataset. Example: { \"fingerprint\": { \"sampling_rate\": 25, # final sampling rate after decimating \"min_freq\": 4.0, \"max_freq\": 12.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 1, \"mad_sample_interval\": 86400 }, \"performance\": { \"num_fp_thread\": 16, \"partition_len\": 86400 }, \"data\": { \"station\": \"WLA06\", \"channel\": \"HNE\", \"start_time\": \"21-06-05T00:00:00.0\", \"end_time\": \"21-06-06T00:00:00.0\", \"folder\": \"data/waveforms/\", # folder where decimated waveform files are located \"fingerprint_files\": [ \"Deci4.bp2to20.YR.ED04..HHZ.D.2016.303\"], \"MAD_sample_files\": [ \"Deci4.bp2to20.YR.ED04..HHZ.D.2016.303\"] } } Put all fp_input_NETWORK_STATION_CHANNEL.json files in ~/FAST/config.json and ~/FAST/parameters/fingerprint/your_dataset_folder/global_indices.json ; Example: { \"index_folder\": \"../data/global_indices/\", \"fp_param_dir\": \"../parameters/fingerprint/your_dataset_folder/\", # fp_input_NETWORK_STATION_CHANNEL.json directory \"fp_params\": [\"fp_input_CI_TPC_EHZ.json\", \"fp_input_CI_RMR_EHZ.json\", \"fp_input_CI_RMM_EHZ.json\", \"fp_input_CI_HEC_BHE.json\", \"fp_input_CI_HEC_BHN.json\", \"fp_input_CI_HEC_BHZ.json\", \"fp_input_CI_CPM_EHZ.json\", \"fp_input_CI_GTM_EHZ.json\", \"fp_input_CI_CDY_EHZ.json\"] } After your data is ready, you can begin fingerprinting. Make sure your fp_input_NETWORK_STATION_CHANNEL.json files are pointing to the correct decimated waveform files and directory otherwise FAST will not write to global index. Fingerprinting is complete when you see: If you get an error when FAST tries to write global index, check global_indices.json to make sure there are not any disceprencies between config.json and globali_indices.sjon , such as a station being included in config.json but left out of global_indices.json Now you can begin similarity search Create an output_Dataset_pairs.sh script similar to ~/FAST/parameters/postprocess/output_HectorMine_pairs.sh for your dataset. Create an combine_Dataset_pairs.sh script similar to ~/FAST/parameters/postprocess/combine_HectorMine_pairs.sh for your dataset. Follow instructions for running output_Dataset_pairs.sh and combine_Dataset_pairs.sh in Tutorial . If a station and its channels are stuck when merging files while running combine_Dataset_pairs.sh , remove it from output_Dataset_pairs.sh . Rerun output_Dataset_pairs.sh then combine_Dataset_pairs.sh . Configure parameters in ~/FAST/parameters/postprocess/7sta_2stathresh_network_params.json for your dataset. Change the 7 in the file name to the number of stations in your dataset. Run python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json Clean up results: Change file path in arrange_network_detection_results.py if you changed the file name of 7sta_2stathresh_network_params.json Change nsta to number of stations in your dataset in arrange_network_detection_results.py and n_sta in delete_overlap_network_detections.py Also change file path name in remove_duplicates_after_network.sh , delete_overlap_network_detections.py , and final_network_sort_nsta_peaksum.sh ~/FAST$ cd utils/network/ ~/FAST/utils/network$ python arrange_network_detection_results.py ~/FAST/utils/network$ ./remove_duplicates_after_network.sh ~/FAST/utils/network$ python delete_overlap_network_detections.py ~/FAST/utils/network$ ./final_network_sort_nsta_peaksum.sh Continue with next steps in tutorial Plot detected earthquakes (change file paths in PARTIALplot_detected_waveforms_HectorMine.py ): 24 25 [ det_start_ind , det_end_ind , dL , nevents , nsta , tot_ndets , max_ndets , tot_vol , max_vol , peaksum , num_sta , diff_ind ] = np . loadtxt ( times_dir + 'sort_nsta_peaksum_6sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt' , usecols = ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ), unpack = True ) # change file name out_dir = times_dir + '6sta_2stathresh_NetworkWaveformPlots/' # change file name * Change start time 39 init_time = UTCDateTime ( '2021-06-05T00:00:00.00' ) # global start time for all channels Change directory for waveform files and change format if different 50 st = read ( ts_dir + 'waveforms_priority_BP/Deci*' , format = 'MSEED' ) (Steps in tutorial) ~/FAST/utils/network$ cd .. ~/FAST/utils$ cd events/ ~/FAST/utils/events$ python PARTIALplot_detected_waveforms_HectorMine.py 0 100 Continue with next step of setting threshold Make changes to output_final_detection_list.py : 10 11 12 infile_name = 'EQ_sort_nsta_peaksum_6sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt' outfile_name = times_dir + 'FINAL_Detection_List_HectorMine_6sta_2stathresh.txt' init_time = UTCDateTime ( '2021-06-05T00:00:00.00' ) # global start time for all channels Now, follow the steps in Phase Picking and Earthquake Location .","title":"Checklist for running FAST on Your Own Dataset"},{"location":"FAST_output/","text":"Output \u00b6 Network Detection Outputs \u00b6 Event resolution: final step after pseudo-association Pairs of similar fingerprints --> list of event detections Network Detection Output (text file with labeled columns) Example (ranked in descending order of \u2018peaksum\u2019): 7sta_2stathresh_detlist_rank_by_peaksum.txt First (num_sta = number of stations) columns: starting fingerprint index at each station (time information) Outputs \u201cnan\u201d if not observed at a particular station dL : Maximum length (samples) along diagonal, overall event-pairs containing this event nevents : Number of other events \u2018linked\u2019 to (similar to) this event nsta : Number of stations over which other events are similar to this event tot_ndets : Total number of fingerprint-pairs (pixels) containing this event, overall event-pair clusters, over all stations max_ndets : Maximum number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations tot_vol : Totalsum (or \u2018volume\u2019 )of all similarity values (added overall stations), over all event-pairs containing this event max_vol : Maximum sum (or \u2018volume\u2019) of all similarity values (added overall stations), over all event-pairs containing this event max_peaksum : Maximum similarity value (added overall stations), overall event-pairs containing this event","title":"FAST Output"},{"location":"FAST_output/#output","text":"","title":"Output"},{"location":"FAST_output/#network-detection-outputs","text":"Event resolution: final step after pseudo-association Pairs of similar fingerprints --> list of event detections Network Detection Output (text file with labeled columns) Example (ranked in descending order of \u2018peaksum\u2019): 7sta_2stathresh_detlist_rank_by_peaksum.txt First (num_sta = number of stations) columns: starting fingerprint index at each station (time information) Outputs \u201cnan\u201d if not observed at a particular station dL : Maximum length (samples) along diagonal, overall event-pairs containing this event nevents : Number of other events \u2018linked\u2019 to (similar to) this event nsta : Number of stations over which other events are similar to this event tot_ndets : Total number of fingerprint-pairs (pixels) containing this event, overall event-pair clusters, over all stations max_ndets : Maximum number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations tot_vol : Totalsum (or \u2018volume\u2019 )of all similarity values (added overall stations), over all event-pairs containing this event max_vol : Maximum sum (or \u2018volume\u2019) of all similarity values (added overall stations), over all event-pairs containing this event max_peaksum : Maximum similarity value (added overall stations), overall event-pairs containing this event","title":"Network Detection Outputs"},{"location":"about/","text":"Est non fitque \u00b6 Ruit tum ore super sed perstat rebus \u00b6 Lorem markdownum innumeras auctor Pergama levis corpore egressa pedem! Sine mihi postibus perenni; somni nulla. Byblis ferae Lycaon gemelliparae videt inspicitur imagine dedit nobis, et clauditur vocem. In ab, ille quippe volat sensi culpa audit utque delicuit videre tulit talis primum, sine . Vulnere et cornua dicere captivarum intravit, ossa Claninque, propago. Ferendum Melaneus minimo, ut extra veri pius: sua per sonat gutture: per usque. Sole terras, spoliataque probabo iustius obstantis solque ardetque Cythereius duro . Sententia Tlepolemus huius cui ferox cuique vulgata \u00b6 Nunc signo diu monitusque, cunctis, tum Teucri ulla felix quercum, consorti motu repetitaque? Vulnere grata contigit caeruleas pietas aequore dixit : emerguntque velis corpora voluptas , obruta nec ibat vultus quae. Ventos vires , unus: idem est Lycei impete fulvis. Erat et sed gaudent cruore muris! Hominumque possem; rediere hic moles gemmae tempus huc enim digitoque. Nidos aliisque Gorgoneas \u00b6 Vix spes secutum de indiciumque manu cuiquam status morsibus curvamine in semper mente dum. Et suis Cadmeida exaudi audent ut summa, tendere, more. Magna retexi flexi medio deprenduntur verba, ambarum servasset prohibete Aeson! Mea esse aliquid faciet numine barbaricoque Delphos Hospitio sacra Quae vos missum quibus enim vellem ligno Iam non alumnus manibus consensistis errat est Fugit patulo communis Triviae nos secreta Vox adflat qui, iram prius ille iuga altera potentia membris efficient. Umbram aequoris, laeso alto commisit loquaci. Responsaque aequoreae; rogata eligit labuntur sedes mortales . Temptabat inque. Reget tria ita sensit rebus fretum illic mortalem trahit locuti labori mea clamor vulnera hi obstaret interea? Rictus inmani leves rapiunt forte excidit! Structoque per patria pudore respicit fulmineo iubet cura euntem mea iungi flectitque. Fama rigidique nostraque petii lumina et Thestias te Syron Balearica excutior ne abire sumpserat mihi.","title":"Est non fitque"},{"location":"about/#est-non-fitque","text":"","title":"Est non fitque"},{"location":"about/#ruit-tum-ore-super-sed-perstat-rebus","text":"Lorem markdownum innumeras auctor Pergama levis corpore egressa pedem! Sine mihi postibus perenni; somni nulla. Byblis ferae Lycaon gemelliparae videt inspicitur imagine dedit nobis, et clauditur vocem. In ab, ille quippe volat sensi culpa audit utque delicuit videre tulit talis primum, sine . Vulnere et cornua dicere captivarum intravit, ossa Claninque, propago. Ferendum Melaneus minimo, ut extra veri pius: sua per sonat gutture: per usque. Sole terras, spoliataque probabo iustius obstantis solque ardetque Cythereius duro .","title":"Ruit tum ore super sed perstat rebus"},{"location":"about/#sententia-tlepolemus-huius-cui-ferox-cuique-vulgata","text":"Nunc signo diu monitusque, cunctis, tum Teucri ulla felix quercum, consorti motu repetitaque? Vulnere grata contigit caeruleas pietas aequore dixit : emerguntque velis corpora voluptas , obruta nec ibat vultus quae. Ventos vires , unus: idem est Lycei impete fulvis. Erat et sed gaudent cruore muris! Hominumque possem; rediere hic moles gemmae tempus huc enim digitoque.","title":"Sententia Tlepolemus huius cui ferox cuique vulgata"},{"location":"about/#nidos-aliisque-gorgoneas","text":"Vix spes secutum de indiciumque manu cuiquam status morsibus curvamine in semper mente dum. Et suis Cadmeida exaudi audent ut summa, tendere, more. Magna retexi flexi medio deprenduntur verba, ambarum servasset prohibete Aeson! Mea esse aliquid faciet numine barbaricoque Delphos Hospitio sacra Quae vos missum quibus enim vellem ligno Iam non alumnus manibus consensistis errat est Fugit patulo communis Triviae nos secreta Vox adflat qui, iram prius ille iuga altera potentia membris efficient. Umbram aequoris, laeso alto commisit loquaci. Responsaque aequoreae; rogata eligit labuntur sedes mortales . Temptabat inque. Reget tria ita sensit rebus fretum illic mortalem trahit locuti labori mea clamor vulnera hi obstaret interea? Rictus inmani leves rapiunt forte excidit! Structoque per patria pudore respicit fulmineo iubet cura euntem mea iungi flectitque. Fama rigidique nostraque petii lumina et Thestias te Syron Balearica excutior ne abire sumpserat mihi.","title":"Nidos aliisque Gorgoneas"},{"location":"brazil_dataset/","text":"0.9 BrazilAcre Data Set \u00b6 Location: Acre, Brazil (search for intermediate-depth and deep earthquakes) Duration: about 3 months (with time gaps): 2015-05-28 to 2016-02-01 Network: 1 station (Figure 14), 3 components (HHE, HHN, HHZ) = 3 channels. \u2022 Sampling rate: 100 Hz Provided by: Marcelo de Bianchi (University of Sao Paulo) Figure 14: Acre, Brazil map provided by Marcelo de Bianchi: 1 station (yellow triangle) used for FAST detection, and locations of known catalog events (circles colored by depth). 0.9.1 Preprocessing \u00b6 Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/continuous_data_times_BrazilAcre.sh The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_BrazilAcre.py to plot the duration of available continuous data at each station and channel (Figure 15). Figure 15: Duration of BrazilAcre continuous data at 1 station (3 components). White sections indicate time gaps. Confirmed no zero-filled time-gap sections of continuous data in all 3 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py): ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Use original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/sample_spectrograms_BrazilAcre.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/bandpass_filter_decimate_BrazilAcre.sh Based on sample spectrograms, filter 3-20 Hz for all 3 channels. Decimate by a factor of 2, to 50 Hz sampling rate. Filtered continuous data files start with Deci2.bp3to20.*, which are input to the fingerprint step. Need to add .mseed extension to all time series files, otherwise the Julian day number in the time series file gets removed while fingerprinting, and we cannot tell the difference between fingerprints from different days. 0.9.2 Fingerprint \u00b6 Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/BrazilAcre/run_fp_BrazilAcre.sh Example script to generate fingerprints on one channel (HHE) at one station (CZSB), called by the master script run_fp_BrazilAcre.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/BrazilAcre/fp_input_BR_CZSB_HHE.json \"fingerprint\": { \"sampling_rate\": 50, \"min_freq\": 3.0, \"max_freq\": 20.0, \"spec_length\": 10.0, \"spec_lag\": 0.2, \"fp_length\": 128, Continuous Data (Network.Station.Channel) \"fp_lag\": 10, \"k_coef\": 800, \"nfreq\": 32, \"mad_sampling_rate\": 0.1, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"CZSB\", \"channel\": \"HHE\", \"start_time\": \"15-10-28T00:00:00.0\", \"end_time\": \"16-02-01T00:00:03.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/\", There are a total of 3 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S25. Table S25: Fingerprint input parameters for BrazilAcre earthquake detection: 3-component at 1 station (Figure 14, yellow triangle), after bandpass filter 3-20 Hz, and decimated to 50 Hz sampling rate. The fingerprint sampling period is dt_fp = 2 seconds. Median/MAD output files: mad/mad*.txt Fingerprints (binary files): fingerprints/CZSB.HHE.fp Timestamps at each fingerprint index (text files): timestamps/CZSB.HHE.ts Finally, to create global indices for the BrazilAcre data set, so that fingerprint indices from different channels (all 3) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/BrazilAcre/global_indices_BrazilAcre.json The common starting time is in global_idx_stats.txt: 2015-10-28T00:00:21.340000 UTC 0.9.3 Similarity Search \u00b6 Master script to run similarity search on each channel (out of 3 total): ~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/run_simsearch_BrazilAcre.sh Example script to run similarity search on one channel (HHE) at one station (CZSB), called by the master script run_simsearch_BrazilAcre.sh : ~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/filt_simsearch_input_BrazilAcre.sh CZSB HHE NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 Table S26: Similarity search input parameters for BrazilAcre earthquake detection: 3 channels at 1 station (3 components each). The same input parameters are used for similarity search on all 3 channels (Table S26). 0.9.4 Postprocessing \u00b6 First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (3 total): ~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/output_BrazilAcre_pairs.sh For example, on one channel (HHE) at one station (CZSB), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ -p candidate_pairs_CZSB_HHE -i /lfs/1/ceyoon/TimeSeries/BrazilAcre/global_indices/CZSB_HHE_idx_mapping.txt Output file for example (large size at channel level): / lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ candidate_pairs_CZSB_HHE_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for 1 station: ~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/combine_BrazilAcre_pairs.sh For example, on three channels (HHE, HHN, HHZ) at one station (CZSB), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ $ mv candidate_pairs_CZSB_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S26). Note: this step will delete the candidate_ pairs_CZSB_HH*_merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ -p candidate_pairs_CZSB --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ candidate_pairs_CZSB_combined.txt Finally, detect similar fingerprints across the network of 1 station, using the input parameters in Table S27 (Note: this step only aggregates similar event pairs from similar fingerprints, and resolves the pairs into a list of candidate events, since there is only 1 station.): ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/BrazilAcre/1sta_1stathresh_network_params.json \"network\": { \"max_fp\": 4147182, \"dt_fp\": 2.0, (seconds) \"dgapL\": 10, (20 s) \"dgapW\": 3, (6 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (16 s) \"ivals_thresh\": 6, \"nsta_thresh\": 1, \"input_offset\": 15 (30 s) <--- NOT USED }, Table S27: Network detection input parameters for BrazilAcre at 1 station. max_fp = 4147182 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 2 seconds is the fingerprint sampling period from Table S25. Network detection output file: /lfs/1/ceyoon/TimeSeries/BrazilAcre/network_detection/1sta_1stathresh_detlist_rank_by_peaksum.tx t (14,477 events) At this point, FAST earthquake detection processing is done. 0.9.5 Remove duplicates after network detection \u00b6 Sort events in descending order of peaksum (peak similarity score between similar fingerprints) for the final detection list. ~/FAST/utils/network/$ ./final_single_station_sort_nsta_peaksum.sh Output: sort_peaksum_1sta_1stathresh_CZSB_events.txt (14,477 events) 0.9.6 Visual inspection and final detections \u00b6 Plot event waveforms in the final detection list, ranked in descending order of peaksum (peak similarity score between similar fingerprints), for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (peaksum \u2265 6). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_BrazilAcre.py 0 14477 Output: .png image files in 1sta_1stathresh_NetworkWaveformPlots/ (zip file) Visual inspection shows that there are many false detections that do not look like earthquake waveforms (for example, event_rank00000_peaksum116351_ind854248_time1708496.0_2015-11-16T18/35/17.340000.png ). However, some earthquake waveforms (for example, event_rank00049_peaksum26898_ind1297608_time2595216 . 0_2015-11-27T00/53/57.340000.png ) are also detected. I suggest running FAST on at least 3 stations for reliable earthquake detection. 14,474 events are above the arbitrary low threshold (peaksum \u2265 6). EQ_sort_peaksum_1sta_1stathresh_CZSB_events.txt For the 14,474 events, output a catalog-like formatted list: ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_BrazilAcre_1sta_1stathresh_peaksum6.txt (14,474 events)","title":"0.9 BrazilAcre Data Set"},{"location":"brazil_dataset/#09-brazilacre-data-set","text":"Location: Acre, Brazil (search for intermediate-depth and deep earthquakes) Duration: about 3 months (with time gaps): 2015-05-28 to 2016-02-01 Network: 1 station (Figure 14), 3 components (HHE, HHN, HHZ) = 3 channels. \u2022 Sampling rate: 100 Hz Provided by: Marcelo de Bianchi (University of Sao Paulo) Figure 14: Acre, Brazil map provided by Marcelo de Bianchi: 1 station (yellow triangle) used for FAST detection, and locations of known catalog events (circles colored by depth).","title":"0.9 BrazilAcre Data Set"},{"location":"brazil_dataset/#091-preprocessing","text":"Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/continuous_data_times_BrazilAcre.sh The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_BrazilAcre.py to plot the duration of available continuous data at each station and channel (Figure 15). Figure 15: Duration of BrazilAcre continuous data at 1 station (3 components). White sections indicate time gaps. Confirmed no zero-filled time-gap sections of continuous data in all 3 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py): ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Use original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/sample_spectrograms_BrazilAcre.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/bandpass_filter_decimate_BrazilAcre.sh Based on sample spectrograms, filter 3-20 Hz for all 3 channels. Decimate by a factor of 2, to 50 Hz sampling rate. Filtered continuous data files start with Deci2.bp3to20.*, which are input to the fingerprint step. Need to add .mseed extension to all time series files, otherwise the Julian day number in the time series file gets removed while fingerprinting, and we cannot tell the difference between fingerprints from different days.","title":"0.9.1 Preprocessing"},{"location":"brazil_dataset/#092-fingerprint","text":"Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/BrazilAcre/run_fp_BrazilAcre.sh Example script to generate fingerprints on one channel (HHE) at one station (CZSB), called by the master script run_fp_BrazilAcre.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/BrazilAcre/fp_input_BR_CZSB_HHE.json \"fingerprint\": { \"sampling_rate\": 50, \"min_freq\": 3.0, \"max_freq\": 20.0, \"spec_length\": 10.0, \"spec_lag\": 0.2, \"fp_length\": 128, Continuous Data (Network.Station.Channel) \"fp_lag\": 10, \"k_coef\": 800, \"nfreq\": 32, \"mad_sampling_rate\": 0.1, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"CZSB\", \"channel\": \"HHE\", \"start_time\": \"15-10-28T00:00:00.0\", \"end_time\": \"16-02-01T00:00:03.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/\", There are a total of 3 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S25. Table S25: Fingerprint input parameters for BrazilAcre earthquake detection: 3-component at 1 station (Figure 14, yellow triangle), after bandpass filter 3-20 Hz, and decimated to 50 Hz sampling rate. The fingerprint sampling period is dt_fp = 2 seconds. Median/MAD output files: mad/mad*.txt Fingerprints (binary files): fingerprints/CZSB.HHE.fp Timestamps at each fingerprint index (text files): timestamps/CZSB.HHE.ts Finally, to create global indices for the BrazilAcre data set, so that fingerprint indices from different channels (all 3) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/BrazilAcre/global_indices_BrazilAcre.json The common starting time is in global_idx_stats.txt: 2015-10-28T00:00:21.340000 UTC","title":"0.9.2 Fingerprint"},{"location":"brazil_dataset/#093-similarity-search","text":"Master script to run similarity search on each channel (out of 3 total): ~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/run_simsearch_BrazilAcre.sh Example script to run similarity search on one channel (HHE) at one station (CZSB), called by the master script run_simsearch_BrazilAcre.sh : ~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/filt_simsearch_input_BrazilAcre.sh CZSB HHE NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 Table S26: Similarity search input parameters for BrazilAcre earthquake detection: 3 channels at 1 station (3 components each). The same input parameters are used for similarity search on all 3 channels (Table S26).","title":"0.9.3 Similarity Search"},{"location":"brazil_dataset/#094-postprocessing","text":"First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (3 total): ~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/output_BrazilAcre_pairs.sh For example, on one channel (HHE) at one station (CZSB), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ -p candidate_pairs_CZSB_HHE -i /lfs/1/ceyoon/TimeSeries/BrazilAcre/global_indices/CZSB_HHE_idx_mapping.txt Output file for example (large size at channel level): / lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ candidate_pairs_CZSB_HHE_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for 1 station: ~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/combine_BrazilAcre_pairs.sh For example, on three channels (HHE, HHN, HHZ) at one station (CZSB), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ $ mv candidate_pairs_CZSB_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S26). Note: this step will delete the candidate_ pairs_CZSB_HH*_merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ -p candidate_pairs_CZSB --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ candidate_pairs_CZSB_combined.txt Finally, detect similar fingerprints across the network of 1 station, using the input parameters in Table S27 (Note: this step only aggregates similar event pairs from similar fingerprints, and resolves the pairs into a list of candidate events, since there is only 1 station.): ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/BrazilAcre/1sta_1stathresh_network_params.json \"network\": { \"max_fp\": 4147182, \"dt_fp\": 2.0, (seconds) \"dgapL\": 10, (20 s) \"dgapW\": 3, (6 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (16 s) \"ivals_thresh\": 6, \"nsta_thresh\": 1, \"input_offset\": 15 (30 s) <--- NOT USED }, Table S27: Network detection input parameters for BrazilAcre at 1 station. max_fp = 4147182 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 2 seconds is the fingerprint sampling period from Table S25. Network detection output file: /lfs/1/ceyoon/TimeSeries/BrazilAcre/network_detection/1sta_1stathresh_detlist_rank_by_peaksum.tx t (14,477 events) At this point, FAST earthquake detection processing is done.","title":"0.9.4 Postprocessing"},{"location":"brazil_dataset/#095-remove-duplicates-after-network-detection","text":"Sort events in descending order of peaksum (peak similarity score between similar fingerprints) for the final detection list. ~/FAST/utils/network/$ ./final_single_station_sort_nsta_peaksum.sh Output: sort_peaksum_1sta_1stathresh_CZSB_events.txt (14,477 events)","title":"0.9.5 Remove duplicates after network detection"},{"location":"brazil_dataset/#096-visual-inspection-and-final-detections","text":"Plot event waveforms in the final detection list, ranked in descending order of peaksum (peak similarity score between similar fingerprints), for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (peaksum \u2265 6). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_BrazilAcre.py 0 14477 Output: .png image files in 1sta_1stathresh_NetworkWaveformPlots/ (zip file) Visual inspection shows that there are many false detections that do not look like earthquake waveforms (for example, event_rank00000_peaksum116351_ind854248_time1708496.0_2015-11-16T18/35/17.340000.png ). However, some earthquake waveforms (for example, event_rank00049_peaksum26898_ind1297608_time2595216 . 0_2015-11-27T00/53/57.340000.png ) are also detected. I suggest running FAST on at least 3 stations for reliable earthquake detection. 14,474 events are above the arbitrary low threshold (peaksum \u2265 6). EQ_sort_peaksum_1sta_1stathresh_CZSB_events.txt For the 14,474 events, output a catalog-like formatted list: ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_BrazilAcre_1sta_1stathresh_peaksum6.txt (14,474 events)","title":"0.9.6 Visual inspection and final detections"},{"location":"calipatria_dataset/","text":"0.11 Calipatria, June 2021 \u00b6 Get stations and waveform data in directory: /app/data/20210605_Calipatria_data/ (eq_fast) root@6006660926e5:/app# cd parameters/preprocess/Calipatria/ Get station data in directory: /app/data/20210605_Calipatria_data/stations/ (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_station_list_Calipatria.py For these stations, download waveform data in directory: /app/data/20210605_Calipatria_data/waveforms/ Try the mass downloader first. Then try the get_waveforms function from client directly to get any data missed from mass downloader. You may need to run waveform download scripts multiple times to get all data. (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_waveforms_mdl_Calipatria.py (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_station_list_Calipatria.py Not all stations from the original station list will have downloadable waveform data. Clean up the station list so that only stations with downloaded waveform data are included. (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python clean_station_list_Calipatria.py Need to manually arrange downloaded MSEED data into directories, with one directory per station named as: /app/data/20210605_Calipatria_data/waveforms${STATION_NAME}/ Preprocess \u00b6 apply 4-12 Hz bandpass filter to all MSEED data, decimate to 25 Hz (factor of 4 for 100-sps data; factor of 8 for 200-sps data). This script will output MSEED data named with \u201cDeci..\u201d to be used in FAST. (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# cd ../../../utils/preprocess/ (eq_fast) root@6006660926e5:/app/utils/preprocess# ../../parameters/preprocess/Calipatria/bandpass_filter_decimate_Calipatria.sh Fingerprint \u00b6 43 stations, 113 channels (eq_fast) root@6006660926e5:/app/utils/preprocess# cd ../../fingerprint/ (eq_fast) root@6006660926e5:/app/fingerprint# ../parameters/fingerprint/Calipatria/run_fp_Calipatria.sh Similarity Search \u00b6 Ended up not using 6 PB stations (18 channels). Now 37 stations, 95 channels (eq_fast) root@6006660926e5:/app/fingerprint# cd ../simsearch/ (eq_fast) root@6006660926e5:/app/simsearch# ../parameters/simsearch/Calipatria/run_simsearch_calipatria.sh Postprocessing \u00b6 (eq_fast) root@6006660926e5:/app/simsearch# cd ../postprocessing/ (eq_fast) root@6006660926e5:/app/postprocessing# ../parameters/postprocess/Calipatria/output_calipatria_pairs.sh (eq_fast) root@6006660926e5:/app/postprocessing# ../parameters/postprocess/Calipatria/combine_calipatria_pairs.sh Network detection \u00b6 If list index out of range in partition, fails to keep running -> try 1 partition (eq_fast) root@6006660926e5:/app/postprocessing# python scr_run_network_det.py ../parameters/postprocess/Calipatria/37sta_3stathresh_network_params.json Postprocess: Clean Network Detection Results \u00b6 (eq_fast) root@6006660926e5:/app/postprocessing# cd ../utils/network/ (eq_fast) root@6006660926e5:/app/utils/network# python arrange_network_detection_results.py Input parameter changes made to arrange_network_detection_results.py (from Hector Mine -> Calipatria) 4 5 6 det_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / \u2019 network_file = \u2018 37 sta_3stathresh_detlist_rank_by_peaksum . txt \u2019 nsta = 37 (eq_fast) root@6006660926e5:/app/utils/network# ./remove_duplicates_after_network.sh Input parameter changes made to remove_duplicates_after_network.sh (from Hector Mine -> Calipatria) 4 5 cd ../../ data / 20210605 _Calipatria_Data / network_detection / NETWORK_FILE = NetworkDetectionTimes_37sta_3stathresh_detlist_rank_by_peaksum . txt (eq_fast) root@6006660926e5:/app/utils/network# python delete_overlap_network_detections.py Input parameter changes made to delete_overlap_network_detections.py (from Hector Mine -> Calipatria) 4 5 6 7 input_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / \u2019 allfile_name = input_dir + \u2018 uniquestart_sorted_no_duplicates . txt \u2019 outfile_name = input_dir + \u2018 37 sta_3stathresh_FinalUniqueNetworkDetectionTimes . txt \u2019 n_sta = 37 (eq_fast) root@6006660926e5:/app/utils/network# ./final_network_sort_nsta_peaksum.sh Input parameter changes made to final_network_sort_nsta_peaksum.sh (from Hector Mine -> Calipatria) 4 5 cd ../../ data / 20210605 _Calipatria_Data / network_detection / NETWORK_FILE = 37 sta_3stathresh_FinalUniqueNetworkDetectionTimes . txt Visualize the FAST output (739 events) \u00b6 (eq_fast) root@6006660926e5:/app/utils/network# cat ../../data/20210605_Calipatria_Data/network_detection/sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt Display FAST detection waveforms, descending order of peaksum-similarity \u00b6 (eq_fast) root@6006660926e5:/app/utils/network# cd ../events/ (eq_fast) root@6006660926e5:/app/utils/events# python PARTIALplot_detected_waveforms_Calipatria.py 0 739 Input parameter changes made to PARTIALplot_detected_waveforms_Calipatria.py (from Hector Mine -> Calipatria) 23 times_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / \u2019 25 out_dir = times_dir + \u2018 37 sta_3stathresh_NetworkWaveformPlots / \u2019 30 dt_fp = 1.2 37 init_time = UTCDateTime ( \u2018 2021 - 06 - 05 T00 : 00 : 06.840000 \u2019 ) 47 48 ts_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 st = read ( ts_dir + \u2018 waveforms */ Deci * Z__20210605T000000Z__20210606T000000Z . mseed \u2019 ) # Plot only vertical component Set detection threshold - keep all events with at least 3 stations \u00b6 (eq_fast) root@6006660926e5:/app/utils/events# cd ../../data/20210605_Calipatria_Data/network_detection/ (eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/network_detection# head -739 sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt > EQ_sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt Output final FAST detected event list \u00b6 (eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/network_detection# cd ../../../utils/events/ (eq_fast) root@6006660926e5:/app/utils/events# python output_final_detection_list.py Input parameter changes made to output_final_detection_list.py (from Hector Mine -> Calipatria) 9 10 11 12 13 times_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / \u2019 infile_name = \u2018 EQ_sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes . txt \u2019 outfile_name = times_dir + \u2018 FINAL_Detection_List_Calipatria_37sta_3stathresh . txt \u2019 init_time = UTCDateTime ( \u2018 2021 - 06 - 05 T00 : 00 : 06.840000 \u2019 ) # global start time for all channels dt_fp = 1.2 (eq_fast) root@6006660926e5:/app/utils/events# cat ../../data/20210605_Calipatria_Data/network_detection/FINAL_Detection_List_Calipatria_37sta_3stathresh.txt Cut event SAC files for phase picking \u00b6 (eq_fast) root@6006660926e5:/app/utils/events# python cut_event_files.py Input parameter changes made to cut_event_files.py (from Hector Mine -> Calipatria) 20 21 22 23 24 25 26 27 28 29 30 stations = [ \u201c USGCB \u201d , \u201c BC3 \", \u201cBOM\u201d, \u201cCLI2\" , \u201c COA \u201d , \u201c COK2 \", \u201cCRR\u201d, \u201c CTC \u201d , \u201c CTW \u201d , \u201c DRE \u201d , \u201c ERR \u201d , \u201c FRK \u201d , \u201c IMP \u201d , \u201c NSS2 \", \u201c OCP \u201d , \u201c RXH \u201d , \u201c SAL \u201d , \u201c SLB \u201d , \u201c SLV \u201d , \u201c SNR \u201d , \u201c SWP \u201d , \u201c SWS \u201d , \u201c THM \u201d , \u201c WMD \u201d , \u201c WWF \u201d , \u201c 286 \", \u201c5056\u201d, \u201c5058\" , \u201c 5062 \u201d , \u201c 5271 \", \u201c5274\u201d, \u201c5444\" , \u201c WLA \u201d , \u201c WLA01 \", \u201cWLA03\u201d, \u201cWLA04\" , \u201c WLA06 \u201d ] in_mseed_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 in_FINAL_Detection_List = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / FINAL_Detection_List_Calipatria_37sta_3stathresh . txt \u2019 out_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / event_ids \u2019 init_time = UTCDateTime ( \u2018 2021 - 06 - 05 T00 : 00 : 06.840000 \u2019 , precision = 2 ) # global start time for all channels dt_fp = 1.2 80 st = read ( \u2018 ../../ data / 20210605 _Calipatria_Data / waveforms */ [ ! Deci ] *. mseed \u2019 ) Pick phases with SeisBench \u00b6 (eq_fast) root@6006660926e5:/app/utils/events# cd ../picking/ (eq_fast) root@6006660926e5:/app/utils/picking# python run_seisbench.py Input parameter changes made to run_seisbench.py (from Hector Mine -> Calipatria) 16 base_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 18 stations = [ \u2018 CLI2 \u2019 , \u2018 COK2 \u2019 , \u2018 OCP \u2019 , \u2018 SAL \u2019 , \u2018 WWF \u2019 , \u2018 5062 \u2019 , \u2018 5271 \u2019 , \u2018 5444 \u2019 ] Earthquake location with HYPOINVERSE \u00b6 (eq_fast) root@6006660926e5:/app/utils/picking# cd ../location/ (eq_fast) root@6006660926e5:/app/utils/location# python SeisBench2hypoinverse.py Input parameter changes made to SeisBench2hypoinverse.py (from Hector Mine -> Calipatria) 25 26 27 28 base_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 start_lat = 33.1 start_lon = - 115.6 start_depth = 5 (eq_fast) root@6006660926e5:/app/utils/location# python output_station_file.py Input parameter changes made to output_station_file.py (from Hector Mine -> Calipatria) 113 base_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 (eq_fast) root@6006660926e5:/app/utils/location# cd ../../data/20210605_Calipatria_Data/location_hypoinverse/ (eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/location_hypoinverse/# ../../../utils/location/hyp1.40/source/hyp1.40 COMMAND? @locate_events.hyp (eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/location_hypoinverse/# cd ../../../utils/location/ (eq_fast) root@6006660926e5:/app/utils/location# python output_hypoinverse_as_text.py Input parameter changes made to output_hypoinverse_as_text.py (from Hector Mine -> Calipatria) 12 13 catalog_start_time = UTCDateTime ( \u2018 2021 - 06 - 05 T00 : 00 : 06.840000 \u2019 ) loc_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / location_hypoinverse / \u2019 Mapping earthquake locations with PyGMT \u00b6 (eq_fast) root@6006660926e5:/app/utils/location# cd ../mapping/ (eq_fast) root@6006660926e5:/app/utils/mapping# conda deactivate root@6006660926e5:/app/utils/mapping# conda activate pygmt (pygmt) root@6006660926e5:/app/utils/mapping# python hypoinverse_to_pygmt_Calipatria.py Plots of detected earthquakes from FAST output","title":"0.11 Calipatria, June 2021"},{"location":"calipatria_dataset/#011-calipatria-june-2021","text":"Get stations and waveform data in directory: /app/data/20210605_Calipatria_data/ (eq_fast) root@6006660926e5:/app# cd parameters/preprocess/Calipatria/ Get station data in directory: /app/data/20210605_Calipatria_data/stations/ (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_station_list_Calipatria.py For these stations, download waveform data in directory: /app/data/20210605_Calipatria_data/waveforms/ Try the mass downloader first. Then try the get_waveforms function from client directly to get any data missed from mass downloader. You may need to run waveform download scripts multiple times to get all data. (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_waveforms_mdl_Calipatria.py (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python get_station_list_Calipatria.py Not all stations from the original station list will have downloadable waveform data. Clean up the station list so that only stations with downloaded waveform data are included. (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# python clean_station_list_Calipatria.py Need to manually arrange downloaded MSEED data into directories, with one directory per station named as: /app/data/20210605_Calipatria_data/waveforms${STATION_NAME}/","title":"0.11 Calipatria, June 2021"},{"location":"calipatria_dataset/#preprocess","text":"apply 4-12 Hz bandpass filter to all MSEED data, decimate to 25 Hz (factor of 4 for 100-sps data; factor of 8 for 200-sps data). This script will output MSEED data named with \u201cDeci..\u201d to be used in FAST. (eq_fast) root@6006660926e5:/app/parameters/preprocess/Calipatria# cd ../../../utils/preprocess/ (eq_fast) root@6006660926e5:/app/utils/preprocess# ../../parameters/preprocess/Calipatria/bandpass_filter_decimate_Calipatria.sh","title":"Preprocess"},{"location":"calipatria_dataset/#fingerprint","text":"43 stations, 113 channels (eq_fast) root@6006660926e5:/app/utils/preprocess# cd ../../fingerprint/ (eq_fast) root@6006660926e5:/app/fingerprint# ../parameters/fingerprint/Calipatria/run_fp_Calipatria.sh","title":"Fingerprint"},{"location":"calipatria_dataset/#similarity-search","text":"Ended up not using 6 PB stations (18 channels). Now 37 stations, 95 channels (eq_fast) root@6006660926e5:/app/fingerprint# cd ../simsearch/ (eq_fast) root@6006660926e5:/app/simsearch# ../parameters/simsearch/Calipatria/run_simsearch_calipatria.sh","title":"Similarity Search"},{"location":"calipatria_dataset/#postprocessing","text":"(eq_fast) root@6006660926e5:/app/simsearch# cd ../postprocessing/ (eq_fast) root@6006660926e5:/app/postprocessing# ../parameters/postprocess/Calipatria/output_calipatria_pairs.sh (eq_fast) root@6006660926e5:/app/postprocessing# ../parameters/postprocess/Calipatria/combine_calipatria_pairs.sh","title":"Postprocessing"},{"location":"calipatria_dataset/#network-detection","text":"If list index out of range in partition, fails to keep running -> try 1 partition (eq_fast) root@6006660926e5:/app/postprocessing# python scr_run_network_det.py ../parameters/postprocess/Calipatria/37sta_3stathresh_network_params.json","title":"Network detection"},{"location":"calipatria_dataset/#postprocess-clean-network-detection-results","text":"(eq_fast) root@6006660926e5:/app/postprocessing# cd ../utils/network/ (eq_fast) root@6006660926e5:/app/utils/network# python arrange_network_detection_results.py Input parameter changes made to arrange_network_detection_results.py (from Hector Mine -> Calipatria) 4 5 6 det_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / \u2019 network_file = \u2018 37 sta_3stathresh_detlist_rank_by_peaksum . txt \u2019 nsta = 37 (eq_fast) root@6006660926e5:/app/utils/network# ./remove_duplicates_after_network.sh Input parameter changes made to remove_duplicates_after_network.sh (from Hector Mine -> Calipatria) 4 5 cd ../../ data / 20210605 _Calipatria_Data / network_detection / NETWORK_FILE = NetworkDetectionTimes_37sta_3stathresh_detlist_rank_by_peaksum . txt (eq_fast) root@6006660926e5:/app/utils/network# python delete_overlap_network_detections.py Input parameter changes made to delete_overlap_network_detections.py (from Hector Mine -> Calipatria) 4 5 6 7 input_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / \u2019 allfile_name = input_dir + \u2018 uniquestart_sorted_no_duplicates . txt \u2019 outfile_name = input_dir + \u2018 37 sta_3stathresh_FinalUniqueNetworkDetectionTimes . txt \u2019 n_sta = 37 (eq_fast) root@6006660926e5:/app/utils/network# ./final_network_sort_nsta_peaksum.sh Input parameter changes made to final_network_sort_nsta_peaksum.sh (from Hector Mine -> Calipatria) 4 5 cd ../../ data / 20210605 _Calipatria_Data / network_detection / NETWORK_FILE = 37 sta_3stathresh_FinalUniqueNetworkDetectionTimes . txt","title":"Postprocess: Clean Network Detection Results"},{"location":"calipatria_dataset/#visualize-the-fast-output-739-events","text":"(eq_fast) root@6006660926e5:/app/utils/network# cat ../../data/20210605_Calipatria_Data/network_detection/sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt","title":"Visualize the FAST output (739 events)"},{"location":"calipatria_dataset/#display-fast-detection-waveforms-descending-order-of-peaksum-similarity","text":"(eq_fast) root@6006660926e5:/app/utils/network# cd ../events/ (eq_fast) root@6006660926e5:/app/utils/events# python PARTIALplot_detected_waveforms_Calipatria.py 0 739 Input parameter changes made to PARTIALplot_detected_waveforms_Calipatria.py (from Hector Mine -> Calipatria) 23 times_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / \u2019 25 out_dir = times_dir + \u2018 37 sta_3stathresh_NetworkWaveformPlots / \u2019 30 dt_fp = 1.2 37 init_time = UTCDateTime ( \u2018 2021 - 06 - 05 T00 : 00 : 06.840000 \u2019 ) 47 48 ts_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 st = read ( ts_dir + \u2018 waveforms */ Deci * Z__20210605T000000Z__20210606T000000Z . mseed \u2019 ) # Plot only vertical component","title":"Display FAST detection waveforms, descending order of peaksum-similarity"},{"location":"calipatria_dataset/#set-detection-threshold-keep-all-events-with-at-least-3-stations","text":"(eq_fast) root@6006660926e5:/app/utils/events# cd ../../data/20210605_Calipatria_Data/network_detection/ (eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/network_detection# head -739 sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt > EQ_sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt","title":"Set detection threshold - keep all events with at least 3 stations"},{"location":"calipatria_dataset/#output-final-fast-detected-event-list","text":"(eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/network_detection# cd ../../../utils/events/ (eq_fast) root@6006660926e5:/app/utils/events# python output_final_detection_list.py Input parameter changes made to output_final_detection_list.py (from Hector Mine -> Calipatria) 9 10 11 12 13 times_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / \u2019 infile_name = \u2018 EQ_sort_nsta_peaksum_37sta_3stathresh_FinalUniqueNetworkDetectionTimes . txt \u2019 outfile_name = times_dir + \u2018 FINAL_Detection_List_Calipatria_37sta_3stathresh . txt \u2019 init_time = UTCDateTime ( \u2018 2021 - 06 - 05 T00 : 00 : 06.840000 \u2019 ) # global start time for all channels dt_fp = 1.2 (eq_fast) root@6006660926e5:/app/utils/events# cat ../../data/20210605_Calipatria_Data/network_detection/FINAL_Detection_List_Calipatria_37sta_3stathresh.txt","title":"Output final FAST detected event list"},{"location":"calipatria_dataset/#cut-event-sac-files-for-phase-picking","text":"(eq_fast) root@6006660926e5:/app/utils/events# python cut_event_files.py Input parameter changes made to cut_event_files.py (from Hector Mine -> Calipatria) 20 21 22 23 24 25 26 27 28 29 30 stations = [ \u201c USGCB \u201d , \u201c BC3 \", \u201cBOM\u201d, \u201cCLI2\" , \u201c COA \u201d , \u201c COK2 \", \u201cCRR\u201d, \u201c CTC \u201d , \u201c CTW \u201d , \u201c DRE \u201d , \u201c ERR \u201d , \u201c FRK \u201d , \u201c IMP \u201d , \u201c NSS2 \", \u201c OCP \u201d , \u201c RXH \u201d , \u201c SAL \u201d , \u201c SLB \u201d , \u201c SLV \u201d , \u201c SNR \u201d , \u201c SWP \u201d , \u201c SWS \u201d , \u201c THM \u201d , \u201c WMD \u201d , \u201c WWF \u201d , \u201c 286 \", \u201c5056\u201d, \u201c5058\" , \u201c 5062 \u201d , \u201c 5271 \", \u201c5274\u201d, \u201c5444\" , \u201c WLA \u201d , \u201c WLA01 \", \u201cWLA03\u201d, \u201cWLA04\" , \u201c WLA06 \u201d ] in_mseed_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 in_FINAL_Detection_List = \u2018 ../../ data / 20210605 _Calipatria_Data / network_detection / FINAL_Detection_List_Calipatria_37sta_3stathresh . txt \u2019 out_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / event_ids \u2019 init_time = UTCDateTime ( \u2018 2021 - 06 - 05 T00 : 00 : 06.840000 \u2019 , precision = 2 ) # global start time for all channels dt_fp = 1.2 80 st = read ( \u2018 ../../ data / 20210605 _Calipatria_Data / waveforms */ [ ! Deci ] *. mseed \u2019 )","title":"Cut event SAC files for phase picking"},{"location":"calipatria_dataset/#pick-phases-with-seisbench","text":"(eq_fast) root@6006660926e5:/app/utils/events# cd ../picking/ (eq_fast) root@6006660926e5:/app/utils/picking# python run_seisbench.py Input parameter changes made to run_seisbench.py (from Hector Mine -> Calipatria) 16 base_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 18 stations = [ \u2018 CLI2 \u2019 , \u2018 COK2 \u2019 , \u2018 OCP \u2019 , \u2018 SAL \u2019 , \u2018 WWF \u2019 , \u2018 5062 \u2019 , \u2018 5271 \u2019 , \u2018 5444 \u2019 ]","title":"Pick phases with SeisBench"},{"location":"calipatria_dataset/#earthquake-location-with-hypoinverse","text":"(eq_fast) root@6006660926e5:/app/utils/picking# cd ../location/ (eq_fast) root@6006660926e5:/app/utils/location# python SeisBench2hypoinverse.py Input parameter changes made to SeisBench2hypoinverse.py (from Hector Mine -> Calipatria) 25 26 27 28 base_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 start_lat = 33.1 start_lon = - 115.6 start_depth = 5 (eq_fast) root@6006660926e5:/app/utils/location# python output_station_file.py Input parameter changes made to output_station_file.py (from Hector Mine -> Calipatria) 113 base_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / \u2019 (eq_fast) root@6006660926e5:/app/utils/location# cd ../../data/20210605_Calipatria_Data/location_hypoinverse/ (eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/location_hypoinverse/# ../../../utils/location/hyp1.40/source/hyp1.40 COMMAND? @locate_events.hyp (eq_fast) root@6006660926e5:/app/data/20210605_Calipatria_Data/location_hypoinverse/# cd ../../../utils/location/ (eq_fast) root@6006660926e5:/app/utils/location# python output_hypoinverse_as_text.py Input parameter changes made to output_hypoinverse_as_text.py (from Hector Mine -> Calipatria) 12 13 catalog_start_time = UTCDateTime ( \u2018 2021 - 06 - 05 T00 : 00 : 06.840000 \u2019 ) loc_dir = \u2018 ../../ data / 20210605 _Calipatria_Data / location_hypoinverse / \u2019","title":"Earthquake location with HYPOINVERSE"},{"location":"calipatria_dataset/#mapping-earthquake-locations-with-pygmt","text":"(eq_fast) root@6006660926e5:/app/utils/location# cd ../mapping/ (eq_fast) root@6006660926e5:/app/utils/mapping# conda deactivate root@6006660926e5:/app/utils/mapping# conda activate pygmt (pygmt) root@6006660926e5:/app/utils/mapping# python hypoinverse_to_pygmt_Calipatria.py Plots of detected earthquakes from FAST output","title":"Mapping earthquake locations with PyGMT"},{"location":"earthquake_location/","text":"Earthquake Location \u00b6 The phase pick information from run_seisbench.py is saved in event_picks.json in /FAST/utils/picking/event_picks.json and is used as input for finding the earthquake locations, starting with SeisBench2hypoinverse.py . SeisBench2hypoinverse.py will format the needed earthquake information as input for HYPOINVERSE. HYPOINVERSE is the standard location program supplied with the Earthworm seismic acquisition and processing system (AQMS). Read more about it here . Make Changes to SeisBench2hypoinverse.py \u00b6 Change output file name: 24 out_hinv_phase_file = 'EQT_19991015_test.txt' # Change file name for your dataset Get Station List \u00b6 You will need to edit eqt_get_station_list.py in /FAST/utils/location/ for your dataset: Starting with getting the data 125 126 127 128 129 130 # Hector Mine data clientlist = [ \"SCEDC\" ] minlat = 34.1 maxlat = 34.9 minlon =- 116.7 maxlon =- 116 Choose channels you want to download 132 chan_priority_list = [ \"HH[ZNE12]\" , \"BH[ZNE12]\" , \"EH[ZNE12]\" , \"HN[ZNE12]\" ] # Hector Mine data Add event start and end time: 147 tstart = \"1999-10-12 00:00:00.00\" # Hector Mine data 153 tend = \"1999-10-17 00:00:00.00\" # Hector Mine data Information About locate_events.hyp input files \u00b6 Input files locate_events.hyp relies on: CRH 1 \u2018hadley.crh\u2019 STA \u2018station_list.sta\u2019 PHS \u2018EQT_19991015_test.txt\u2019 SUM \u2018locate_events.sum\u2019 ARC \u2018locate_events.arc\u2019 hadley.crh is the velocity model input file. It approximates the p-wave speed (km/s) underground, at a given depth in km. You\u2019ll need this to calculate earthquake locations from the phase pick times. The first column has p-wave speed in km/s. The second column has depth in km. The p-wave speed is 5.5 km/s at depths from 0 to 5.5 km, 6.3 km/s at depths from 5.5 to 16 km, 6.7 km/s at depths from 16 to 32 km, and 7.8 km/s at depths deeper than 32 km. 9 POS 1.73 / P to S ratio This line in the locate_events.hyp file tells you the ratio between p wave and s wave speed. S wave speed is always slower than p wave speed, so s picks are always later than p picks. You can divide the first column of numbers in hadley.crh by 1.73 to get the s-wave speeds; that\u2019s what HYPOINVERSE does internally. PHS \u2018EQT_19991015_test.txt\u2019 - that\u2019s the all-important file your script generated, that has the approximate origin times and phase pick times from SeisBench. STA \u2018station_list.sta\u2019 - this is the station file, which has the list of station names and their locations. There are scripts you can run to create this file shown in Tutorial . Change File Name in locate_events.hyp \u00b6 The output changed above in SeisBench2hypoinverse.py is used in locate_events.hyp Change file name for your dataset in locate_events.hyp : 53 PHS 'EQT_19991015_test.txt' # Change file name for your dataset Plotting HYPOINVERSE Location Results With PyGMT \u00b6 IMPORTANT - PyGMT needs to be installed and run in a separate pygmt conda environment, since it is incompatible with the eq_fast conda environment. Follow the steps in the tutorial section to user PyGMT.","title":"Earthquake Location"},{"location":"earthquake_location/#earthquake-location","text":"The phase pick information from run_seisbench.py is saved in event_picks.json in /FAST/utils/picking/event_picks.json and is used as input for finding the earthquake locations, starting with SeisBench2hypoinverse.py . SeisBench2hypoinverse.py will format the needed earthquake information as input for HYPOINVERSE. HYPOINVERSE is the standard location program supplied with the Earthworm seismic acquisition and processing system (AQMS). Read more about it here .","title":"Earthquake Location"},{"location":"earthquake_location/#make-changes-to-seisbench2hypoinversepy","text":"Change output file name: 24 out_hinv_phase_file = 'EQT_19991015_test.txt' # Change file name for your dataset","title":"Make Changes to SeisBench2hypoinverse.py"},{"location":"earthquake_location/#get-station-list","text":"You will need to edit eqt_get_station_list.py in /FAST/utils/location/ for your dataset: Starting with getting the data 125 126 127 128 129 130 # Hector Mine data clientlist = [ \"SCEDC\" ] minlat = 34.1 maxlat = 34.9 minlon =- 116.7 maxlon =- 116 Choose channels you want to download 132 chan_priority_list = [ \"HH[ZNE12]\" , \"BH[ZNE12]\" , \"EH[ZNE12]\" , \"HN[ZNE12]\" ] # Hector Mine data Add event start and end time: 147 tstart = \"1999-10-12 00:00:00.00\" # Hector Mine data 153 tend = \"1999-10-17 00:00:00.00\" # Hector Mine data","title":"Get Station List"},{"location":"earthquake_location/#information-about-locate_eventshyp-input-files","text":"Input files locate_events.hyp relies on: CRH 1 \u2018hadley.crh\u2019 STA \u2018station_list.sta\u2019 PHS \u2018EQT_19991015_test.txt\u2019 SUM \u2018locate_events.sum\u2019 ARC \u2018locate_events.arc\u2019 hadley.crh is the velocity model input file. It approximates the p-wave speed (km/s) underground, at a given depth in km. You\u2019ll need this to calculate earthquake locations from the phase pick times. The first column has p-wave speed in km/s. The second column has depth in km. The p-wave speed is 5.5 km/s at depths from 0 to 5.5 km, 6.3 km/s at depths from 5.5 to 16 km, 6.7 km/s at depths from 16 to 32 km, and 7.8 km/s at depths deeper than 32 km. 9 POS 1.73 / P to S ratio This line in the locate_events.hyp file tells you the ratio between p wave and s wave speed. S wave speed is always slower than p wave speed, so s picks are always later than p picks. You can divide the first column of numbers in hadley.crh by 1.73 to get the s-wave speeds; that\u2019s what HYPOINVERSE does internally. PHS \u2018EQT_19991015_test.txt\u2019 - that\u2019s the all-important file your script generated, that has the approximate origin times and phase pick times from SeisBench. STA \u2018station_list.sta\u2019 - this is the station file, which has the list of station names and their locations. There are scripts you can run to create this file shown in Tutorial .","title":"Information About locate_events.hyp input files"},{"location":"earthquake_location/#change-file-name-in-locate_eventshyp","text":"The output changed above in SeisBench2hypoinverse.py is used in locate_events.hyp Change file name for your dataset in locate_events.hyp : 53 PHS 'EQT_19991015_test.txt' # Change file name for your dataset","title":"Change File Name in locate_events.hyp"},{"location":"earthquake_location/#plotting-hypoinverse-location-results-with-pygmt","text":"IMPORTANT - PyGMT needs to be installed and run in a separate pygmt conda environment, since it is incompatible with the eq_fast conda environment. Follow the steps in the tutorial section to user PyGMT.","title":"Plotting HYPOINVERSE Location Results With PyGMT"},{"location":"ex_params/","text":"Example Parameters \u00b6 0.1 Introduction \u00b6 FAST is available to the public at https://github.com/stanford-futuredata/FAST as open-source software, and it will be released with a comprehensive user manual containing guidance for setting parameters. Interested users can run FAST to perform an uninformed search for earthquakes with similar waveforms on any seismic network, with varying duration of continuous data and number of stations. The FAST software has successfully detected earthquakes in the following data sets. FAST will only reach its full potential as a tool for seismological discovery if other users apply it to their own data sets (filling the N and T gaps in Figure 1) and improve the detection algorithms. Thank you to all collaborators and interested users who shared data, which was useful for testing the FAST software and identifying bug fixes, in preparation for its public release. Figure 1: Dimensions of different data sets where FAST has successfully detected similar earthquakes. The log-scale axes represent the directions of data growth in seismology to \u201dlarge-T\u201d and \u201dlarge-N\u201d big data sets (Chapters 1 and 5): T is the longest duration of continuous data over all stations in the data set, while N is the number of seismic stations in the data set. Blue stars: data sets from Chapters 2-5. Red stars: additional data sets from Appendix A, Sections A.1-A.6. 0.2 ItalyDayYR Data Set \u00b6 Info One day of continuous data, 2016-10-29 00:00:00 to 2016-10-29 23:59:59 UTC, at 22 stations in central Italy (Figure 2), used 22 channels (vertical component HHZ only on each channel) for detection, provided by Bill Ellsworth. This data records small earthquakes from a swarm in Central Italy during October 2016, that occurred between the Mw 6.1 earthquake on 2016-10-26 19:18:08 UTC and the Mw 6.6 Norcia earthquake on 2016-10-30 06:40:18 UTC. Figure 2: Map of 22 stations (black triangles) in central Italy used for FAST detection of small earthquakes on 2016-10-29, one day of continuous data. The INGV catalog (http://cnt.rm.ingv.it/search) had 482 earthquakes (circles colored by depth, sized by relative magnitudes 0.4 \u2264 M \u2264 4.1) inside the boundaries of this map on 2016-10-29. 0.2.1 Preprocessing \u00b6 Output sample spectrograms on each channel and station to determine bandpass filter range: ~/FAST/utils/preprocess/$ ../../parameters/preprocess/ItalyDayYR/sample_spectrograms_ItalyDayYR.sh Table S2: FAST input parameters for Italy earthquake detection: single-channel at 22 YR stations (Figure 2, black triangles), after bandpass filter 2-20 Hz, and decimate to 25 Hz. Total number of fingerprints: 71,989. Table S3: Network detection input parameters for Italy earthquakes at 22 YR stations (HHZ channel only), after getting similar pairs of fingerprints from FAST for each station. Figure 3: Distribution of FAST detections in central Italy continuous data on 2016-10-29. FAST detected a total of 1,485 earthquakes during this day. 0.3 Tanzania, August 2016 \u00b6 Temporary dense deployment of seismic stations in Tanzania to identify previously unknown faults and infer their dimensions. 1 month continuous data (2016-07-31 to 2016-08-31), at 5 stations, 15 channels (3 components per station), provided by Laura Parisi of King Abdullah University of Science and Technology (KAUST). The stations are located about 10 km apart, at the base of a volcanic caldera called Ngorongoro Crater. For all 15 channels, we applied the following preprocessing: 4-12 Hz bandpass filter, then decimated to 25 Hz (factor of 8, from original 200 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise (only on station CES04). Table S4: FAST input parameters for Tanzania earthquake detection, applied to each component at all 5 stations. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989. Table S5: Network detection input parameters for Tanzania earthquakes at 5 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HNE,HNN,HNZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S6: Final thresholds for Tanzania earthquakes, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta , a different threshold for peaksum can be applied. Figure 4: Tanzania earthquake detections from 2016-07-31 to 2016-08-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S6). FAST detected a total of 1,156 earthquakes during this month. Some false positive detections had to be removed manually, especially detections on only 2 out of 5 stations. 0.4 Saudi Arabia, May 2014 \u00b6 Figure 5: Map of 19 stations (white triangles) in Saudi Arabia used for FAST detection from 2014-05-01 to 2014-06-01. Catalog earthquakes are colored by depth; mantle earthquakes are circled. This figure was created by Alex Blanchette. Info Seismic network from Saudi Arabia to study dike swarms in volcanic area, and deep mantle earthquakes. 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations (Figure 5), 55 channels (3 components per station, except LNY11 where only HHN was used), provided by Alex Blanchette of Stanford Geophysics. Table S7: Preprocessing parameters for Saudi Arabia May 2014 earthquake detection, for each station (same filter applied to all components), 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations, decimate to 25 Hz. Also, all time gaps with 0\u2019s were filled with uncorrelated random noise. For station LNY11, only HHN component was used in similarity search, as the HHE and HHZ components had too much correlated noise. Table S8: FAST input parameters for Saudi Arabia May 2014 earthquake detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989. Table S9: Network detection input parameters for Saudi Arabia May 2014 earthquake detection at 19 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S10: Final thresholds for Saudi Arabia May 2014 earthquake detection, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta , a different threshold for peaksum can be applied. Figure 6: Saudi Arabia earthquake detections from 2014-05-01 to 2014-06-01. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S10). FAST detected a total of 1,837 earthquakes during this month. 0.5 SaudiFull data set: Saudi Arabia, January - May 2017 \u00b6 Location: Saudi Arabia, January - May 2017 (volcanic area with dikes) Duration: up to 5 months (151 days): 2017-01-01 to 2017-05-30 Network: 36 stations, 3 components each (HHE, HHN, HHZ) = 106 channels. (Station SA.UMJ02: only HHE channel) Sampling rate: 100 Hz Provided by: Mohammad Youssof (KAUST) 0.5.1 Preprocessing \u00b6 Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/continuous_data_times_SaudiFull.sh The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_SaudiFull.py to plot the duration of available continuous data at each station and channel (Figure 7). Figure 7: Duration of SaudiFull continuous data at 36 stations (change colors with each station), 3 components each (except SA.UMJ02 which has only HHE). White sections indicate time gaps. Detected zero-filled time-gap sections of continuous data in all 106 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py), and filled them with random uncorrelated noise: ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Only stations SA.UMJ03, SA.UMJ05, SA.UMJ08 had zero-filled time-gap sections, which were filled with random noise and saved as files starting with the Filled.* string. The majority of continuous data files had no zero-filled time gaps, so we used original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/sample_spectrograms_SaudiFull.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/bandpass_filter_decimate_SaudiFull.sh Based on sample spectrograms, apply a station-specific bandpass filter (Table S11). Decimate by a factor of 2 to a sampling rate of 50 Hz. Filtered continuous data files start with Deci2.bpXtoY.* , where X is the lower frequency and Y is the higher frequency, which are input to the fingerprint step. Table S11: Preprocessing parameters for SaudiFull earthquake detection, for each station (same filter applied to all components), 5 months continuous data (2017-01-01 to 2017-05-31), at 36 stations, decimate to 50 Hz. 0.5.2 Fingerprint \u00b6 Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/SaudiFull/run_fp_SaudiFull.sh Example script to generate fingerprints on one channel (HHZ) at one station (LNY03), called by the master script run_fp_SaudiFull.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/SaudiFull/fp_input_SA_LNY03_HHZ.json \"fingerprint\": { \"sampling_rate\": 50, \"min_freq\": 4.0, \"max_freq\": 15.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 0.1, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"LNY03\", \"channel\": \"HHZ\", \"start_time\": \"17-01-01T00:00:00.0\", \"end_time\": \"17-05-31T00:00:00.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/\", There are a total of 106 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S12. Median/MAD output files: mad/mad*.txt Table S12: Fingerprint input parameters for SaudiFull earthquake detection: 3-component at 36 stations (except for SA.UMJ02), after applying station-specific bandpass filter (Table S11), and sampled at 50 Hz. The fingerprint sampling period is dt_fp = 1.2 seconds. Fingerprints (binary files): fingerprints/LNY03.HHZ.fp Timestamps at each fingerprint index (text files): timestamps/LNY03.HHZ.ts Finally, to create global indices for the SaudiFull data set, so that fingerprint indices from different channels (all 106) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/SaudiFull/global_indices_SaudiFull.json The common starting time is in global_idx_stats.txt : 2017-01-01T00:00:06.840000 UTC 0.5.3 Similarity Search \u00b6 Master script to run similarity search on each channel (out of 106 total): ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/run_simsearch_SaudiFull.sh Table S13: Similarity search input parameters for SaudiFull earthquake detection: 106 channels at 36 stations (3 components each, except SA.UMJ02). The occurrence filter, specified by the FREQ_NOISE parameter, was applied only for selected stations and channels (Table S14). Example script to run similarity search on one channel (HHZ) at one station (LNY03), called by the master script run_simsearch_SaudiFull.sh : ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/simsearch_input_SaudiFull.sh LNY03 HHZ NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 We first ran similarity search with the same input parameters on all 106 channels, without the occurrence filter. For 18 selected channels (Table S14), where the candidate_pairs similarity search outputs were especially large because of correlated noise, we ran similarity search with the occurrence filter (FREQ_NOISE=0.01), which significantly reduced the similarity search output file sizes. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. For example, the occurrence filter was applied for station LNY01 channel HHZ by calling the script filt_simsearch_input_SaudiFull.sh from the master script run_simsearch_SaudiFull.sh : ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/filt_simsearch_input_SaudiFull.sh LNY03 HHZ NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 FREQ_NOISE=0.01 Table S14: Selected stations and channels from SaudiFull data set where we applied the occurrence filter with FREQ_ NOISE=0.01. 0.5.4 Postprocessing \u00b6 First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (106 total): ~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/output_SaudiFull_pairs.sh For example, on one channel (HHZ) at one station (LNY03), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/ -p candidate_pairs_LNY03_HHZ -i /lfs/1/ceyoon/TimeSeries/SaudiFull/global_indices/LNY03_HHZ_idx_mapping.txt Output file for example (large size at channel level): /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/candidate_pairs_LNY03_HHZ_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for all 36 stations: ~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/combine_SaudiFull_pairs.sh Example For example, on three channels (HHE, HHN, HHZ) at one station (LNY03), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/ $ mv candidate_pairs_LNY03_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S13). Note: this step will delete the c andidate_ pairs_LNY03_HH*_merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ -p candidate_pairs_LNY03 --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ candidate_pairs_LNY03_combined.txt For station SA.UMJ02, which has only 1 component (HHE), multiply the similarity sim by 3 to give this station an equal weight as the other 3-component stations: ~/FAST/postprocessing/$ awk \u2019{print $1, $2, 3*$3}\u2019 /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_HHE_merged.txt > /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_combined.txt Finally , detect similar fingerprints across the network of 36 stations, using the input parameters in Table S15: ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/SaudiFull/36sta_3stathresh_network_params.json \"network\": { \"max_fp\": 10736786, \"dt_fp\": 1.2, (seconds) \"dgapL\": 10, (12 s) \"dgapW\": 3, (3.6 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (9.6 s) \"ivals_thresh\": 6, \"nsta_thresh\": 3, \"input_offset\": 15 (18 s) }, Network detection output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/SaudiFull/ network_detection/36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events) At this point, FAST earthquake detection processing is done . Table S15: Network detection input parameters for SaudiFull at 36 stations. max_fp = 10736786 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.2 seconds is the fingerprint sampling period from Table S12. 0.5.5 Remove Duplicates After Network Detection \u00b6 Info The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.) First , save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind). ~/FAST/utils/network/$ python arrange_network_detection_results.py Output: NetworkDetectionTimes_36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events) Second , remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity). ~/FAST/utils/network/$ ./remove_duplicates_after_network.sh Output: uniquestart_sorted_no_duplicates.txt (15,054 events) Third , remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum. ~/FAST/utils/network/$ python delete_overlap_network_detections.py Output: 36sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (11,597 events) Fourth , since different channels in the network have different durations (for example, in Figure 7, stations UMJ01-UMJ12 were active only during May 2017, while many of the other stations were active from January to May 2017), we calculate a normalized measure of the number of stations that detected the event: frac_ch, which is the fraction of channels that were active at each detection time. This is done by reading in files that were generated during preprocessing by get_continuous_data_times.py. This normalization step would not be necessary if all stations and channels in the network recorded the same duration of data. ~/FAST/utils/network/$ python get_station_count_detections.py Output: 36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt (11,597 events) Finally , sort remaining events in descending order of num_sta, then frac_ch, then peaksum, for the final detection list. ~/FAST/utils/network/$ ./final_network_sort_nsta_fracch_peaksum.sh Output: sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt (11,597 events) 0.5.6 Visual Inspection and Final Detections \u00b6 Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table S16). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_SaudiFull.py 0 11597 Output: .png image files in 36sta_3stathresh_NetworkWaveformPlots/ Table S16: Final thresholds for SaudiFull applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied. After visual inspection, 4634 events are above thresholds in Table S16. EQ_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt : 4543 events that look like earthquake waveforms FALSE_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt : 91 false detections above thresholds that do not look like earthquakes For the 4543 earthquake events, output an event catalog (Figure 8): ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_SaudiFull_36sta_3stathresh.txt (4543 events) Figure 8: Saudi Arabia earthquake detections from 2017-01-01 to 2017-05-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S16). FAST detected a total of 4,543 earthquakes during this month. 0.6 Ometepec, Mexico, January - April 2012 \u00b6 Figure 9: Map of 1 station in southern Mexico (black triangle) used for FAST detection of small earthquakes from 2012-01-01 to 2012-04-21. The SSN catalog (http://www2.ssn.unam.mx:8080/catalogo/) had 558 earthquakes (circles colored by depth, sized by relative magnitudes 2.8 \u2264 M \u2264 7.5) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.5 Ometepec earthquake on 2012-03-20. Info The objective of this study is to identify repeating earthquake sequences as tools to measure deep aseismic slip rates [Dominguez et al., 2016], and characterize the unusually active aftershock sequence of the Mw 7.5 Omepetec, Mexico earthquake on 2012-03-20 [UNAM, 2013] (Figure 9). 112 days of continuous data (2012-01-01 to 2012-04-21) at 1 station, 3 components, provided by Luis Dominguez of Universidad Nacional Autonoma de Mexico (UNAM)-Morelia. For all 3 channels, I applied a 3-20 Hz bandpass filter, and kept the original sampling rate of 100 Hz. FAST detected a total of 31,970 earthquakes during these 4 months. 30,923 were earthquakes (Figure 10), and 1,047 were noise, as determined by visual inspection. ***NOTE: postprocessing and elimination of duplicate detection pairs was done with the old MATLAB code from [Yoon et al., 2015] and [Yoon et al., 2017]. Single-station event-pair extraction with network FAST was not yet available. These were the events I sent to Luis, who performed single-station location using P-wave polarization analysis (Figure 10). Table S17: FAST input parameters for Ometepec, Mexico earthquake detection, applied to each component at station IG.PNIG. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 4,795,140. Figure 10: Ometepec, Mexico earthquake detections from 2012-01-01 to 2012-04-21. The blue dots indicate the total 3-component FAST similarity (left y-axis) of the 30,923 FAST detections as a function of time. The red dots indicate the magnitudes (right y-axis) of the 558 catalog events as a function of time. Following the Mw 7.5 earthquake on 2012-03-20, aftershocks are abundant. 0.7 SeismOlympics: Wenchuan Aftershocks \u00b6 Info Alibaba Cloud and the China Earthquake Administration sponsored a \u201dSeismOlympics\u201d programming competition to detect aftershocks of the deadly May 12, 2008 Mw 7.9 Wenchuan, China, earthquake [Fang et al., 2017], similar to the Netflix Prize or the Kaggle data science competitions. Competitors from seismology, machine learning, signal processing, computer science, and other backgrounds developed algorithms that automatically detect and pick phases on aftershock waveforms while avoiding false positive detections. Performance was evaluated against phases picked by human analysts. This was a great opportunity to test how the FAST earthquake detection algorithm measured up against other methods. Other members of my team, all from Stanford Geophysics (Mostafa Mousavi, Yixiao Sheng, Weiqiang Zhu) used machine learning to pick phases and recognize false detections. We finished in 27th place in the first round of competition, and 16th place in the second round. Figure 11: Map of 15 stations in Wenchuan, China used for FAST detection of small earthquakes in 3 months of continuous data. The ComCat catalog had 1039 aftershocks (circles colored by depth, sized by relative magnitudes 3.2 \u2264 M \u2264 6.1) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.9 Wenchuan earthquake on 2008-05-12. After the competition, I applied FAST to detect earthquakes within the entire continuous data set provided in both rounds of competition. 3 months of seismic data: April 1-22, 2008 (foreshocks), July 1-August 31, 2008 (aftershocks), at 15 stations (Figure 11) with 3 components each, although some stations only have data for part of this time. For all 45 channels, I applied the following preprocessing: 1-20 Hz bandpass filter, then decimated to 50 Hz (factor of 2, from original 100 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise. FAST detected about 12,000 earthquakes; some of them are teleseismic because the 1-20 Hz filter includes lower frequencies. Table S18: FAST input parameters for Wenchuan 2008 aftershock detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 3,612,972. Table S19: Network detection input parameters for Wenchuan 2008 aftershock detection at 15 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S20: Final thresholds for Wenchuan 2008 aftershock detection applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied. 0.8 Groningen Data Set \u00b6 Location: Netherlands (gas production field) Duration: 4 months (119 days): 2018-01-01 to 2018-04-30 Network: 67 stations (Figure 12), 3 components each (HH1, HH2, HHZ) = 201 channels. (Station G294 not used for detection due to short duration) Sampling rate: 20 Hz (already downsampled) Provided by: Zack Spica (Stanford Geophysics) Figure 12: Groningen map provided by Zack Spica: 67 stations (black, red triangles) used for FAST detection, and locations of known catalog events (blue circles). 0.8.1 Preprocessing \u00b6 Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/continuous_data_times_Groningen.sh Figure 13: Duration of Groningen continuous data at 67 stations (change colors with each station), 3 components each. White sections indicate time gaps. The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_Groningen.py to plot the duration of available continuous data at each station and channel (Figure 13). Confirmed no zero-filled time-gap sections of continuous data in all 201 channels (need to modify paths in fill_time_gaps_with_uncorrelated_noise.py): ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Use original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/sample_spectrograms_Groningen.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/bandpass_filter_decimate_Groningen.sh Based on sample spectrograms, filter 3-10 Hz for all 201 channels. No need to decimate, as sampling rate is already low at 20 Hz. Filtered continuous data files start with Deci1.bp3to10.*, which are input to the fingerprint step. 0.8.2 Fingerprint \u00b6 Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/Groningen/run_fp_Groningen.sh Example script to generate fingerprints on one channel (HHZ) at one station (G014), called by the master script run_fp_Groningen.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/Groningen/fp_input_NL_G014_HHZ.json \"fingerprint\": { \"sampling_rate\": 20, \"min_freq\": 3.0, \"max_freq\": 10.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 0.05, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"G014\", \"channel\": \"HHZ\", \"start_time\": \"18-01-01T00:00:00.0\", \"end_time\": \"18-04-30T00:00:00.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/\", There are a total of 201 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S21. Table S21: Fingerprint input parameters for Groningen earthquake detection: 3-component at 67 stations (Figure 12, red, black triangles), after bandpass filter 3-10 Hz, and sampled at 20 Hz. The fingerprint sampling period is dt_fp = 1.5 seconds. Median/MAD output files: mad/mad*.txt Fingerprints (binary files): fingerprints/G014.HHZ.fp Timestamps at each fingerprint index (text files): timestamps/G014.HHZ.ts Finally, to create global indices for the Groningen data set, so that fingerprint indices from different channels (all 201) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/Groningen/global_indices_Groningen.json The common starting time is in global_idx_stats.txt : 2018-01-01T00:00:04.500000 UTC 0.8.3 Similarity Search \u00b6 Master script to run similarity search on each channel (out of 201 total): ~/FAST/simsearch/$ ../parameters/simsearch/Groningen/run_simsearch_Groningen.sh Table S22: Similarity search input parameters for Groningen earthquake detection: 201 channels at 67 stations (3 components each). Example script to run similarity search on one channel (HHZ) at one station (G014), called by the master script run_simsearch_Groningen.sh: ~/FAST/simsearch/$ ../parameters/simsearch/Groningen/filt_simsearch_input_Groningen.sh G014 HHZ NTBLS=100 NHASH=5 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 FREQ_NOISE=0.01 Similarity search is run with the occurrence filter (FREQ_NOISE=0.01) for all 201 channels. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. The same input parameters are used for similarity search on all 201 channels (Table S22). 0.8.4 Postprocessing \u00b6 First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (201 total): ~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/output_Groningen_pairs.sh For example, on one channel (HHZ) at one station (G014), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/ -p candidate_pairs_G014_HHZ -i /lfs/1/ceyoon/TimeSeries/Groningen/global_indices/G014_HHZ_idx_mapping.txt Output file for example (large size at channel level): /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/ fingerprints/candidate_pairs_G014_HHZ_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for all 67 stations: ~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/combine_Groningen_pairs.sh For example, on three channels (HH1, HH2, HHZ) at one station (G014), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/ $ mv candidate_pairs_G014_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components) (v=2 votes/component, Table S22). Note: this step will delete the candidate_ pairs_G014_HH _merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ -p candidate_pairs_G014 --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ candidate_pairs_G014_combined.txt Finally , detect similar fingerprints across the network of 67 stations, using the input parameters in Table S23: ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/Groningen/67sta_3stathresh_network_params.json \"network\": { \"max_fp\": 6798013, \"dt_fp\": 1.5, (seconds) \"dgapL\": 10, (15 s) \"dgapW\": 3, (4.5 s) \"num_pass\": 2, 28 }, Table S23: Network detection input parameters for Groningen at 67 stations. max_fp = 6798013 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.5 seconds is the fingerprint sampling period from Table S21. Network detection output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/Groningen/ network_detection/67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events) At this point, FAST earthquake detection processing is done. 0.8.5 Remove duplicates after network detection \u00b6 The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.) First , save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind). ~/FAST/utils/network/$ python arrange_network_detection_results.py Output: NetworkDetectionTimes_67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events) Second , remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity). ~/FAST/utils/network/$ ./remove_duplicates_after_network.sh Output: uniquestart_sorted_no_duplicates.txt (13,782 events) Third , remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum. ~/FAST/utils/network/$ python delete_overlap_network_detections.py Output: 67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (6277 events) Finally , sort remaining events in descending order of num_sta, then peaksum, for the final detection list. ~/FAST/utils/network/$ ./final_network_sort_nsta_peaksum.sh Output: sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (6277 events) 0.8.6 Visual inspection and final detections \u00b6 Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table 0.8.6). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_Groningen.py 0 6277 Output: .png image files in 67sta_3stathresh_NetworkWaveformPlots/ Table S24: Final thresholds for Groningen applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied. After visual inspection, 26 events are above thresholds in Table 0.8.6. EQ_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt : 23 events that look like earthquake waveforms FALSE_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt : 3 false detections above thresholds that do not look like earthquakes For the 23 earthquake events, output an event catalog: ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_Groningen_67sta_13stathresh.txt (23 events) 0.9 BrazilAcre Data Set \u00b6 Location: Acre, Brazil (search for intermediate-depth and deep earthquakes) Duration: about 3 months (with time gaps): 2015-05-28 to 2016-02-01 Network: 1 station (Figure 14), 3 components (HHE, HHN, HHZ) = 3 channels. \u2022 Sampling rate: 100 Hz Provided by: Marcelo de Bianchi (University of Sao Paulo) Figure 14: Acre, Brazil map provided by Marcelo de Bianchi: 1 station (yellow triangle) used for FAST detection, and locations of known catalog events (circles colored by depth). 0.9.1 Preprocessing \u00b6 Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/continuous_data_times_BrazilAcre.sh The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_BrazilAcre.py to plot the duration of available continuous data at each station and channel (Figure 15). Figure 15: Duration of BrazilAcre continuous data at 1 station (3 components). White sections indicate time gaps. Confirmed no zero-filled time-gap sections of continuous data in all 3 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py): ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Use original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/sample_spectrograms_BrazilAcre.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/bandpass_filter_decimate_BrazilAcre.sh Based on sample spectrograms, filter 3-20 Hz for all 3 channels. Decimate by a factor of 2, to 50 Hz sampling rate. Filtered continuous data files start with Deci2.bp3to20.*, which are input to the fingerprint step. Need to add .mseed extension to all time series files, otherwise the Julian day number in the time series file gets removed while fingerprinting, and we cannot tell the difference between fingerprints from different days. 0.9.2 Fingerprint \u00b6 Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/BrazilAcre/run_fp_BrazilAcre.sh Example script to generate fingerprints on one channel (HHE) at one station (CZSB), called by the master script run_fp_BrazilAcre.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/BrazilAcre/fp_input_BR_CZSB_HHE.json \"fingerprint\": { \"sampling_rate\": 50, \"min_freq\": 3.0, \"max_freq\": 20.0, \"spec_length\": 10.0, \"spec_lag\": 0.2, \"fp_length\": 128, Continuous Data (Network.Station.Channel) \"fp_lag\": 10, \"k_coef\": 800, \"nfreq\": 32, \"mad_sampling_rate\": 0.1, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"CZSB\", \"channel\": \"HHE\", \"start_time\": \"15-10-28T00:00:00.0\", \"end_time\": \"16-02-01T00:00:03.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/\", There are a total of 3 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S25. Table S25: Fingerprint input parameters for BrazilAcre earthquake detection: 3-component at 1 station (Figure 14, yellow triangle), after bandpass filter 3-20 Hz, and decimated to 50 Hz sampling rate. The fingerprint sampling period is dt_fp = 2 seconds. Median/MAD output files: mad/mad*.txt Fingerprints (binary files): fingerprints/CZSB.HHE.fp Timestamps at each fingerprint index (text files): timestamps/CZSB.HHE.ts Finally, to create global indices for the BrazilAcre data set, so that fingerprint indices from different channels (all 3) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/BrazilAcre/global_indices_BrazilAcre.json The common starting time is in global_idx_stats.txt: 2015-10-28T00:00:21.340000 UTC 0.9.3 Similarity Search \u00b6 Master script to run similarity search on each channel (out of 3 total): ~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/run_simsearch_BrazilAcre.sh Example script to run similarity search on one channel (HHE) at one station (CZSB), called by the master script run_simsearch_BrazilAcre.sh : ~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/filt_simsearch_input_BrazilAcre.sh CZSB HHE NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 Table S26: Similarity search input parameters for BrazilAcre earthquake detection: 3 channels at 1 station (3 components each). The same input parameters are used for similarity search on all 3 channels (Table S26). 0.9.4 Postprocessing \u00b6 First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (3 total): ~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/output_BrazilAcre_pairs.sh For example, on one channel (HHE) at one station (CZSB), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ -p candidate_pairs_CZSB_HHE -i /lfs/1/ceyoon/TimeSeries/BrazilAcre/global_indices/CZSB_HHE_idx_mapping.txt Output file for example (large size at channel level): / lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ candidate_pairs_CZSB_HHE_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for 1 station: ~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/combine_BrazilAcre_pairs.sh For example, on three channels (HHE, HHN, HHZ) at one station (CZSB), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ $ mv candidate_pairs_CZSB_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S26). Note: this step will delete the candidate_ pairs_CZSB_HH*_merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ -p candidate_pairs_CZSB --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ candidate_pairs_CZSB_combined.txt Finally, detect similar fingerprints across the network of 1 station, using the input parameters in Table S27 (Note: this step only aggregates similar event pairs from similar fingerprints, and resolves the pairs into a list of candidate events, since there is only 1 station.): ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/BrazilAcre/1sta_1stathresh_network_params.json \"network\": { \"max_fp\": 4147182, \"dt_fp\": 2.0, (seconds) \"dgapL\": 10, (20 s) \"dgapW\": 3, (6 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (16 s) \"ivals_thresh\": 6, \"nsta_thresh\": 1, \"input_offset\": 15 (30 s) <--- NOT USED }, Table S27: Network detection input parameters for BrazilAcre at 1 station. max_fp = 4147182 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 2 seconds is the fingerprint sampling period from Table S25. Network detection output file: /lfs/1/ceyoon/TimeSeries/BrazilAcre/network_detection/1sta_1stathresh_detlist_rank_by_peaksum.tx t (14,477 events) At this point, FAST earthquake detection processing is done. 0.9.5 Remove duplicates after network detection \u00b6 Sort events in descending order of peaksum (peak similarity score between similar fingerprints) for the final detection list. ~/FAST/utils/network/$ ./final_single_station_sort_nsta_peaksum.sh Output: sort_peaksum_1sta_1stathresh_CZSB_events.txt (14,477 events) 0.9.6 Visual inspection and final detections \u00b6 Plot event waveforms in the final detection list, ranked in descending order of peaksum (peak similarity score between similar fingerprints), for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (peaksum \u2265 6). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_BrazilAcre.py 0 14477 Output: .png image files in 1sta_1stathresh_NetworkWaveformPlots/ (zip file) Visual inspection shows that there are many false detections that do not look like earthquake waveforms (for example, event_rank00000_peaksum116351_ind854248_time1708496.0_2015-11-16T18/35/17.340000.png ). However, some earthquake waveforms (for example, event_rank00049_peaksum26898_ind1297608_time2595216 . 0_2015-11-27T00/53/57.340000.png ) are also detected. I suggest running FAST on at least 3 stations for reliable earthquake detection. 14,474 events are above the arbitrary low threshold (peaksum \u2265 6). EQ_sort_peaksum_1sta_1stathresh_CZSB_events.txt For the 14,474 events, output a catalog-like formatted list: ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_BrazilAcre_1sta_1stathresh_peaksum6.txt (14,474 events) 0.10 New Zealand, Year 2010 \u00b6 Info The objective of this study is to detect small earthquakes in New Zealand to test earthquake triggering hypothesis. Detection results, with input parameters, are described in Rong et al. [2018]. 1 year continuous data (2010), 5 seismic stations LTZ, MQZ, KHZ, THZ, OXZ (Figure 16, black triangles), vertical components only, sampled at 100 Hz. Detections were compared against the GeoNet catalog, and visually inspected. FAST detected 11419 events: 4916 catalog events (Figure 16, red circles), 355 teleseismic events, 6123 new local earthquakes and 25 false positives (noise waveforms). Figure 16: New Zealand map: 5 stations (black triangles) used for FAST detection (except GVZ which was not used), and locations of GeoNet catalog events (circles). 4916 catalog events were detected by FAST (red circles). Catalog events missed by FAST are displayed as green circles. 0.11 Calipatria, June 2021 \u00b6","title":"**Example Parameters**"},{"location":"ex_params/#example-parameters","text":"","title":"Example Parameters"},{"location":"ex_params/#01-introduction","text":"FAST is available to the public at https://github.com/stanford-futuredata/FAST as open-source software, and it will be released with a comprehensive user manual containing guidance for setting parameters. Interested users can run FAST to perform an uninformed search for earthquakes with similar waveforms on any seismic network, with varying duration of continuous data and number of stations. The FAST software has successfully detected earthquakes in the following data sets. FAST will only reach its full potential as a tool for seismological discovery if other users apply it to their own data sets (filling the N and T gaps in Figure 1) and improve the detection algorithms. Thank you to all collaborators and interested users who shared data, which was useful for testing the FAST software and identifying bug fixes, in preparation for its public release. Figure 1: Dimensions of different data sets where FAST has successfully detected similar earthquakes. The log-scale axes represent the directions of data growth in seismology to \u201dlarge-T\u201d and \u201dlarge-N\u201d big data sets (Chapters 1 and 5): T is the longest duration of continuous data over all stations in the data set, while N is the number of seismic stations in the data set. Blue stars: data sets from Chapters 2-5. Red stars: additional data sets from Appendix A, Sections A.1-A.6.","title":"0.1 Introduction"},{"location":"ex_params/#02-italydayyr-data-set","text":"Info One day of continuous data, 2016-10-29 00:00:00 to 2016-10-29 23:59:59 UTC, at 22 stations in central Italy (Figure 2), used 22 channels (vertical component HHZ only on each channel) for detection, provided by Bill Ellsworth. This data records small earthquakes from a swarm in Central Italy during October 2016, that occurred between the Mw 6.1 earthquake on 2016-10-26 19:18:08 UTC and the Mw 6.6 Norcia earthquake on 2016-10-30 06:40:18 UTC. Figure 2: Map of 22 stations (black triangles) in central Italy used for FAST detection of small earthquakes on 2016-10-29, one day of continuous data. The INGV catalog (http://cnt.rm.ingv.it/search) had 482 earthquakes (circles colored by depth, sized by relative magnitudes 0.4 \u2264 M \u2264 4.1) inside the boundaries of this map on 2016-10-29.","title":"0.2 ItalyDayYR Data Set"},{"location":"ex_params/#021-preprocessing","text":"Output sample spectrograms on each channel and station to determine bandpass filter range: ~/FAST/utils/preprocess/$ ../../parameters/preprocess/ItalyDayYR/sample_spectrograms_ItalyDayYR.sh Table S2: FAST input parameters for Italy earthquake detection: single-channel at 22 YR stations (Figure 2, black triangles), after bandpass filter 2-20 Hz, and decimate to 25 Hz. Total number of fingerprints: 71,989. Table S3: Network detection input parameters for Italy earthquakes at 22 YR stations (HHZ channel only), after getting similar pairs of fingerprints from FAST for each station. Figure 3: Distribution of FAST detections in central Italy continuous data on 2016-10-29. FAST detected a total of 1,485 earthquakes during this day.","title":"0.2.1 Preprocessing"},{"location":"ex_params/#03-tanzania-august-2016","text":"Temporary dense deployment of seismic stations in Tanzania to identify previously unknown faults and infer their dimensions. 1 month continuous data (2016-07-31 to 2016-08-31), at 5 stations, 15 channels (3 components per station), provided by Laura Parisi of King Abdullah University of Science and Technology (KAUST). The stations are located about 10 km apart, at the base of a volcanic caldera called Ngorongoro Crater. For all 15 channels, we applied the following preprocessing: 4-12 Hz bandpass filter, then decimated to 25 Hz (factor of 8, from original 200 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise (only on station CES04). Table S4: FAST input parameters for Tanzania earthquake detection, applied to each component at all 5 stations. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989. Table S5: Network detection input parameters for Tanzania earthquakes at 5 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HNE,HNN,HNZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S6: Final thresholds for Tanzania earthquakes, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta , a different threshold for peaksum can be applied. Figure 4: Tanzania earthquake detections from 2016-07-31 to 2016-08-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S6). FAST detected a total of 1,156 earthquakes during this month. Some false positive detections had to be removed manually, especially detections on only 2 out of 5 stations.","title":"0.3 Tanzania, August 2016"},{"location":"ex_params/#04-saudi-arabia-may-2014","text":"Figure 5: Map of 19 stations (white triangles) in Saudi Arabia used for FAST detection from 2014-05-01 to 2014-06-01. Catalog earthquakes are colored by depth; mantle earthquakes are circled. This figure was created by Alex Blanchette. Info Seismic network from Saudi Arabia to study dike swarms in volcanic area, and deep mantle earthquakes. 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations (Figure 5), 55 channels (3 components per station, except LNY11 where only HHN was used), provided by Alex Blanchette of Stanford Geophysics. Table S7: Preprocessing parameters for Saudi Arabia May 2014 earthquake detection, for each station (same filter applied to all components), 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations, decimate to 25 Hz. Also, all time gaps with 0\u2019s were filled with uncorrelated random noise. For station LNY11, only HHN component was used in similarity search, as the HHE and HHZ components had too much correlated noise. Table S8: FAST input parameters for Saudi Arabia May 2014 earthquake detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989. Table S9: Network detection input parameters for Saudi Arabia May 2014 earthquake detection at 19 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S10: Final thresholds for Saudi Arabia May 2014 earthquake detection, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta , a different threshold for peaksum can be applied. Figure 6: Saudi Arabia earthquake detections from 2014-05-01 to 2014-06-01. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S10). FAST detected a total of 1,837 earthquakes during this month.","title":"0.4 Saudi Arabia, May 2014"},{"location":"ex_params/#05-saudifull-data-set-saudi-arabia-january-may-2017","text":"Location: Saudi Arabia, January - May 2017 (volcanic area with dikes) Duration: up to 5 months (151 days): 2017-01-01 to 2017-05-30 Network: 36 stations, 3 components each (HHE, HHN, HHZ) = 106 channels. (Station SA.UMJ02: only HHE channel) Sampling rate: 100 Hz Provided by: Mohammad Youssof (KAUST)","title":"0.5 SaudiFull data set: Saudi Arabia, January - May 2017"},{"location":"ex_params/#051-preprocessing","text":"Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/continuous_data_times_SaudiFull.sh The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_SaudiFull.py to plot the duration of available continuous data at each station and channel (Figure 7). Figure 7: Duration of SaudiFull continuous data at 36 stations (change colors with each station), 3 components each (except SA.UMJ02 which has only HHE). White sections indicate time gaps. Detected zero-filled time-gap sections of continuous data in all 106 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py), and filled them with random uncorrelated noise: ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Only stations SA.UMJ03, SA.UMJ05, SA.UMJ08 had zero-filled time-gap sections, which were filled with random noise and saved as files starting with the Filled.* string. The majority of continuous data files had no zero-filled time gaps, so we used original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/sample_spectrograms_SaudiFull.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/bandpass_filter_decimate_SaudiFull.sh Based on sample spectrograms, apply a station-specific bandpass filter (Table S11). Decimate by a factor of 2 to a sampling rate of 50 Hz. Filtered continuous data files start with Deci2.bpXtoY.* , where X is the lower frequency and Y is the higher frequency, which are input to the fingerprint step. Table S11: Preprocessing parameters for SaudiFull earthquake detection, for each station (same filter applied to all components), 5 months continuous data (2017-01-01 to 2017-05-31), at 36 stations, decimate to 50 Hz.","title":"0.5.1 Preprocessing"},{"location":"ex_params/#052-fingerprint","text":"Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/SaudiFull/run_fp_SaudiFull.sh Example script to generate fingerprints on one channel (HHZ) at one station (LNY03), called by the master script run_fp_SaudiFull.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/SaudiFull/fp_input_SA_LNY03_HHZ.json \"fingerprint\": { \"sampling_rate\": 50, \"min_freq\": 4.0, \"max_freq\": 15.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 0.1, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"LNY03\", \"channel\": \"HHZ\", \"start_time\": \"17-01-01T00:00:00.0\", \"end_time\": \"17-05-31T00:00:00.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/\", There are a total of 106 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S12. Median/MAD output files: mad/mad*.txt Table S12: Fingerprint input parameters for SaudiFull earthquake detection: 3-component at 36 stations (except for SA.UMJ02), after applying station-specific bandpass filter (Table S11), and sampled at 50 Hz. The fingerprint sampling period is dt_fp = 1.2 seconds. Fingerprints (binary files): fingerprints/LNY03.HHZ.fp Timestamps at each fingerprint index (text files): timestamps/LNY03.HHZ.ts Finally, to create global indices for the SaudiFull data set, so that fingerprint indices from different channels (all 106) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/SaudiFull/global_indices_SaudiFull.json The common starting time is in global_idx_stats.txt : 2017-01-01T00:00:06.840000 UTC","title":"0.5.2 Fingerprint"},{"location":"ex_params/#053-similarity-search","text":"Master script to run similarity search on each channel (out of 106 total): ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/run_simsearch_SaudiFull.sh Table S13: Similarity search input parameters for SaudiFull earthquake detection: 106 channels at 36 stations (3 components each, except SA.UMJ02). The occurrence filter, specified by the FREQ_NOISE parameter, was applied only for selected stations and channels (Table S14). Example script to run similarity search on one channel (HHZ) at one station (LNY03), called by the master script run_simsearch_SaudiFull.sh : ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/simsearch_input_SaudiFull.sh LNY03 HHZ NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 We first ran similarity search with the same input parameters on all 106 channels, without the occurrence filter. For 18 selected channels (Table S14), where the candidate_pairs similarity search outputs were especially large because of correlated noise, we ran similarity search with the occurrence filter (FREQ_NOISE=0.01), which significantly reduced the similarity search output file sizes. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. For example, the occurrence filter was applied for station LNY01 channel HHZ by calling the script filt_simsearch_input_SaudiFull.sh from the master script run_simsearch_SaudiFull.sh : ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/filt_simsearch_input_SaudiFull.sh LNY03 HHZ NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 FREQ_NOISE=0.01 Table S14: Selected stations and channels from SaudiFull data set where we applied the occurrence filter with FREQ_ NOISE=0.01.","title":"0.5.3 Similarity Search"},{"location":"ex_params/#054-postprocessing","text":"First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (106 total): ~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/output_SaudiFull_pairs.sh For example, on one channel (HHZ) at one station (LNY03), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/ -p candidate_pairs_LNY03_HHZ -i /lfs/1/ceyoon/TimeSeries/SaudiFull/global_indices/LNY03_HHZ_idx_mapping.txt Output file for example (large size at channel level): /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/candidate_pairs_LNY03_HHZ_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for all 36 stations: ~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/combine_SaudiFull_pairs.sh Example For example, on three channels (HHE, HHN, HHZ) at one station (LNY03), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/ $ mv candidate_pairs_LNY03_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S13). Note: this step will delete the c andidate_ pairs_LNY03_HH*_merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ -p candidate_pairs_LNY03 --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ candidate_pairs_LNY03_combined.txt For station SA.UMJ02, which has only 1 component (HHE), multiply the similarity sim by 3 to give this station an equal weight as the other 3-component stations: ~/FAST/postprocessing/$ awk \u2019{print $1, $2, 3*$3}\u2019 /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_HHE_merged.txt > /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_combined.txt Finally , detect similar fingerprints across the network of 36 stations, using the input parameters in Table S15: ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/SaudiFull/36sta_3stathresh_network_params.json \"network\": { \"max_fp\": 10736786, \"dt_fp\": 1.2, (seconds) \"dgapL\": 10, (12 s) \"dgapW\": 3, (3.6 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (9.6 s) \"ivals_thresh\": 6, \"nsta_thresh\": 3, \"input_offset\": 15 (18 s) }, Network detection output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/SaudiFull/ network_detection/36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events) At this point, FAST earthquake detection processing is done . Table S15: Network detection input parameters for SaudiFull at 36 stations. max_fp = 10736786 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.2 seconds is the fingerprint sampling period from Table S12.","title":"0.5.4 Postprocessing"},{"location":"ex_params/#055-remove-duplicates-after-network-detection","text":"Info The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.) First , save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind). ~/FAST/utils/network/$ python arrange_network_detection_results.py Output: NetworkDetectionTimes_36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events) Second , remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity). ~/FAST/utils/network/$ ./remove_duplicates_after_network.sh Output: uniquestart_sorted_no_duplicates.txt (15,054 events) Third , remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum. ~/FAST/utils/network/$ python delete_overlap_network_detections.py Output: 36sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (11,597 events) Fourth , since different channels in the network have different durations (for example, in Figure 7, stations UMJ01-UMJ12 were active only during May 2017, while many of the other stations were active from January to May 2017), we calculate a normalized measure of the number of stations that detected the event: frac_ch, which is the fraction of channels that were active at each detection time. This is done by reading in files that were generated during preprocessing by get_continuous_data_times.py. This normalization step would not be necessary if all stations and channels in the network recorded the same duration of data. ~/FAST/utils/network/$ python get_station_count_detections.py Output: 36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt (11,597 events) Finally , sort remaining events in descending order of num_sta, then frac_ch, then peaksum, for the final detection list. ~/FAST/utils/network/$ ./final_network_sort_nsta_fracch_peaksum.sh Output: sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt (11,597 events)","title":"0.5.5 Remove Duplicates After Network Detection"},{"location":"ex_params/#056-visual-inspection-and-final-detections","text":"Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table S16). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_SaudiFull.py 0 11597 Output: .png image files in 36sta_3stathresh_NetworkWaveformPlots/ Table S16: Final thresholds for SaudiFull applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied. After visual inspection, 4634 events are above thresholds in Table S16. EQ_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt : 4543 events that look like earthquake waveforms FALSE_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt : 91 false detections above thresholds that do not look like earthquakes For the 4543 earthquake events, output an event catalog (Figure 8): ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_SaudiFull_36sta_3stathresh.txt (4543 events) Figure 8: Saudi Arabia earthquake detections from 2017-01-01 to 2017-05-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S16). FAST detected a total of 4,543 earthquakes during this month.","title":"0.5.6 Visual Inspection and Final Detections"},{"location":"ex_params/#06-ometepec-mexico-january-april-2012","text":"Figure 9: Map of 1 station in southern Mexico (black triangle) used for FAST detection of small earthquakes from 2012-01-01 to 2012-04-21. The SSN catalog (http://www2.ssn.unam.mx:8080/catalogo/) had 558 earthquakes (circles colored by depth, sized by relative magnitudes 2.8 \u2264 M \u2264 7.5) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.5 Ometepec earthquake on 2012-03-20. Info The objective of this study is to identify repeating earthquake sequences as tools to measure deep aseismic slip rates [Dominguez et al., 2016], and characterize the unusually active aftershock sequence of the Mw 7.5 Omepetec, Mexico earthquake on 2012-03-20 [UNAM, 2013] (Figure 9). 112 days of continuous data (2012-01-01 to 2012-04-21) at 1 station, 3 components, provided by Luis Dominguez of Universidad Nacional Autonoma de Mexico (UNAM)-Morelia. For all 3 channels, I applied a 3-20 Hz bandpass filter, and kept the original sampling rate of 100 Hz. FAST detected a total of 31,970 earthquakes during these 4 months. 30,923 were earthquakes (Figure 10), and 1,047 were noise, as determined by visual inspection. ***NOTE: postprocessing and elimination of duplicate detection pairs was done with the old MATLAB code from [Yoon et al., 2015] and [Yoon et al., 2017]. Single-station event-pair extraction with network FAST was not yet available. These were the events I sent to Luis, who performed single-station location using P-wave polarization analysis (Figure 10). Table S17: FAST input parameters for Ometepec, Mexico earthquake detection, applied to each component at station IG.PNIG. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 4,795,140. Figure 10: Ometepec, Mexico earthquake detections from 2012-01-01 to 2012-04-21. The blue dots indicate the total 3-component FAST similarity (left y-axis) of the 30,923 FAST detections as a function of time. The red dots indicate the magnitudes (right y-axis) of the 558 catalog events as a function of time. Following the Mw 7.5 earthquake on 2012-03-20, aftershocks are abundant.","title":"0.6 Ometepec, Mexico, January - April 2012"},{"location":"ex_params/#07-seismolympics-wenchuan-aftershocks","text":"Info Alibaba Cloud and the China Earthquake Administration sponsored a \u201dSeismOlympics\u201d programming competition to detect aftershocks of the deadly May 12, 2008 Mw 7.9 Wenchuan, China, earthquake [Fang et al., 2017], similar to the Netflix Prize or the Kaggle data science competitions. Competitors from seismology, machine learning, signal processing, computer science, and other backgrounds developed algorithms that automatically detect and pick phases on aftershock waveforms while avoiding false positive detections. Performance was evaluated against phases picked by human analysts. This was a great opportunity to test how the FAST earthquake detection algorithm measured up against other methods. Other members of my team, all from Stanford Geophysics (Mostafa Mousavi, Yixiao Sheng, Weiqiang Zhu) used machine learning to pick phases and recognize false detections. We finished in 27th place in the first round of competition, and 16th place in the second round. Figure 11: Map of 15 stations in Wenchuan, China used for FAST detection of small earthquakes in 3 months of continuous data. The ComCat catalog had 1039 aftershocks (circles colored by depth, sized by relative magnitudes 3.2 \u2264 M \u2264 6.1) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.9 Wenchuan earthquake on 2008-05-12. After the competition, I applied FAST to detect earthquakes within the entire continuous data set provided in both rounds of competition. 3 months of seismic data: April 1-22, 2008 (foreshocks), July 1-August 31, 2008 (aftershocks), at 15 stations (Figure 11) with 3 components each, although some stations only have data for part of this time. For all 45 channels, I applied the following preprocessing: 1-20 Hz bandpass filter, then decimated to 50 Hz (factor of 2, from original 100 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise. FAST detected about 12,000 earthquakes; some of them are teleseismic because the 1-20 Hz filter includes lower frequencies. Table S18: FAST input parameters for Wenchuan 2008 aftershock detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 3,612,972. Table S19: Network detection input parameters for Wenchuan 2008 aftershock detection at 15 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S20: Final thresholds for Wenchuan 2008 aftershock detection applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.","title":"0.7 SeismOlympics: Wenchuan Aftershocks"},{"location":"ex_params/#08-groningen-data-set","text":"Location: Netherlands (gas production field) Duration: 4 months (119 days): 2018-01-01 to 2018-04-30 Network: 67 stations (Figure 12), 3 components each (HH1, HH2, HHZ) = 201 channels. (Station G294 not used for detection due to short duration) Sampling rate: 20 Hz (already downsampled) Provided by: Zack Spica (Stanford Geophysics) Figure 12: Groningen map provided by Zack Spica: 67 stations (black, red triangles) used for FAST detection, and locations of known catalog events (blue circles).","title":"0.8 Groningen Data Set"},{"location":"ex_params/#081-preprocessing","text":"Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/continuous_data_times_Groningen.sh Figure 13: Duration of Groningen continuous data at 67 stations (change colors with each station), 3 components each. White sections indicate time gaps. The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_Groningen.py to plot the duration of available continuous data at each station and channel (Figure 13). Confirmed no zero-filled time-gap sections of continuous data in all 201 channels (need to modify paths in fill_time_gaps_with_uncorrelated_noise.py): ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Use original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/sample_spectrograms_Groningen.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/bandpass_filter_decimate_Groningen.sh Based on sample spectrograms, filter 3-10 Hz for all 201 channels. No need to decimate, as sampling rate is already low at 20 Hz. Filtered continuous data files start with Deci1.bp3to10.*, which are input to the fingerprint step.","title":"0.8.1 Preprocessing"},{"location":"ex_params/#082-fingerprint","text":"Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/Groningen/run_fp_Groningen.sh Example script to generate fingerprints on one channel (HHZ) at one station (G014), called by the master script run_fp_Groningen.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/Groningen/fp_input_NL_G014_HHZ.json \"fingerprint\": { \"sampling_rate\": 20, \"min_freq\": 3.0, \"max_freq\": 10.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 0.05, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"G014\", \"channel\": \"HHZ\", \"start_time\": \"18-01-01T00:00:00.0\", \"end_time\": \"18-04-30T00:00:00.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/\", There are a total of 201 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S21. Table S21: Fingerprint input parameters for Groningen earthquake detection: 3-component at 67 stations (Figure 12, red, black triangles), after bandpass filter 3-10 Hz, and sampled at 20 Hz. The fingerprint sampling period is dt_fp = 1.5 seconds. Median/MAD output files: mad/mad*.txt Fingerprints (binary files): fingerprints/G014.HHZ.fp Timestamps at each fingerprint index (text files): timestamps/G014.HHZ.ts Finally, to create global indices for the Groningen data set, so that fingerprint indices from different channels (all 201) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/Groningen/global_indices_Groningen.json The common starting time is in global_idx_stats.txt : 2018-01-01T00:00:04.500000 UTC","title":"0.8.2 Fingerprint"},{"location":"ex_params/#083-similarity-search","text":"Master script to run similarity search on each channel (out of 201 total): ~/FAST/simsearch/$ ../parameters/simsearch/Groningen/run_simsearch_Groningen.sh Table S22: Similarity search input parameters for Groningen earthquake detection: 201 channels at 67 stations (3 components each). Example script to run similarity search on one channel (HHZ) at one station (G014), called by the master script run_simsearch_Groningen.sh: ~/FAST/simsearch/$ ../parameters/simsearch/Groningen/filt_simsearch_input_Groningen.sh G014 HHZ NTBLS=100 NHASH=5 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 FREQ_NOISE=0.01 Similarity search is run with the occurrence filter (FREQ_NOISE=0.01) for all 201 channels. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. The same input parameters are used for similarity search on all 201 channels (Table S22).","title":"0.8.3 Similarity Search"},{"location":"ex_params/#084-postprocessing","text":"First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (201 total): ~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/output_Groningen_pairs.sh For example, on one channel (HHZ) at one station (G014), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/ -p candidate_pairs_G014_HHZ -i /lfs/1/ceyoon/TimeSeries/Groningen/global_indices/G014_HHZ_idx_mapping.txt Output file for example (large size at channel level): /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/ fingerprints/candidate_pairs_G014_HHZ_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for all 67 stations: ~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/combine_Groningen_pairs.sh For example, on three channels (HH1, HH2, HHZ) at one station (G014), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/ $ mv candidate_pairs_G014_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components) (v=2 votes/component, Table S22). Note: this step will delete the candidate_ pairs_G014_HH _merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ -p candidate_pairs_G014 --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ candidate_pairs_G014_combined.txt Finally , detect similar fingerprints across the network of 67 stations, using the input parameters in Table S23: ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/Groningen/67sta_3stathresh_network_params.json \"network\": { \"max_fp\": 6798013, \"dt_fp\": 1.5, (seconds) \"dgapL\": 10, (15 s) \"dgapW\": 3, (4.5 s) \"num_pass\": 2, 28 }, Table S23: Network detection input parameters for Groningen at 67 stations. max_fp = 6798013 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.5 seconds is the fingerprint sampling period from Table S21. Network detection output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/Groningen/ network_detection/67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events) At this point, FAST earthquake detection processing is done.","title":"0.8.4 Postprocessing"},{"location":"ex_params/#085-remove-duplicates-after-network-detection","text":"The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.) First , save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind). ~/FAST/utils/network/$ python arrange_network_detection_results.py Output: NetworkDetectionTimes_67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events) Second , remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity). ~/FAST/utils/network/$ ./remove_duplicates_after_network.sh Output: uniquestart_sorted_no_duplicates.txt (13,782 events) Third , remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum. ~/FAST/utils/network/$ python delete_overlap_network_detections.py Output: 67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (6277 events) Finally , sort remaining events in descending order of num_sta, then peaksum, for the final detection list. ~/FAST/utils/network/$ ./final_network_sort_nsta_peaksum.sh Output: sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (6277 events)","title":"0.8.5 Remove duplicates after network detection"},{"location":"ex_params/#086-visual-inspection-and-final-detections","text":"Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table 0.8.6). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_Groningen.py 0 6277 Output: .png image files in 67sta_3stathresh_NetworkWaveformPlots/ Table S24: Final thresholds for Groningen applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied. After visual inspection, 26 events are above thresholds in Table 0.8.6. EQ_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt : 23 events that look like earthquake waveforms FALSE_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt : 3 false detections above thresholds that do not look like earthquakes For the 23 earthquake events, output an event catalog: ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_Groningen_67sta_13stathresh.txt (23 events)","title":"0.8.6 Visual inspection and final detections"},{"location":"ex_params/#09-brazilacre-data-set","text":"Location: Acre, Brazil (search for intermediate-depth and deep earthquakes) Duration: about 3 months (with time gaps): 2015-05-28 to 2016-02-01 Network: 1 station (Figure 14), 3 components (HHE, HHN, HHZ) = 3 channels. \u2022 Sampling rate: 100 Hz Provided by: Marcelo de Bianchi (University of Sao Paulo) Figure 14: Acre, Brazil map provided by Marcelo de Bianchi: 1 station (yellow triangle) used for FAST detection, and locations of known catalog events (circles colored by depth).","title":"0.9 BrazilAcre Data Set"},{"location":"ex_params/#091-preprocessing","text":"Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/continuous_data_times_BrazilAcre.sh The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_BrazilAcre.py to plot the duration of available continuous data at each station and channel (Figure 15). Figure 15: Duration of BrazilAcre continuous data at 1 station (3 components). White sections indicate time gaps. Confirmed no zero-filled time-gap sections of continuous data in all 3 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py): ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Use original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/sample_spectrograms_BrazilAcre.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/BrazilAcre/bandpass_filter_decimate_BrazilAcre.sh Based on sample spectrograms, filter 3-20 Hz for all 3 channels. Decimate by a factor of 2, to 50 Hz sampling rate. Filtered continuous data files start with Deci2.bp3to20.*, which are input to the fingerprint step. Need to add .mseed extension to all time series files, otherwise the Julian day number in the time series file gets removed while fingerprinting, and we cannot tell the difference between fingerprints from different days.","title":"0.9.1 Preprocessing"},{"location":"ex_params/#092-fingerprint","text":"Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/BrazilAcre/run_fp_BrazilAcre.sh Example script to generate fingerprints on one channel (HHE) at one station (CZSB), called by the master script run_fp_BrazilAcre.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/BrazilAcre/fp_input_BR_CZSB_HHE.json \"fingerprint\": { \"sampling_rate\": 50, \"min_freq\": 3.0, \"max_freq\": 20.0, \"spec_length\": 10.0, \"spec_lag\": 0.2, \"fp_length\": 128, Continuous Data (Network.Station.Channel) \"fp_lag\": 10, \"k_coef\": 800, \"nfreq\": 32, \"mad_sampling_rate\": 0.1, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"CZSB\", \"channel\": \"HHE\", \"start_time\": \"15-10-28T00:00:00.0\", \"end_time\": \"16-02-01T00:00:03.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/\", There are a total of 3 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S25. Table S25: Fingerprint input parameters for BrazilAcre earthquake detection: 3-component at 1 station (Figure 14, yellow triangle), after bandpass filter 3-20 Hz, and decimated to 50 Hz sampling rate. The fingerprint sampling period is dt_fp = 2 seconds. Median/MAD output files: mad/mad*.txt Fingerprints (binary files): fingerprints/CZSB.HHE.fp Timestamps at each fingerprint index (text files): timestamps/CZSB.HHE.ts Finally, to create global indices for the BrazilAcre data set, so that fingerprint indices from different channels (all 3) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/BrazilAcre/global_indices_BrazilAcre.json The common starting time is in global_idx_stats.txt: 2015-10-28T00:00:21.340000 UTC","title":"0.9.2 Fingerprint"},{"location":"ex_params/#093-similarity-search","text":"Master script to run similarity search on each channel (out of 3 total): ~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/run_simsearch_BrazilAcre.sh Example script to run similarity search on one channel (HHE) at one station (CZSB), called by the master script run_simsearch_BrazilAcre.sh : ~/FAST/simsearch/$ ../parameters/simsearch/BrazilAcre/filt_simsearch_input_BrazilAcre.sh CZSB HHE NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 Table S26: Similarity search input parameters for BrazilAcre earthquake detection: 3 channels at 1 station (3 components each). The same input parameters are used for similarity search on all 3 channels (Table S26).","title":"0.9.3 Similarity Search"},{"location":"ex_params/#094-postprocessing","text":"First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (3 total): ~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/output_BrazilAcre_pairs.sh For example, on one channel (HHE) at one station (CZSB), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ -p candidate_pairs_CZSB_HHE -i /lfs/1/ceyoon/TimeSeries/BrazilAcre/global_indices/CZSB_HHE_idx_mapping.txt Output file for example (large size at channel level): / lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ candidate_pairs_CZSB_HHE_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for 1 station: ~/FAST/postprocessing/$ ../parameters/postprocess/BrazilAcre/combine_BrazilAcre_pairs.sh For example, on three channels (HHE, HHN, HHZ) at one station (CZSB), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/BrazilAcre/CZSB/fingerprints/ $ mv candidate_pairs_CZSB_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S26). Note: this step will delete the candidate_ pairs_CZSB_HH*_merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ -p candidate_pairs_CZSB --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/BrazilAcre/inputs_network/ candidate_pairs_CZSB_combined.txt Finally, detect similar fingerprints across the network of 1 station, using the input parameters in Table S27 (Note: this step only aggregates similar event pairs from similar fingerprints, and resolves the pairs into a list of candidate events, since there is only 1 station.): ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/BrazilAcre/1sta_1stathresh_network_params.json \"network\": { \"max_fp\": 4147182, \"dt_fp\": 2.0, (seconds) \"dgapL\": 10, (20 s) \"dgapW\": 3, (6 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (16 s) \"ivals_thresh\": 6, \"nsta_thresh\": 1, \"input_offset\": 15 (30 s) <--- NOT USED }, Table S27: Network detection input parameters for BrazilAcre at 1 station. max_fp = 4147182 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 2 seconds is the fingerprint sampling period from Table S25. Network detection output file: /lfs/1/ceyoon/TimeSeries/BrazilAcre/network_detection/1sta_1stathresh_detlist_rank_by_peaksum.tx t (14,477 events) At this point, FAST earthquake detection processing is done.","title":"0.9.4 Postprocessing"},{"location":"ex_params/#095-remove-duplicates-after-network-detection","text":"Sort events in descending order of peaksum (peak similarity score between similar fingerprints) for the final detection list. ~/FAST/utils/network/$ ./final_single_station_sort_nsta_peaksum.sh Output: sort_peaksum_1sta_1stathresh_CZSB_events.txt (14,477 events)","title":"0.9.5 Remove duplicates after network detection"},{"location":"ex_params/#096-visual-inspection-and-final-detections","text":"Plot event waveforms in the final detection list, ranked in descending order of peaksum (peak similarity score between similar fingerprints), for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (peaksum \u2265 6). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_BrazilAcre.py 0 14477 Output: .png image files in 1sta_1stathresh_NetworkWaveformPlots/ (zip file) Visual inspection shows that there are many false detections that do not look like earthquake waveforms (for example, event_rank00000_peaksum116351_ind854248_time1708496.0_2015-11-16T18/35/17.340000.png ). However, some earthquake waveforms (for example, event_rank00049_peaksum26898_ind1297608_time2595216 . 0_2015-11-27T00/53/57.340000.png ) are also detected. I suggest running FAST on at least 3 stations for reliable earthquake detection. 14,474 events are above the arbitrary low threshold (peaksum \u2265 6). EQ_sort_peaksum_1sta_1stathresh_CZSB_events.txt For the 14,474 events, output a catalog-like formatted list: ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_BrazilAcre_1sta_1stathresh_peaksum6.txt (14,474 events)","title":"0.9.6 Visual inspection and final detections"},{"location":"ex_params/#010-new-zealand-year-2010","text":"Info The objective of this study is to detect small earthquakes in New Zealand to test earthquake triggering hypothesis. Detection results, with input parameters, are described in Rong et al. [2018]. 1 year continuous data (2010), 5 seismic stations LTZ, MQZ, KHZ, THZ, OXZ (Figure 16, black triangles), vertical components only, sampled at 100 Hz. Detections were compared against the GeoNet catalog, and visually inspected. FAST detected 11419 events: 4916 catalog events (Figure 16, red circles), 355 teleseismic events, 6123 new local earthquakes and 25 false positives (noise waveforms). Figure 16: New Zealand map: 5 stations (black triangles) used for FAST detection (except GVZ which was not used), and locations of GeoNet catalog events (circles). 4916 catalog events were detected by FAST (red circles). Catalog events missed by FAST are displayed as green circles.","title":"0.10 New Zealand, Year 2010"},{"location":"ex_params/#011-calipatria-june-2021","text":"","title":"0.11 Calipatria, June 2021"},{"location":"ex_params_intro/","text":"0.1 Introduction \u00b6 FAST is available to the public at https://github.com/stanford-futuredata/FAST as open-source software, and it will be released with a comprehensive user manual containing guidance for setting parameters. Interested users can run FAST to perform an uninformed search for earthquakes with similar waveforms on any seismic network, with varying duration of continuous data and number of stations. The FAST software has successfully detected earthquakes in the following data sets. FAST will only reach its full potential as a tool for seismological discovery if other users apply it to their own data sets (filling the N and T gaps in Figure 1) and improve the detection algorithms. Thank you to all collaborators and interested users who shared data, which was useful for testing the FAST software and identifying bug fixes, in preparation for its public release. Figure 1: Dimensions of different data sets where FAST has successfully detected similar earthquakes. The log-scale axes represent the directions of data growth in seismology to \u201dlarge-T\u201d and \u201dlarge-N\u201d big data sets (Chapters 1 and 5): T is the longest duration of continuous data over all stations in the data set, while N is the number of seismic stations in the data set. Blue stars: data sets from Chapters 2-5. Red stars: additional data sets from Appendix A, Sections A.1-A.6.","title":"0.1 Introduction"},{"location":"ex_params_intro/#01-introduction","text":"FAST is available to the public at https://github.com/stanford-futuredata/FAST as open-source software, and it will be released with a comprehensive user manual containing guidance for setting parameters. Interested users can run FAST to perform an uninformed search for earthquakes with similar waveforms on any seismic network, with varying duration of continuous data and number of stations. The FAST software has successfully detected earthquakes in the following data sets. FAST will only reach its full potential as a tool for seismological discovery if other users apply it to their own data sets (filling the N and T gaps in Figure 1) and improve the detection algorithms. Thank you to all collaborators and interested users who shared data, which was useful for testing the FAST software and identifying bug fixes, in preparation for its public release. Figure 1: Dimensions of different data sets where FAST has successfully detected similar earthquakes. The log-scale axes represent the directions of data growth in seismology to \u201dlarge-T\u201d and \u201dlarge-N\u201d big data sets (Chapters 1 and 5): T is the longest duration of continuous data over all stations in the data set, while N is the number of seismic stations in the data set. Blue stars: data sets from Chapters 2-5. Red stars: additional data sets from Appendix A, Sections A.1-A.6.","title":"0.1 Introduction"},{"location":"f_p/","text":"Fingerprint \u00b6 Feature Extraction Overview \u00b6 Step 1: Time Series --> Spectrogram \u00b6 Step 2: Spectrogram --> Spectral Images \u00b6 To find short duration events, divide spectrogram into overlapping spectral images Long lag --> fewer spectral images to compare --> fast Step 3: Spectral Image --> Wavelet Transform \u00b6 Goal: compress nonstationary seismic signal Compute 2D discrete wavelet transform (Haar basis) of spectral image to get wavelet coefficients Step 4: Spectrogram --> Spectral Images \u00b6 Key discriminative features are concentrated ina few wavelet coefficients with highest deviation Deviation defined by median/MAD over entire data set Keep only sign (+ or -) of these coefficients, set rest to 0 Data compression, robust to noise Step 5: Spectrogram --> Spectral Images \u00b6 Fingerprint must be compact and sparse to store in database Convert top coefficients to a binary sequence of 0\u2019s, 1\u2019s Negative: 01, Zero: 00, Positive: 10 How do we measure similarity? \u00b6 Fingerprint Parameters \u00b6 { \"fingerprint\": { \"sampling_rate\": 20, # Sampling rate (Hz) \"min_freq\": 0.0, # Bandpass frequency (Hz) - minimum \"max_freq\":, 10.0, # Bandpass frequency (Hz) \u2013 maximum \"spec_length\": 6.0, # Time window length (s) for spectrogram \"spec_lag\": 0.2, # Time window lag (s) for spectrogram \"fp_length\": 32, # Spectral image length (samples) \"fp_lag\": 5, # Spectral image lag (samples) \"k_coef\": 200, # Number of wavelet coefficients to keep \"nfreq\": 32, # Final spectral image width (samples) \"mad_sampling_rate\": 1, # Median/MAD sampling fraction of data \"mad_sampling_interval\": 86400 # Median/MAD sampling frequency (s) } } Note Need one input file per component at each station: parameters/fingerprint/fp_input_${NETWORK}_${STATION}_${CHANNEL}.json Example: fp_input_CI_CDY_EHZ.json How to select bandpass filter? \u00b6 Filter can be different for different stations and components Contain as much of your desired earthquake signal as possible; not too narrowband Remove frequencies with repeated noise: important View sample spectrograms to empirically determine these noisy frequencies (output as .png image files): parameters/preprocess_utils/sample_spectrograms_daily _NEP.py Twice a day (day and night: cultural noise variations) Once a month or once a day \u2013 sample randomly Usually 0-2 Hz has repeated noise; sometimes >20 Hz Without this step, similar noise signals will dominate your detections --> you will not find earthquakes May want to avoid teleseismic event detection Lower limit 3-4 Hz 4-12 Hz generally works well as default Example: Bandpass filter selection, given sample spectrogram \u00b6 \"spec_length\": 6.0, # Time window length (s) for spectrogram \"spec_lag\": 0.2, # Time window lag (s) for spectrogram \"fp_length\": 32, # Spectral image length (samples) \"fp_lag\": 5, # Spectral image lag (samples) Info Spectral image (and fingerprint) length: 12.4 seconds Spectral image (and fingerprint) lag: 1 second Choose parameters so that entire earthquake waveform (P,S,coda) fits into fp_length time window Not too short (just P or S arrival), but not too long (otherwise adds noise) Choose same parameters for all components at all stations Adjust spec_length and fp_length values fp_length (samples) should be a power of 2 Required for the wavelet transform. If fp_length is not a power of 2, each spectral image will be downsampled to the next smallest power of 2. spec_lag should be short with >95% overlap between adjacent time windows; 0.05 to 0.2 seconds is a good default fp_lag : can be slightly longer with >85% overlap between adjacent spectral images; 0.5 to 2 seconds is a good default \"k_coef\": 200, # Number of wavelet coefficients to keep \"nfreq\": 32, # Final spectral image width (samples) Spectral image width will be resized (usually downsampled) to nfreq samples Initial spectral image width is 2 ( spec_length ) ( max_freq - min_freq ) samples: depends on bandpass filter nfreq must be a power of 2 for wavelet transform; 32 is good default value Each spectral image (and wavelet-transform) has dimensions = nfreq * fp_length This example: 32*32 = 1024 elements To set k_coef , keep ~20% of most anomalous wavelet coefficients This example: 200/1024 ~ 19.5% Fingerprint has twice as many elements as spectral image This example: 2 * 1024 = 2048 elements FAST Fingerprints: Sparsity Parameter \u00b6 \"mad_sampling_rate\": 1, # Median/MAD sampling fraction of data \"mad_sample_interval\": 86400, # Median/MAD sampling interval (s) For each coefficient, compute median/MAD statistics over entire data set. This step determines which k_coef wavelet coefficients to keep. But if data set is too long (months-years), compute statistics over a representative sample of data mad_sampling_rate : fraction of entire continuous data set used to compute median/MAD Duration of sampled data set = ( mad_sampling_rate ) * (continuous data duration) should not exceed 1 week, otherwise may not fit in memory Retrieve sample of data for median/MAD statistics once per mad_sample_interval 86400 s = 1 day is a good default value Exact time of sample is determined randomly : expect different numbers every time you run this Median/MAD for each coefficient: pre-computed and stored in a text file, then read in during fingerprint generation data/waveforms${STATION}/mad/mad*.txt Rule of thumb Duration <1 week: set to 1 (use entire data set for sample) Duration weeks \u2013 months: set to 0.1 (sample 10% of data) Duration >1 year: set to 0.01 (sample 1% of data) Runtime-accuracy tradeoff \"performance\": { \"num_fp_thread\": 8, # Number of parallel processes \"partition_len\": 86400 # Continuous data partition (s) }, Can generate fingerprints in parallel by setting num_fp_thread > 1 Each process gets one continuous data file Better parallelization if you have one mseed file per day, rather than one per month Generate fingerprints partition_len at a time 86400 s (1 day) is a good default value Changing these \u201cperformance\u201d parameters should not affect the final results \"data\": { \"station\": \"CDY\", \"channel\": \"EHZ\", \"start_time\": \"99-10-15T13:00:00.0\", # Time format: YY-MM-DDTHH:MM:SS.S \"end_time\": \"99-10-16T09:46:44.0\", \"folder\": \"../data/waveformsCDY/\", # folder with input data \"fingerprint_files\": [ # Usually finerprint_files, MAD_samples_files should be the same; can have list of multiple files for input continuous data \"Deci5.Pick.19991015130000.CI.CDY.EHZ.sac\"], \"MAD_sample_files\": [ \"Deci5.Pick.19991015130000.CI.CDY.EHZ.sac\"] } OUTPUTS ${folder}/fingerprints/ Fingerprints from each continuous data file (can delete these later): fp_* Single file with all fingerprints: ${STATION}.${CHANNEL}.fp For example: data/waveformsCDY/fingerprints/CDY.EHZ.fp ${folder}/timestamps/ Timestamp (YYYY-MM-DDTHH:MM:SS.SSS) for each fingerprint Timestamps from each continuous data file (used later for global index calculation): ts_* Global Index: Inputs & Outputs \u00b6 Input file: global_indices.json { \"index_folder\": \"../data/global_indices/\", # Output folder \"fp_param_dir\": \"../parameters/fingerprint/\", # Input folder \"fp_params\": [\"fp_input_CI_TPC_EHZ.json\", \"fp_input_CI_RMR_EHZ.json\", # Fingerprint input files for all components and stations to use for detection \"fp_input_CI_RMM_EHZ.json\u201d, \"fp_input_CI_HEC_BHE.json\u201c, \"fp_input_CI_HEC_BHN.json\", \"fp_input_CI_HEC_BHZ.json\u201c, \"fp_input_CI_CPM_EHZ.json\", \"fp_input_CI_GTM_EHZ.json\", \"fp_input_CI_CDY_EHZ.json\"] } Outputs: Global start time \u201ct0\u201d for index 0 (YYYY-MM-DD THH:MM:SS.SSS), fingerprint input file names: global_idx_stats.txt Global index files for each channel, containing global index of each fingerprint: ${STATION}_${CHANNEL}_idx_mapping.txt Sample Fingerprint Parameters \u00b6 Find a sample fingerprint parameters json file here . You can duplicate this file for each component and change the parameters as needed. You must edit the data section of the file and change the filename for each component. Follow the file naming convention: fp_input_NETWORK_STATION_CHANNEL.json Example fingerprint parameter settings: { \"fingerprint\": { (fingerprint settings) \"sampling_rate\": 100, (sampling rate in Hz) \"min_freq\": 2.0, (min bandpass frequency in Hz) \"max_freq\": 20.0, (max bandpass frequency in Hz) \"spec_length\": 6.0, (length of spectrogram window in seconds) \"spec_lag\": 0.2, (lag between neighboring spectrogram windows in seconds) \"fp_length\": 128, (fingerprint length in samples) \"fp_lag\": 10, (fingerprint lag in samples) \"k_coef\": 1600, (number of top haar wavelet coefficients to keep) \"nfreq\": 32, (number of frequency / time bins in fingerprints (must be power of 2)) \"mad_sampling_rate\": 0.1, (sampling rate for calculating MAD statistics) \"mad_sample_interval\": 14400 (sampling interval for calculating MAD statistics in seconds) }, \"performance\": { (performance settings) \"num_fp_thread\": 12, (number of threads) \"partition_len\": 28800 (fingerprint partition length in seconds) }, \"data\": { (data settings) \"station\": \"KHZ\", \"channel\": \"HHZ\", \"start_time\": \"10-01-01T00:00:00.0\", \"end_time\": \"10-06-01T00:00:00.0\", \"folder\": \"../bp2to20_waveformsKHZ/\", \"fingerprint_files\": [ \"bp2to20.NZ.KHZ.10.HHZ__20100101T000000Z__20100201T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100201T000000Z__20100301T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100301T000000Z__20100401T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100401T000000Z__20100501T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100501T000000Z__20100601T000000Z.mseed\"], \"MAD_sample_files\": [ \"bp2to20.NZ.KHZ.10.HHZ__20100101T000000Z__20100201T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100201T000000Z__20100301T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100301T000000Z__20100401T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100401T000000Z__20100501T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100501T000000Z__20100601T000000Z.mseed\"] } } Fingerprint Examples from GitHub \u00b6 Click here for more example fingerprint parameters such as: Info File can be found in FAST/parameters/fingerprint/fp_input_CI_CDY_EHZ.json Click here for an example fingerprint script such as: Info File can be found in FAST/parameters/fingerprint/run_fp_HectorMine.sh","title":"Fingerprint"},{"location":"f_p/#fingerprint","text":"","title":"Fingerprint"},{"location":"f_p/#feature-extraction-overview","text":"","title":"Feature Extraction Overview"},{"location":"f_p/#step-1-time-series-spectrogram","text":"","title":"Step 1: Time Series --&gt; Spectrogram"},{"location":"f_p/#step-2-spectrogram-spectral-images","text":"To find short duration events, divide spectrogram into overlapping spectral images Long lag --> fewer spectral images to compare --> fast","title":"Step 2: Spectrogram --&gt; Spectral Images"},{"location":"f_p/#step-3-spectral-image-wavelet-transform","text":"Goal: compress nonstationary seismic signal Compute 2D discrete wavelet transform (Haar basis) of spectral image to get wavelet coefficients","title":"Step 3: Spectral Image --&gt; Wavelet Transform"},{"location":"f_p/#step-4-spectrogram-spectral-images","text":"Key discriminative features are concentrated ina few wavelet coefficients with highest deviation Deviation defined by median/MAD over entire data set Keep only sign (+ or -) of these coefficients, set rest to 0 Data compression, robust to noise","title":"Step 4: Spectrogram --&gt; Spectral Images"},{"location":"f_p/#step-5-spectrogram-spectral-images","text":"Fingerprint must be compact and sparse to store in database Convert top coefficients to a binary sequence of 0\u2019s, 1\u2019s Negative: 01, Zero: 00, Positive: 10","title":"Step 5: Spectrogram --&gt; Spectral Images"},{"location":"f_p/#how-do-we-measure-similarity","text":"","title":"How do we measure similarity?"},{"location":"f_p/#fingerprint-parameters","text":"{ \"fingerprint\": { \"sampling_rate\": 20, # Sampling rate (Hz) \"min_freq\": 0.0, # Bandpass frequency (Hz) - minimum \"max_freq\":, 10.0, # Bandpass frequency (Hz) \u2013 maximum \"spec_length\": 6.0, # Time window length (s) for spectrogram \"spec_lag\": 0.2, # Time window lag (s) for spectrogram \"fp_length\": 32, # Spectral image length (samples) \"fp_lag\": 5, # Spectral image lag (samples) \"k_coef\": 200, # Number of wavelet coefficients to keep \"nfreq\": 32, # Final spectral image width (samples) \"mad_sampling_rate\": 1, # Median/MAD sampling fraction of data \"mad_sampling_interval\": 86400 # Median/MAD sampling frequency (s) } } Note Need one input file per component at each station: parameters/fingerprint/fp_input_${NETWORK}_${STATION}_${CHANNEL}.json Example: fp_input_CI_CDY_EHZ.json","title":"Fingerprint Parameters"},{"location":"f_p/#how-to-select-bandpass-filter","text":"Filter can be different for different stations and components Contain as much of your desired earthquake signal as possible; not too narrowband Remove frequencies with repeated noise: important View sample spectrograms to empirically determine these noisy frequencies (output as .png image files): parameters/preprocess_utils/sample_spectrograms_daily _NEP.py Twice a day (day and night: cultural noise variations) Once a month or once a day \u2013 sample randomly Usually 0-2 Hz has repeated noise; sometimes >20 Hz Without this step, similar noise signals will dominate your detections --> you will not find earthquakes May want to avoid teleseismic event detection Lower limit 3-4 Hz 4-12 Hz generally works well as default","title":"How to select bandpass filter?"},{"location":"f_p/#example-bandpass-filter-selection-given-sample-spectrogram","text":"\"spec_length\": 6.0, # Time window length (s) for spectrogram \"spec_lag\": 0.2, # Time window lag (s) for spectrogram \"fp_length\": 32, # Spectral image length (samples) \"fp_lag\": 5, # Spectral image lag (samples) Info Spectral image (and fingerprint) length: 12.4 seconds Spectral image (and fingerprint) lag: 1 second Choose parameters so that entire earthquake waveform (P,S,coda) fits into fp_length time window Not too short (just P or S arrival), but not too long (otherwise adds noise) Choose same parameters for all components at all stations Adjust spec_length and fp_length values fp_length (samples) should be a power of 2 Required for the wavelet transform. If fp_length is not a power of 2, each spectral image will be downsampled to the next smallest power of 2. spec_lag should be short with >95% overlap between adjacent time windows; 0.05 to 0.2 seconds is a good default fp_lag : can be slightly longer with >85% overlap between adjacent spectral images; 0.5 to 2 seconds is a good default \"k_coef\": 200, # Number of wavelet coefficients to keep \"nfreq\": 32, # Final spectral image width (samples) Spectral image width will be resized (usually downsampled) to nfreq samples Initial spectral image width is 2 ( spec_length ) ( max_freq - min_freq ) samples: depends on bandpass filter nfreq must be a power of 2 for wavelet transform; 32 is good default value Each spectral image (and wavelet-transform) has dimensions = nfreq * fp_length This example: 32*32 = 1024 elements To set k_coef , keep ~20% of most anomalous wavelet coefficients This example: 200/1024 ~ 19.5% Fingerprint has twice as many elements as spectral image This example: 2 * 1024 = 2048 elements","title":"Example: Bandpass filter selection, given sample spectrogram"},{"location":"f_p/#fast-fingerprints-sparsity-parameter","text":"\"mad_sampling_rate\": 1, # Median/MAD sampling fraction of data \"mad_sample_interval\": 86400, # Median/MAD sampling interval (s) For each coefficient, compute median/MAD statistics over entire data set. This step determines which k_coef wavelet coefficients to keep. But if data set is too long (months-years), compute statistics over a representative sample of data mad_sampling_rate : fraction of entire continuous data set used to compute median/MAD Duration of sampled data set = ( mad_sampling_rate ) * (continuous data duration) should not exceed 1 week, otherwise may not fit in memory Retrieve sample of data for median/MAD statistics once per mad_sample_interval 86400 s = 1 day is a good default value Exact time of sample is determined randomly : expect different numbers every time you run this Median/MAD for each coefficient: pre-computed and stored in a text file, then read in during fingerprint generation data/waveforms${STATION}/mad/mad*.txt Rule of thumb Duration <1 week: set to 1 (use entire data set for sample) Duration weeks \u2013 months: set to 0.1 (sample 10% of data) Duration >1 year: set to 0.01 (sample 1% of data) Runtime-accuracy tradeoff \"performance\": { \"num_fp_thread\": 8, # Number of parallel processes \"partition_len\": 86400 # Continuous data partition (s) }, Can generate fingerprints in parallel by setting num_fp_thread > 1 Each process gets one continuous data file Better parallelization if you have one mseed file per day, rather than one per month Generate fingerprints partition_len at a time 86400 s (1 day) is a good default value Changing these \u201cperformance\u201d parameters should not affect the final results \"data\": { \"station\": \"CDY\", \"channel\": \"EHZ\", \"start_time\": \"99-10-15T13:00:00.0\", # Time format: YY-MM-DDTHH:MM:SS.S \"end_time\": \"99-10-16T09:46:44.0\", \"folder\": \"../data/waveformsCDY/\", # folder with input data \"fingerprint_files\": [ # Usually finerprint_files, MAD_samples_files should be the same; can have list of multiple files for input continuous data \"Deci5.Pick.19991015130000.CI.CDY.EHZ.sac\"], \"MAD_sample_files\": [ \"Deci5.Pick.19991015130000.CI.CDY.EHZ.sac\"] } OUTPUTS ${folder}/fingerprints/ Fingerprints from each continuous data file (can delete these later): fp_* Single file with all fingerprints: ${STATION}.${CHANNEL}.fp For example: data/waveformsCDY/fingerprints/CDY.EHZ.fp ${folder}/timestamps/ Timestamp (YYYY-MM-DDTHH:MM:SS.SSS) for each fingerprint Timestamps from each continuous data file (used later for global index calculation): ts_*","title":"FAST Fingerprints: Sparsity Parameter"},{"location":"f_p/#global-index-inputs-outputs","text":"Input file: global_indices.json { \"index_folder\": \"../data/global_indices/\", # Output folder \"fp_param_dir\": \"../parameters/fingerprint/\", # Input folder \"fp_params\": [\"fp_input_CI_TPC_EHZ.json\", \"fp_input_CI_RMR_EHZ.json\", # Fingerprint input files for all components and stations to use for detection \"fp_input_CI_RMM_EHZ.json\u201d, \"fp_input_CI_HEC_BHE.json\u201c, \"fp_input_CI_HEC_BHN.json\", \"fp_input_CI_HEC_BHZ.json\u201c, \"fp_input_CI_CPM_EHZ.json\", \"fp_input_CI_GTM_EHZ.json\", \"fp_input_CI_CDY_EHZ.json\"] } Outputs: Global start time \u201ct0\u201d for index 0 (YYYY-MM-DD THH:MM:SS.SSS), fingerprint input file names: global_idx_stats.txt Global index files for each channel, containing global index of each fingerprint: ${STATION}_${CHANNEL}_idx_mapping.txt","title":"Global Index: Inputs &amp; Outputs"},{"location":"f_p/#sample-fingerprint-parameters","text":"Find a sample fingerprint parameters json file here . You can duplicate this file for each component and change the parameters as needed. You must edit the data section of the file and change the filename for each component. Follow the file naming convention: fp_input_NETWORK_STATION_CHANNEL.json Example fingerprint parameter settings: { \"fingerprint\": { (fingerprint settings) \"sampling_rate\": 100, (sampling rate in Hz) \"min_freq\": 2.0, (min bandpass frequency in Hz) \"max_freq\": 20.0, (max bandpass frequency in Hz) \"spec_length\": 6.0, (length of spectrogram window in seconds) \"spec_lag\": 0.2, (lag between neighboring spectrogram windows in seconds) \"fp_length\": 128, (fingerprint length in samples) \"fp_lag\": 10, (fingerprint lag in samples) \"k_coef\": 1600, (number of top haar wavelet coefficients to keep) \"nfreq\": 32, (number of frequency / time bins in fingerprints (must be power of 2)) \"mad_sampling_rate\": 0.1, (sampling rate for calculating MAD statistics) \"mad_sample_interval\": 14400 (sampling interval for calculating MAD statistics in seconds) }, \"performance\": { (performance settings) \"num_fp_thread\": 12, (number of threads) \"partition_len\": 28800 (fingerprint partition length in seconds) }, \"data\": { (data settings) \"station\": \"KHZ\", \"channel\": \"HHZ\", \"start_time\": \"10-01-01T00:00:00.0\", \"end_time\": \"10-06-01T00:00:00.0\", \"folder\": \"../bp2to20_waveformsKHZ/\", \"fingerprint_files\": [ \"bp2to20.NZ.KHZ.10.HHZ__20100101T000000Z__20100201T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100201T000000Z__20100301T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100301T000000Z__20100401T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100401T000000Z__20100501T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100501T000000Z__20100601T000000Z.mseed\"], \"MAD_sample_files\": [ \"bp2to20.NZ.KHZ.10.HHZ__20100101T000000Z__20100201T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100201T000000Z__20100301T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100301T000000Z__20100401T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100401T000000Z__20100501T000000Z.mseed\", \"bp2to20.NZ.KHZ.10.HHZ__20100501T000000Z__20100601T000000Z.mseed\"] } }","title":"Sample Fingerprint Parameters"},{"location":"f_p/#fingerprint-examples-from-github","text":"Click here for more example fingerprint parameters such as: Info File can be found in FAST/parameters/fingerprint/fp_input_CI_CDY_EHZ.json Click here for an example fingerprint script such as: Info File can be found in FAST/parameters/fingerprint/run_fp_HectorMine.sh","title":"Fingerprint Examples from GitHub"},{"location":"fast_overview/","text":"FAST Overview \u00b6 What is FAST? \u00b6 FAST is an end-to-end and unsupervised earthquake detection pipeline\u2014it does not require any examples of known event waveforms or waveform characteristics for detection. This allows FAST to discover new earthquake sources, even if template waveforms (training data) is not available. It takes continuous seismic data from multiple stations as input and outputs a list of time stamps for potential detections. FAST draws on techniques used by content-based audio recognition systems (like the Shazam app , or Google's Waveprint algorithm), and adapts these methods for the unique characteristics of seismic waveform data. FAST was designed to complement existing energy-based detection methods like STA/LTA in order to find previously unknown earthquakes, especially small earthquakes, in seismic data. The image to the right gives an overview of the FAST pipeline, which involves gathering continuous seismic data, preprocessing the data with a bandpass filter, running FAST for feature extraction to get binary fingerprints, running a similarity search with MinHash and Locality Sensitive Hashing, post-processing to identify events and clean up the data, and outputting the detection results. Standard Earthquake Detection (STA/LTA) \u00b6 Ratio: Short Term Average / Long Term Average Traditionally, an earthquake is detected at one station at a time, using an energy detector such as a short-term average (STA)/long-term average (LTA). STA/LTA computes the ratio of the STA energy in a short time window to the LTA energy in a longer time window, as these windows slide through the continuous data. A detection is declared when the STA/LTA ratio exceeds certain thresholds. An association algorithm then determines whether detections at multiple stations across the network are consistent with a seismic source. If a seismic event is detected at a minimum of four stations, it is included in an earthquake catalog, which is a database of the location, origin time, and magnitude of known earthquakes. STA/LTA successfully identifies earthquakes with impulsive, high signal-to-noise ratio (snr) P-wave and S-wave arrivals presented below. STA/LTA rates high on general applicability, which we define as the ability to detect a wide variety of earthquakes without prior knowledge of the event waveform or source information. But STA/LTA fails to detect earthquakes, or may produce false detections, in more challenging situations such as low snr, waveforms with emergent arrivals, overlapping events, cultural noise, and sparse station spacing; thus, STA/LTA has low detection sensitivity as shown below. Therefore, earthquake catalogs are incomplete for lower-magnitude events. Read more here . Waveform Similarity \u00b6 Many algorithms have been developed to efficiently search for similar items in massive data sets; applications include identifying similar files in a large file system, finding near-duplicate Web pages, detecting plagiarism in documents, and recognizing similar audio clips for music identification, such as in the Shazam mobile app. We can meet our objective of a fast, efficient, automated blind detection of similar earthquake waveforms in huge volumes of continuous data by leveraging scalable algorithms that are widely used in the computer science community. Seismologists are just beginning to exploit data-intensive search technologies to analyze seismograms; one recent application is an earthquake search engine for fast focal mechanism identification that retrieves a best-fit synthetic seismogram from a large database, whereas another study developed a fast-approximation algorithm to find similar event waveforms within large catalogs. Rather than directly comparing waveforms, we first perform feature extraction to condense each waveform into a compact \u201cfingerprint\u201d that retains only its key discriminative features. A fingerprint serves as a proxy for a waveform; thus, two similar waveforms should have similar fingerprints, and two dissimilar waveforms should have dissimilar fingerprints. We assign the fingerprints (rather than waveforms) to LSH hash buckets. If you are interested in learning more about Locality Sensitive Hashing (LSH), check out \"Locality Sensitive Hashing (LSH) for Search with Shingling + MinHashing (Python)\" by James Briggs on YouTube. Our approach, an algorithm that we call Fingerprint And Similarity Thresholding (FAST) , builds on the Waveprint audio fingerprinting algorithm, which combines computer-vision techniques and large-scale data processing methods to match similar audio clips. We modified the Waveprint algorithm based on the properties and requirements of our specific application of detecting similar earthquakes from continuous seismic data. We chose Waveprint for its demonstrated capabilities in audio identification and its ease of mapping the technology to our application. First, an audio signal resembles a seismogram in several ways: they are both continuous time series waveform data, and the signals of interest are often nonimpulsive. Second, Waveprint computes fingerprints using short overlapping audio clips, as in autocorrelation. Third, Waveprint takes advantage of LSH to search through only a small subset of fingerprints. Waveprint also reports fast retrieval results with high accuracy, and its feature extraction steps are easily parallelizable. FAST scores high on three qualitative desirable metrics for earthquake detection methods (detection sensitivity, general applicability, and computational efficiency), whereas other earthquake detection algorithms (STA/LTA, template matching, and autocorrelation) do well on only two of the three. Waveform similarity allows detection of smaller earthquakes. A comprehensive, exhaustive search for earthquakes with similar waveforms. Efficient Search \u00b6 FAST identifies candidate earthquake waveforms using a blind search for similar waveforms in single-channel continuous ground motion data. Rather than using a brute-force search in the time domain, as in the autocorrelation method (Brown et al., 2008), FAST searches for similar waveform fingerprints using an efficient indexing and search procedure. The FAST similarity search involves two steps: the first is indexing a set of database fingerprints, and the second is querying the index to identify similar waveform fingerprints. Because FAST assumes no prior information about waveform signatures, we set up the similarity search in a manner that will identify any repeating or similar signals among the full set of waveform fingerprints. Therefore, in FAST similarity search we store the full set of fingerprints in the search index and we also use the full set of fingerprints as queries against the index, in a true blind search. The index is designed such that for each query fingerprint, FAST can identify similar fingerprints without having to scan the entire index. Rather than an exhaustive search, FAST performs an approximate similarity search, guaranteed to identify similar waveforms with high probability, which enables improved scalability and reduced runtime. Efficient search for similar items in large databases What can and can't FAST do? \u00b6 Typical use cases of FAST include weeks, months, or years of continuous seismic data at several stations, which FAST scans through to find small similar (or repeating) earthquakes. FAST will not detect an earthquake that occurs only once and is not similar enough to any other earthquakes in your continuous data set. Most similar earthquakes != largest earthquakes. Larger earthquakes often match a smaller earthquake on the coda, so they are detected with lower similarity (or not detected at all). FAST is intended to complement (not replace) existing energy-based detection methods like STA/LTA.","title":"FAST Overview"},{"location":"fast_overview/#fast-overview","text":"","title":"FAST Overview"},{"location":"fast_overview/#what-is-fast","text":"FAST is an end-to-end and unsupervised earthquake detection pipeline\u2014it does not require any examples of known event waveforms or waveform characteristics for detection. This allows FAST to discover new earthquake sources, even if template waveforms (training data) is not available. It takes continuous seismic data from multiple stations as input and outputs a list of time stamps for potential detections. FAST draws on techniques used by content-based audio recognition systems (like the Shazam app , or Google's Waveprint algorithm), and adapts these methods for the unique characteristics of seismic waveform data. FAST was designed to complement existing energy-based detection methods like STA/LTA in order to find previously unknown earthquakes, especially small earthquakes, in seismic data. The image to the right gives an overview of the FAST pipeline, which involves gathering continuous seismic data, preprocessing the data with a bandpass filter, running FAST for feature extraction to get binary fingerprints, running a similarity search with MinHash and Locality Sensitive Hashing, post-processing to identify events and clean up the data, and outputting the detection results.","title":"What is FAST?"},{"location":"fast_overview/#standard-earthquake-detection-stalta","text":"Ratio: Short Term Average / Long Term Average Traditionally, an earthquake is detected at one station at a time, using an energy detector such as a short-term average (STA)/long-term average (LTA). STA/LTA computes the ratio of the STA energy in a short time window to the LTA energy in a longer time window, as these windows slide through the continuous data. A detection is declared when the STA/LTA ratio exceeds certain thresholds. An association algorithm then determines whether detections at multiple stations across the network are consistent with a seismic source. If a seismic event is detected at a minimum of four stations, it is included in an earthquake catalog, which is a database of the location, origin time, and magnitude of known earthquakes. STA/LTA successfully identifies earthquakes with impulsive, high signal-to-noise ratio (snr) P-wave and S-wave arrivals presented below. STA/LTA rates high on general applicability, which we define as the ability to detect a wide variety of earthquakes without prior knowledge of the event waveform or source information. But STA/LTA fails to detect earthquakes, or may produce false detections, in more challenging situations such as low snr, waveforms with emergent arrivals, overlapping events, cultural noise, and sparse station spacing; thus, STA/LTA has low detection sensitivity as shown below. Therefore, earthquake catalogs are incomplete for lower-magnitude events. Read more here .","title":"Standard Earthquake Detection (STA/LTA)"},{"location":"fast_overview/#waveform-similarity","text":"Many algorithms have been developed to efficiently search for similar items in massive data sets; applications include identifying similar files in a large file system, finding near-duplicate Web pages, detecting plagiarism in documents, and recognizing similar audio clips for music identification, such as in the Shazam mobile app. We can meet our objective of a fast, efficient, automated blind detection of similar earthquake waveforms in huge volumes of continuous data by leveraging scalable algorithms that are widely used in the computer science community. Seismologists are just beginning to exploit data-intensive search technologies to analyze seismograms; one recent application is an earthquake search engine for fast focal mechanism identification that retrieves a best-fit synthetic seismogram from a large database, whereas another study developed a fast-approximation algorithm to find similar event waveforms within large catalogs. Rather than directly comparing waveforms, we first perform feature extraction to condense each waveform into a compact \u201cfingerprint\u201d that retains only its key discriminative features. A fingerprint serves as a proxy for a waveform; thus, two similar waveforms should have similar fingerprints, and two dissimilar waveforms should have dissimilar fingerprints. We assign the fingerprints (rather than waveforms) to LSH hash buckets. If you are interested in learning more about Locality Sensitive Hashing (LSH), check out \"Locality Sensitive Hashing (LSH) for Search with Shingling + MinHashing (Python)\" by James Briggs on YouTube. Our approach, an algorithm that we call Fingerprint And Similarity Thresholding (FAST) , builds on the Waveprint audio fingerprinting algorithm, which combines computer-vision techniques and large-scale data processing methods to match similar audio clips. We modified the Waveprint algorithm based on the properties and requirements of our specific application of detecting similar earthquakes from continuous seismic data. We chose Waveprint for its demonstrated capabilities in audio identification and its ease of mapping the technology to our application. First, an audio signal resembles a seismogram in several ways: they are both continuous time series waveform data, and the signals of interest are often nonimpulsive. Second, Waveprint computes fingerprints using short overlapping audio clips, as in autocorrelation. Third, Waveprint takes advantage of LSH to search through only a small subset of fingerprints. Waveprint also reports fast retrieval results with high accuracy, and its feature extraction steps are easily parallelizable. FAST scores high on three qualitative desirable metrics for earthquake detection methods (detection sensitivity, general applicability, and computational efficiency), whereas other earthquake detection algorithms (STA/LTA, template matching, and autocorrelation) do well on only two of the three. Waveform similarity allows detection of smaller earthquakes. A comprehensive, exhaustive search for earthquakes with similar waveforms.","title":"Waveform Similarity"},{"location":"fast_overview/#efficient-search","text":"FAST identifies candidate earthquake waveforms using a blind search for similar waveforms in single-channel continuous ground motion data. Rather than using a brute-force search in the time domain, as in the autocorrelation method (Brown et al., 2008), FAST searches for similar waveform fingerprints using an efficient indexing and search procedure. The FAST similarity search involves two steps: the first is indexing a set of database fingerprints, and the second is querying the index to identify similar waveform fingerprints. Because FAST assumes no prior information about waveform signatures, we set up the similarity search in a manner that will identify any repeating or similar signals among the full set of waveform fingerprints. Therefore, in FAST similarity search we store the full set of fingerprints in the search index and we also use the full set of fingerprints as queries against the index, in a true blind search. The index is designed such that for each query fingerprint, FAST can identify similar fingerprints without having to scan the entire index. Rather than an exhaustive search, FAST performs an approximate similarity search, guaranteed to identify similar waveforms with high probability, which enables improved scalability and reduced runtime. Efficient search for similar items in large databases","title":"Efficient Search"},{"location":"fast_overview/#what-can-and-cant-fast-do","text":"Typical use cases of FAST include weeks, months, or years of continuous seismic data at several stations, which FAST scans through to find small similar (or repeating) earthquakes. FAST will not detect an earthquake that occurs only once and is not similar enough to any other earthquakes in your continuous data set. Most similar earthquakes != largest earthquakes. Larger earthquakes often match a smaller earthquake on the coda, so they are detected with lower similarity (or not detected at all). FAST is intended to complement (not replace) existing energy-based detection methods like STA/LTA.","title":"What can and can't FAST do?"},{"location":"get_seismic_data/","text":"Getting Seismic Data \u00b6 Using Obspy, users can download seismic data with get_waveforms or mass downloader . Example using get_waveforms : from obspy import UTCDateTime from obspy import Stream from obspy import read from obspy.clients.fdsn import Client import os import json t = UTCDateTime(2021, 6, 5, 10, 55, 58) # largest event time start_time = UTCDateTime(\"2021-06-05 00:00:00\") end_time = UTCDateTime(\"2021-06-06 00:00:00\") # Earthquake longitude, latitude, depth lon = -115.635 lat = 33.140 depth = 5.8 chan_priority_list=[\"HHZ\", \"HHN\", \"HHE\", \"HH1\", \"HH2\", \"BHZ\", \"BHN\", \"BHE\", \"BH1\", \"BH2\", \"EHZ\", \"EHN\", \"EHE\", \"EH1\", \"EH2\", \"HNZ\", \"HNN\", \"HNE\", \"HN1\", \"HN2\"] # Clients to get waveforms client1 = Client(\"IRIS\") client2 = Client(\"SCEDC\") # Get stations from IRIS within 50km from the earthquake IRIS_inventory = client1.get_stations( starttime=start_time, endtime=end_time, longitude=lon, latitude=lat, maxradius=0.5) # Get stations from SCEDC within 50km from the earthquake SCEDC_inventory = client2.get_stations( starttime=start_time, endtime=end_time, longitude=lon, latitude=lat, maxradius=0.5) # Get dictionary containing the contents of the objects IRIS_contents = IRIS_inventory.get_contents() SCEDC_contents = SCEDC_inventory.get_contents() # File format start_time_file = (f\"{start_time.year}{str(start_time.month).zfill(2)}{str(start_time.day).zfill(2)}T{str(start_time.hour).zfill(2)}{str(start_time.minute).zfill(2)}{str(start_time.second).zfill(2)}Z\") end_time_file = (f\"{end_time.year}{str(end_time.month).zfill(2)}{str(end_time.day).zfill(2)}T{str(end_time.hour).zfill(2)}{str(end_time.minute).zfill(2)}{str(end_time.second).zfill(2)}Z\") # Get waveforms from IRIS os.mkdir(\"waveforms_IRIS\") st_list = [] for i in IRIS_contents[\"stations\"]: curr = i.split() network = curr[0].split('.')[0] station = curr[0].split('.')[1] try: wave_form = client1.get_waveforms(network, station, \"*\", \"*\", start_time, end_time) except: print(f\"No data available for {network}.{station}\") for s in wave_form: if s.stats.channel in chan_priority_list: s.write(f\"waveforms_IRIS/{s.stats.network}.{s.stats.station}.{s.stats.channel}__{start_time_file}__{end_time_file}.mseed\", format=\"MSEED\") if s.stats.station not in st_list: st_list.append(s.stats.station) # Get waveforms from SCEDC os.mkdir(\"waveforms_SCEDC\") st_list = [] for i in SCEDC_contents[\"stations\"]: curr = i.split() network = curr[0].split('.')[0] station = curr[0].split('.')[1] try: wave_form = client2.get_waveforms(network, station, \"*\", \"*\", start_time, end_time) except: print(f\"No data available for {network}.{station}\") for s in wave_form: if s.stats.channel in chan_priority_list: s.write(f\"waveforms_SCEDC/{s.stats.network}.{s.stats.station}.{s.stats.channel}__{start_time_file}__{end_time_file}.mseed\", format=\"MSEED\") if s.stats.station not in st_list: st_list.append(s.stats.station) Example using mass downloader: import os import obspy from obspy.clients.fdsn.mass_downloader import CircularDomain, \\ Restrictions, MassDownloader # Earthquake origin time origin_time = obspy.UTCDateTime(2021, 6, 5, 10, 55, 58) # Set up a circular domain with a maximum radius of 50km domain = CircularDomain(latitude=33.140, longitude=-115.635, minradius=0, maxradius=0.5) # Make directories to save miniseed waveform files and station information os.makedirs(\"waveforms_mdl\") os.makedirs(\"stations_mdl\") # Add restrictions to downloaded data such as start time, end time, and channel priorities restrictions = Restrictions( starttime = obspy.UTCDateTime(\"2021-06-05 00:00:00\"), endtime = obspy.UTCDateTime(\"2021-06-06 00:00:00\"), reject_channels_with_gaps=True, minimum_length=0, channel_priorities=[\"HH[ZNE12]\", \"BH[ZNE12]\", \"EH[ZNE12]\", \"HN[ZNE12]\"]) # Select Clients to get waveforms from mdl = MassDownloader(providers=[\"IRIS\", \"SCEDC\"]) mdl.download(domain, restrictions, mseed_storage=\"waveforms_mdl\", stationxml_storage=\"stations_mdl\") After saving waveforms to your directory, there may be multiple channels for one stations. In the image shown above, there are multiple channels for CI.BOM, CI.CLI2, and CI.COK2. You do not need all of the channels. Instead, refer to this priority list to know which channels to keep for running FAST: HH: High Broad Band; Sampling rate 100x per second BH: Broad Band; Sampling rate 40x per second EH: Extremely Short Period HN: Measures how much the ground movement is accelerating; not good for finding small earthquakes Read more here . If you have HH channels available, choose those. Otherwise, use BH. If you don't have BH, then use EH. Lastly, if only HN is available, then use HN.","title":"Getting Seismic Data"},{"location":"get_seismic_data/#getting-seismic-data","text":"Using Obspy, users can download seismic data with get_waveforms or mass downloader . Example using get_waveforms : from obspy import UTCDateTime from obspy import Stream from obspy import read from obspy.clients.fdsn import Client import os import json t = UTCDateTime(2021, 6, 5, 10, 55, 58) # largest event time start_time = UTCDateTime(\"2021-06-05 00:00:00\") end_time = UTCDateTime(\"2021-06-06 00:00:00\") # Earthquake longitude, latitude, depth lon = -115.635 lat = 33.140 depth = 5.8 chan_priority_list=[\"HHZ\", \"HHN\", \"HHE\", \"HH1\", \"HH2\", \"BHZ\", \"BHN\", \"BHE\", \"BH1\", \"BH2\", \"EHZ\", \"EHN\", \"EHE\", \"EH1\", \"EH2\", \"HNZ\", \"HNN\", \"HNE\", \"HN1\", \"HN2\"] # Clients to get waveforms client1 = Client(\"IRIS\") client2 = Client(\"SCEDC\") # Get stations from IRIS within 50km from the earthquake IRIS_inventory = client1.get_stations( starttime=start_time, endtime=end_time, longitude=lon, latitude=lat, maxradius=0.5) # Get stations from SCEDC within 50km from the earthquake SCEDC_inventory = client2.get_stations( starttime=start_time, endtime=end_time, longitude=lon, latitude=lat, maxradius=0.5) # Get dictionary containing the contents of the objects IRIS_contents = IRIS_inventory.get_contents() SCEDC_contents = SCEDC_inventory.get_contents() # File format start_time_file = (f\"{start_time.year}{str(start_time.month).zfill(2)}{str(start_time.day).zfill(2)}T{str(start_time.hour).zfill(2)}{str(start_time.minute).zfill(2)}{str(start_time.second).zfill(2)}Z\") end_time_file = (f\"{end_time.year}{str(end_time.month).zfill(2)}{str(end_time.day).zfill(2)}T{str(end_time.hour).zfill(2)}{str(end_time.minute).zfill(2)}{str(end_time.second).zfill(2)}Z\") # Get waveforms from IRIS os.mkdir(\"waveforms_IRIS\") st_list = [] for i in IRIS_contents[\"stations\"]: curr = i.split() network = curr[0].split('.')[0] station = curr[0].split('.')[1] try: wave_form = client1.get_waveforms(network, station, \"*\", \"*\", start_time, end_time) except: print(f\"No data available for {network}.{station}\") for s in wave_form: if s.stats.channel in chan_priority_list: s.write(f\"waveforms_IRIS/{s.stats.network}.{s.stats.station}.{s.stats.channel}__{start_time_file}__{end_time_file}.mseed\", format=\"MSEED\") if s.stats.station not in st_list: st_list.append(s.stats.station) # Get waveforms from SCEDC os.mkdir(\"waveforms_SCEDC\") st_list = [] for i in SCEDC_contents[\"stations\"]: curr = i.split() network = curr[0].split('.')[0] station = curr[0].split('.')[1] try: wave_form = client2.get_waveforms(network, station, \"*\", \"*\", start_time, end_time) except: print(f\"No data available for {network}.{station}\") for s in wave_form: if s.stats.channel in chan_priority_list: s.write(f\"waveforms_SCEDC/{s.stats.network}.{s.stats.station}.{s.stats.channel}__{start_time_file}__{end_time_file}.mseed\", format=\"MSEED\") if s.stats.station not in st_list: st_list.append(s.stats.station) Example using mass downloader: import os import obspy from obspy.clients.fdsn.mass_downloader import CircularDomain, \\ Restrictions, MassDownloader # Earthquake origin time origin_time = obspy.UTCDateTime(2021, 6, 5, 10, 55, 58) # Set up a circular domain with a maximum radius of 50km domain = CircularDomain(latitude=33.140, longitude=-115.635, minradius=0, maxradius=0.5) # Make directories to save miniseed waveform files and station information os.makedirs(\"waveforms_mdl\") os.makedirs(\"stations_mdl\") # Add restrictions to downloaded data such as start time, end time, and channel priorities restrictions = Restrictions( starttime = obspy.UTCDateTime(\"2021-06-05 00:00:00\"), endtime = obspy.UTCDateTime(\"2021-06-06 00:00:00\"), reject_channels_with_gaps=True, minimum_length=0, channel_priorities=[\"HH[ZNE12]\", \"BH[ZNE12]\", \"EH[ZNE12]\", \"HN[ZNE12]\"]) # Select Clients to get waveforms from mdl = MassDownloader(providers=[\"IRIS\", \"SCEDC\"]) mdl.download(domain, restrictions, mseed_storage=\"waveforms_mdl\", stationxml_storage=\"stations_mdl\") After saving waveforms to your directory, there may be multiple channels for one stations. In the image shown above, there are multiple channels for CI.BOM, CI.CLI2, and CI.COK2. You do not need all of the channels. Instead, refer to this priority list to know which channels to keep for running FAST: HH: High Broad Band; Sampling rate 100x per second BH: Broad Band; Sampling rate 40x per second EH: Extremely Short Period HN: Measures how much the ground movement is accelerating; not good for finding small earthquakes Read more here . If you have HH channels available, choose those. Otherwise, use BH. If you don't have BH, then use EH. Lastly, if only HN is available, then use HN.","title":"Getting Seismic Data"},{"location":"groningen_dataset/","text":"0.8 Groningen Data Set \u00b6 Location: Netherlands (gas production field) Duration: 4 months (119 days): 2018-01-01 to 2018-04-30 Network: 67 stations (Figure 12), 3 components each (HH1, HH2, HHZ) = 201 channels. (Station G294 not used for detection due to short duration) Sampling rate: 20 Hz (already downsampled) Provided by: Zack Spica (Stanford Geophysics) Figure 12: Groningen map provided by Zack Spica: 67 stations (black, red triangles) used for FAST detection, and locations of known catalog events (blue circles). 0.8.1 Preprocessing \u00b6 Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/continuous_data_times_Groningen.sh Figure 13: Duration of Groningen continuous data at 67 stations (change colors with each station), 3 components each. White sections indicate time gaps. The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_Groningen.py to plot the duration of available continuous data at each station and channel (Figure 13). Confirmed no zero-filled time-gap sections of continuous data in all 201 channels (need to modify paths in fill_time_gaps_with_uncorrelated_noise.py): ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Use original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/sample_spectrograms_Groningen.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/bandpass_filter_decimate_Groningen.sh Based on sample spectrograms, filter 3-10 Hz for all 201 channels. No need to decimate, as sampling rate is already low at 20 Hz. Filtered continuous data files start with Deci1.bp3to10.*, which are input to the fingerprint step. 0.8.2 Fingerprint \u00b6 Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/Groningen/run_fp_Groningen.sh Example script to generate fingerprints on one channel (HHZ) at one station (G014), called by the master script run_fp_Groningen.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/Groningen/fp_input_NL_G014_HHZ.json \"fingerprint\": { \"sampling_rate\": 20, \"min_freq\": 3.0, \"max_freq\": 10.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 0.05, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"G014\", \"channel\": \"HHZ\", \"start_time\": \"18-01-01T00:00:00.0\", \"end_time\": \"18-04-30T00:00:00.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/\", There are a total of 201 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S21. Table S21: Fingerprint input parameters for Groningen earthquake detection: 3-component at 67 stations (Figure 12, red, black triangles), after bandpass filter 3-10 Hz, and sampled at 20 Hz. The fingerprint sampling period is dt_fp = 1.5 seconds. Median/MAD output files: mad/mad*.txt Fingerprints (binary files): fingerprints/G014.HHZ.fp Timestamps at each fingerprint index (text files): timestamps/G014.HHZ.ts Finally, to create global indices for the Groningen data set, so that fingerprint indices from different channels (all 201) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/Groningen/global_indices_Groningen.json The common starting time is in global_idx_stats.txt : 2018-01-01T00:00:04.500000 UTC 0.8.3 Similarity Search \u00b6 Master script to run similarity search on each channel (out of 201 total): ~/FAST/simsearch/$ ../parameters/simsearch/Groningen/run_simsearch_Groningen.sh Table S22: Similarity search input parameters for Groningen earthquake detection: 201 channels at 67 stations (3 components each). Example script to run similarity search on one channel (HHZ) at one station (G014), called by the master script run_simsearch_Groningen.sh: ~/FAST/simsearch/$ ../parameters/simsearch/Groningen/filt_simsearch_input_Groningen.sh G014 HHZ NTBLS=100 NHASH=5 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 FREQ_NOISE=0.01 Similarity search is run with the occurrence filter (FREQ_NOISE=0.01) for all 201 channels. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. The same input parameters are used for similarity search on all 201 channels (Table S22). 0.8.4 Postprocessing \u00b6 First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (201 total): ~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/output_Groningen_pairs.sh For example, on one channel (HHZ) at one station (G014), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/ -p candidate_pairs_G014_HHZ -i /lfs/1/ceyoon/TimeSeries/Groningen/global_indices/G014_HHZ_idx_mapping.txt Output file for example (large size at channel level): /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/ fingerprints/candidate_pairs_G014_HHZ_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for all 67 stations: ~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/combine_Groningen_pairs.sh For example, on three channels (HH1, HH2, HHZ) at one station (G014), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/ $ mv candidate_pairs_G014_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components) (v=2 votes/component, Table S22). Note: this step will delete the candidate_ pairs_G014_HH _merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ -p candidate_pairs_G014 --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ candidate_pairs_G014_combined.txt Finally , detect similar fingerprints across the network of 67 stations, using the input parameters in Table S23: ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/Groningen/67sta_3stathresh_network_params.json \"network\": { \"max_fp\": 6798013, \"dt_fp\": 1.5, (seconds) \"dgapL\": 10, (15 s) \"dgapW\": 3, (4.5 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (12 s) \"ivals_thresh\": 6, \"nsta_thresh\": 3, \"input_offset\": 15 (22.5 s) }, Table S23: Network detection input parameters for Groningen at 67 stations. max_fp = 6798013 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.5 seconds is the fingerprint sampling period from Table S21. Network detection output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/Groningen/ network_detection/67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events) At this point, FAST earthquake detection processing is done. 0.8.5 Remove duplicates after network detection \u00b6 The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.) First , save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind). ~/FAST/utils/network/$ python arrange_network_detection_results.py Output: NetworkDetectionTimes_67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events) Second , remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity). ~/FAST/utils/network/$ ./remove_duplicates_after_network.sh Output: uniquestart_sorted_no_duplicates.txt (13,782 events) Third , remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum. ~/FAST/utils/network/$ python delete_overlap_network_detections.py Output: 67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (6277 events) Finally , sort remaining events in descending order of num_sta, then peaksum, for the final detection list. ~/FAST/utils/network/$ ./final_network_sort_nsta_peaksum.sh Output: sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (6277 events) 0.8.6 Visual inspection and final detections \u00b6 Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table 0.8.6). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_Groningen.py 0 6277 Output: .png image files in 67sta_3stathresh_NetworkWaveformPlots/ Table S24: Final thresholds for Groningen applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied. After visual inspection, 26 events are above thresholds in Table 0.8.6. EQ_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt : 23 events that look like earthquake waveforms FALSE_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt : 3 false detections above thresholds that do not look like earthquakes For the 23 earthquake events, output an event catalog: ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_Groningen_67sta_13stathresh.txt (23 events)","title":"0.8 Groningen Data Set"},{"location":"groningen_dataset/#08-groningen-data-set","text":"Location: Netherlands (gas production field) Duration: 4 months (119 days): 2018-01-01 to 2018-04-30 Network: 67 stations (Figure 12), 3 components each (HH1, HH2, HHZ) = 201 channels. (Station G294 not used for detection due to short duration) Sampling rate: 20 Hz (already downsampled) Provided by: Zack Spica (Stanford Geophysics) Figure 12: Groningen map provided by Zack Spica: 67 stations (black, red triangles) used for FAST detection, and locations of known catalog events (blue circles).","title":"0.8 Groningen Data Set"},{"location":"groningen_dataset/#081-preprocessing","text":"Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/continuous_data_times_Groningen.sh Figure 13: Duration of Groningen continuous data at 67 stations (change colors with each station), 3 components each. White sections indicate time gaps. The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_Groningen.py to plot the duration of available continuous data at each station and channel (Figure 13). Confirmed no zero-filled time-gap sections of continuous data in all 201 channels (need to modify paths in fill_time_gaps_with_uncorrelated_noise.py): ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Use original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/sample_spectrograms_Groningen.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/Groningen/bandpass_filter_decimate_Groningen.sh Based on sample spectrograms, filter 3-10 Hz for all 201 channels. No need to decimate, as sampling rate is already low at 20 Hz. Filtered continuous data files start with Deci1.bp3to10.*, which are input to the fingerprint step.","title":"0.8.1 Preprocessing"},{"location":"groningen_dataset/#082-fingerprint","text":"Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/Groningen/run_fp_Groningen.sh Example script to generate fingerprints on one channel (HHZ) at one station (G014), called by the master script run_fp_Groningen.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/Groningen/fp_input_NL_G014_HHZ.json \"fingerprint\": { \"sampling_rate\": 20, \"min_freq\": 3.0, \"max_freq\": 10.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 0.05, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"G014\", \"channel\": \"HHZ\", \"start_time\": \"18-01-01T00:00:00.0\", \"end_time\": \"18-04-30T00:00:00.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/\", There are a total of 201 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S21. Table S21: Fingerprint input parameters for Groningen earthquake detection: 3-component at 67 stations (Figure 12, red, black triangles), after bandpass filter 3-10 Hz, and sampled at 20 Hz. The fingerprint sampling period is dt_fp = 1.5 seconds. Median/MAD output files: mad/mad*.txt Fingerprints (binary files): fingerprints/G014.HHZ.fp Timestamps at each fingerprint index (text files): timestamps/G014.HHZ.ts Finally, to create global indices for the Groningen data set, so that fingerprint indices from different channels (all 201) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/Groningen/global_indices_Groningen.json The common starting time is in global_idx_stats.txt : 2018-01-01T00:00:04.500000 UTC","title":"0.8.2 Fingerprint"},{"location":"groningen_dataset/#083-similarity-search","text":"Master script to run similarity search on each channel (out of 201 total): ~/FAST/simsearch/$ ../parameters/simsearch/Groningen/run_simsearch_Groningen.sh Table S22: Similarity search input parameters for Groningen earthquake detection: 201 channels at 67 stations (3 components each). Example script to run similarity search on one channel (HHZ) at one station (G014), called by the master script run_simsearch_Groningen.sh: ~/FAST/simsearch/$ ../parameters/simsearch/Groningen/filt_simsearch_input_Groningen.sh G014 HHZ NTBLS=100 NHASH=5 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 FREQ_NOISE=0.01 Similarity search is run with the occurrence filter (FREQ_NOISE=0.01) for all 201 channels. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. The same input parameters are used for similarity search on all 201 channels (Table S22).","title":"0.8.3 Similarity Search"},{"location":"groningen_dataset/#084-postprocessing","text":"First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (201 total): ~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/output_Groningen_pairs.sh For example, on one channel (HHZ) at one station (G014), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/ -p candidate_pairs_G014_HHZ -i /lfs/1/ceyoon/TimeSeries/Groningen/global_indices/G014_HHZ_idx_mapping.txt Output file for example (large size at channel level): /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/ fingerprints/candidate_pairs_G014_HHZ_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for all 67 stations: ~/FAST/postprocessing/$ ../parameters/postprocess/Groningen/combine_Groningen_pairs.sh For example, on three channels (HH1, HH2, HHZ) at one station (G014), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/Groningen/data/waveformsG014/fingerprints/ $ mv candidate_pairs_G014_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components) (v=2 votes/component, Table S22). Note: this step will delete the candidate_ pairs_G014_HH _merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ -p candidate_pairs_G014 --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/Groningen/inputs_network/ candidate_pairs_G014_combined.txt Finally , detect similar fingerprints across the network of 67 stations, using the input parameters in Table S23: ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/Groningen/67sta_3stathresh_network_params.json \"network\": { \"max_fp\": 6798013, \"dt_fp\": 1.5, (seconds) \"dgapL\": 10, (15 s) \"dgapW\": 3, (4.5 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (12 s) \"ivals_thresh\": 6, \"nsta_thresh\": 3, \"input_offset\": 15 (22.5 s) }, Table S23: Network detection input parameters for Groningen at 67 stations. max_fp = 6798013 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.5 seconds is the fingerprint sampling period from Table S21. Network detection output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/Groningen/ network_detection/67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events) At this point, FAST earthquake detection processing is done.","title":"0.8.4 Postprocessing"},{"location":"groningen_dataset/#085-remove-duplicates-after-network-detection","text":"The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.) First , save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind). ~/FAST/utils/network/$ python arrange_network_detection_results.py Output: NetworkDetectionTimes_67sta_3stathresh_detlist_rank_by_peaksum.txt (118,728 events) Second , remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity). ~/FAST/utils/network/$ ./remove_duplicates_after_network.sh Output: uniquestart_sorted_no_duplicates.txt (13,782 events) Third , remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum. ~/FAST/utils/network/$ python delete_overlap_network_detections.py Output: 67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (6277 events) Finally , sort remaining events in descending order of num_sta, then peaksum, for the final detection list. ~/FAST/utils/network/$ ./final_network_sort_nsta_peaksum.sh Output: sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (6277 events)","title":"0.8.5 Remove duplicates after network detection"},{"location":"groningen_dataset/#086-visual-inspection-and-final-detections","text":"Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table 0.8.6). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_Groningen.py 0 6277 Output: .png image files in 67sta_3stathresh_NetworkWaveformPlots/ Table S24: Final thresholds for Groningen applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied. After visual inspection, 26 events are above thresholds in Table 0.8.6. EQ_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt : 23 events that look like earthquake waveforms FALSE_sort_nsta_peaksum_67sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt : 3 false detections above thresholds that do not look like earthquakes For the 23 earthquake events, output an event catalog: ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_Groningen_67sta_13stathresh.txt (23 events)","title":"0.8.6 Visual inspection and final detections"},{"location":"input_and_preprocess/","text":"Input and Preprocessing \u00b6 Input: Continuous Seismic Data \u00b6 SAC or MiniSEED formats Run FAST independently for each component at each station Filename should have station, component, date-time Warning Filename must end with \u201c.sac\u201d or \u201c.mseed\u201d \u2013 if not, rename it! FAST uses ObsPy functions to read in data Time gaps ok, but must not be filled with 0\u2019s 0\u2019s are similar to other 0\u2019s --> time gaps overwhelm your earthquake detections, and take forever to run Run scripts to fill 0\u2019s with random uncorrelated noise; outputs files starting with \u201cFilled*\u201d $ python fill_time_gaps_uncorrelated_noise.py calls detect_time_gaps.py Need to modify for your input data Example scripts in: parameters/preprocess_utils/ Preprocessing \u00b6 Bandpass Filter: important parameter FAST uses short sections of spectrogram to create fingerprints Nyquist upper limit = (Sampling rate)/2 Typically sampling rate is 100 Hz, but depends on data Frequencies outside passband are cut, thrown away Demean, detrend data before applying filter Decimate to lower sampling rate Depends on your selected filter band; usually to 50 Hz, 25 Hz, or 20 Hz Remove spikes and glitches (write your own script) Example Python scripts in parameters/preprocess_utils/ (uses ObsPy): bandpass_filter_decimate.py , mseed_bandpass_filter_decimate.py SaudiMonth_bandpass_filter_decimate.sh : calls Python script multiple times for different stations and components, different filter bands","title":"Input and Preprocessing"},{"location":"input_and_preprocess/#input-and-preprocessing","text":"","title":"Input and Preprocessing"},{"location":"input_and_preprocess/#input-continuous-seismic-data","text":"SAC or MiniSEED formats Run FAST independently for each component at each station Filename should have station, component, date-time Warning Filename must end with \u201c.sac\u201d or \u201c.mseed\u201d \u2013 if not, rename it! FAST uses ObsPy functions to read in data Time gaps ok, but must not be filled with 0\u2019s 0\u2019s are similar to other 0\u2019s --> time gaps overwhelm your earthquake detections, and take forever to run Run scripts to fill 0\u2019s with random uncorrelated noise; outputs files starting with \u201cFilled*\u201d $ python fill_time_gaps_uncorrelated_noise.py calls detect_time_gaps.py Need to modify for your input data Example scripts in: parameters/preprocess_utils/","title":"Input: Continuous Seismic Data"},{"location":"input_and_preprocess/#preprocessing","text":"Bandpass Filter: important parameter FAST uses short sections of spectrogram to create fingerprints Nyquist upper limit = (Sampling rate)/2 Typically sampling rate is 100 Hz, but depends on data Frequencies outside passband are cut, thrown away Demean, detrend data before applying filter Decimate to lower sampling rate Depends on your selected filter band; usually to 50 Hz, 25 Hz, or 20 Hz Remove spikes and glitches (write your own script) Example Python scripts in parameters/preprocess_utils/ (uses ObsPy): bandpass_filter_decimate.py , mseed_bandpass_filter_decimate.py SaudiMonth_bandpass_filter_decimate.sh : calls Python script multiple times for different stations and components, different filter bands","title":"Preprocessing"},{"location":"italy_day_yr_dataset/","text":"0.2 ItalyDayYR Data Set \u00b6 Info One day of continuous data, 2016-10-29 00:00:00 to 2016-10-29 23:59:59 UTC, at 22 stations in central Italy (Figure 2), used 22 channels (vertical component HHZ only on each channel) for detection, provided by Bill Ellsworth. This data records small earthquakes from a swarm in Central Italy during October 2016, that occurred between the Mw 6.1 earthquake on 2016-10-26 19:18:08 UTC and the Mw 6.6 Norcia earthquake on 2016-10-30 06:40:18 UTC. Figure 2: Map of 22 stations (black triangles) in central Italy used for FAST detection of small earthquakes on 2016-10-29, one day of continuous data. The INGV catalog (http://cnt.rm.ingv.it/search) had 482 earthquakes (circles colored by depth, sized by relative magnitudes 0.4 \u2264 M \u2264 4.1) inside the boundaries of this map on 2016-10-29. 0.2.1 Preprocessing \u00b6 Output sample spectrograms on each channel and station to determine bandpass filter range: ~/FAST/utils/preprocess/$ ../../parameters/preprocess/ItalyDayYR/sample_spectrograms_ItalyDayYR.sh Table S2: FAST input parameters for Italy earthquake detection: single-channel at 22 YR stations (Figure 2, black triangles), after bandpass filter 2-20 Hz, and decimate to 25 Hz. Total number of fingerprints: 71,989. Table S3: Network detection input parameters for Italy earthquakes at 22 YR stations (HHZ channel only), after getting similar pairs of fingerprints from FAST for each station. Figure 3: Distribution of FAST detections in central Italy continuous data on 2016-10-29. FAST detected a total of 1,485 earthquakes during this day.","title":"0.2 ItalyDayYR Data Set"},{"location":"italy_day_yr_dataset/#02-italydayyr-data-set","text":"Info One day of continuous data, 2016-10-29 00:00:00 to 2016-10-29 23:59:59 UTC, at 22 stations in central Italy (Figure 2), used 22 channels (vertical component HHZ only on each channel) for detection, provided by Bill Ellsworth. This data records small earthquakes from a swarm in Central Italy during October 2016, that occurred between the Mw 6.1 earthquake on 2016-10-26 19:18:08 UTC and the Mw 6.6 Norcia earthquake on 2016-10-30 06:40:18 UTC. Figure 2: Map of 22 stations (black triangles) in central Italy used for FAST detection of small earthquakes on 2016-10-29, one day of continuous data. The INGV catalog (http://cnt.rm.ingv.it/search) had 482 earthquakes (circles colored by depth, sized by relative magnitudes 0.4 \u2264 M \u2264 4.1) inside the boundaries of this map on 2016-10-29.","title":"0.2 ItalyDayYR Data Set"},{"location":"italy_day_yr_dataset/#021-preprocessing","text":"Output sample spectrograms on each channel and station to determine bandpass filter range: ~/FAST/utils/preprocess/$ ../../parameters/preprocess/ItalyDayYR/sample_spectrograms_ItalyDayYR.sh Table S2: FAST input parameters for Italy earthquake detection: single-channel at 22 YR stations (Figure 2, black triangles), after bandpass filter 2-20 Hz, and decimate to 25 Hz. Total number of fingerprints: 71,989. Table S3: Network detection input parameters for Italy earthquakes at 22 YR stations (HHZ channel only), after getting similar pairs of fingerprints from FAST for each station. Figure 3: Distribution of FAST detections in central Italy continuous data on 2016-10-29. FAST detected a total of 1,485 earthquakes during this day.","title":"0.2.1 Preprocessing"},{"location":"network_detection/","text":"Network Detection \u00b6 Association: Detect Earthquakes Over a Seismic Network \u00b6 Earthquake pair at different stations: consistent inter-event time dt Reduce false detections Network (Multi-Station) Detection with FAST \u00b6 Network (Multi-Station) Illustration \u00b6 Event-Pair Extraction Parameters \u00b6 \"network\": { \"dgapL\": 3, # Longest allowed along-diagonal time gap (samples) \u201ddgapW\": 3, # Longest allowed cross-diagonal time gap (samples) \u201dnum_pass\": 2, # Adjacent diagonal merge iterations \u201divals_thresh\": 6, # Minimum similarity (number of votes) \u201cmin_dets\": 4, # Minimum number of fingerprint-pairs in a cluster \u201dmin_sum_multiplier\": 1, # Minimum total similarity multiplier for a cluster \"max_width\": 8, # Maximum bounding box width (samples) } Guidelines for setting parameters: ivals_thresh = nvote, unless initial threshold is too low . Better approach is increasing min_sum_multiplier (i.e. min_sum_multiplier = updated_nvote / nvote ) which effectively increases fingerprint-pair threshold to updated_nvote with better thresholding that takes advantage of structure of event-pairs min_dets = 4-6 dgapL: time interval equivalent to largest expected P-S gap (e.g. 10-20 seconds) dgapW: should be small, equivalent to a few seconds (3-4 seconds) \"network\": { \u201cmax_fp\": 74797, # Max fingerprint index over all stations \u201ddt_fp\": 1.0, # Fingerprint lag (s) \"dgapL\": 3, # Longest allowed along-diagonal time gap (samples) \u201ddgapW\": 3, # Longest allowed cross-diagonal time gap (samples) \u201dnum_pass\": 2, # Adjacent diagonal merge iterations }, Event-Pair Extraction Parameters (1 Station) dgapL , dgapW : determine whether to keep as 1 cluster or split into 2 clusters Multiply dgapL , dgapW by dt_fp to get values in seconds num_pass =2 is good default (3 is also ok, but takes longer) Event-Pair Extraction Samples \u00b6 \"network\": { \u201divals_thresh\": 6, # Minimum similarity (number of votes) \u201cmin_dets\": 4, # Minimum number of fingerprint-pairs in a cluster \u201dmin_sum_multiplier\": 1, # Minimum total similarity multiplier for a cluster \"max_width\": 8, # Maximum bounding box width (samples) }, Event-Pair Pruning Parameters (1 Station) Set higher thresholds on similarity in order to identify an event-pair cluster Minimum total similarity threshold: ivals_thresh * min_dets * min_sum_multiplier max_width : 8 is a good default value, probably don\u2019t need to change multiply by dt_fp to get value in seconds Network Detection Performance Parameter Guidance \u00b6 \"performance\": { \"partition_size\": 2147483648, \"num_cores\": 4 } partition_size : Maximum size of each partition (bytes), if entire list of similarity search output pairs does not fit into memory num_cores : Number of threads for parallel processing (event-pair extraction only) Pseudo-Association Parameters (Multiple stations) \u00b6 \u201dnetwork\": { \u201dnsta_thresh\": 2, # Minimum number of stations for detection \u201cinput_offset\": 3, # Arrival time constraint: maximum time gap (samples) }, Set nsta_thresh low to begin, can increase threshold later n sta_thresh =1: single station detection not yet thoroughly tested Set input_offset to be largest expected time gap between S wave at 1 station and P wave at another station Multiply by dt_fp to get value in seconds input_offset : arrival time constraint: maximum time gap (samples) input_offset is the longest time period that can elapse with no active detections (for a given \u2013 event-pair): after a gap of more than input_offset samples within a network event-pair, pseudo- association will automatically create a new network event-pair. A reasonable upper-bound on input_offset is the largest expected S-P time for any station in the network, or the largest difference in P arrival times between any pair of stations in the network, whichever is larger. Usually, input_offset can be shorter than this upper-bound, but the value should not be smaller than the time gap parameter used in event-pair extraction: input_offset > dgapL . Note that because all event-pairs are only grouped together into network event-pairs only if they have nearly identical inter-event times, there is limited risk of falsely associating event-pairs or of being unable to resolve overlapping events (with detections separated by a time interval of less than input_offset ) due to selecting the value of input_offset that is somewhat longer than necessary. However, input_offset should not be set to a value that is unnecessarily large (e.g. 60+ seconds) because this does increase the chance of spurious associations of unrelated event-pairs observed at different stations in the network. For most data sets, the value of network time gap parameter should lie within the range, input_offset = 15-40 seconds Event Resolution Implementation \u00b6 Event resolution is applied separately to each station using detections from each station that meet network detection threshold (e.g. observed at minimum number of station) In this implementation, event resolution method is relatively simple to minimize memory usage for large data sets. Specifically event resolution does not keep information about structure of pairwise detections, only whether there was a detection (in any event-pair) for each time stamp. Thus in this version of the code, events that are overlapping in time at a single station with be resolved to a single event. In order to tease out two separate events that overlap in time at a single station, the user will need to go back to the network detection output from pairwise pseudo-association. Two events overlapping in time at a single station will belong to different network event-pairs (if there are two detections at the same station in the same network event-pair, then these are not overlapping events, but different phases of the same event). Event Resolution Implementation Algorithm: \u00b6 Sample Parameter Settings: 2014 M8.2 Iquique Foreshock Sequence \u00b6 (from Bergen & Beroza, 2018)","title":"Network Detection"},{"location":"network_detection/#network-detection","text":"","title":"Network Detection"},{"location":"network_detection/#association-detect-earthquakes-over-a-seismic-network","text":"Earthquake pair at different stations: consistent inter-event time dt Reduce false detections","title":"Association: Detect Earthquakes Over a Seismic Network"},{"location":"network_detection/#network-multi-station-detection-with-fast","text":"","title":"Network (Multi-Station) Detection with FAST"},{"location":"network_detection/#network-multi-station-illustration","text":"","title":"Network (Multi-Station) Illustration"},{"location":"network_detection/#event-pair-extraction-parameters","text":"\"network\": { \"dgapL\": 3, # Longest allowed along-diagonal time gap (samples) \u201ddgapW\": 3, # Longest allowed cross-diagonal time gap (samples) \u201dnum_pass\": 2, # Adjacent diagonal merge iterations \u201divals_thresh\": 6, # Minimum similarity (number of votes) \u201cmin_dets\": 4, # Minimum number of fingerprint-pairs in a cluster \u201dmin_sum_multiplier\": 1, # Minimum total similarity multiplier for a cluster \"max_width\": 8, # Maximum bounding box width (samples) } Guidelines for setting parameters: ivals_thresh = nvote, unless initial threshold is too low . Better approach is increasing min_sum_multiplier (i.e. min_sum_multiplier = updated_nvote / nvote ) which effectively increases fingerprint-pair threshold to updated_nvote with better thresholding that takes advantage of structure of event-pairs min_dets = 4-6 dgapL: time interval equivalent to largest expected P-S gap (e.g. 10-20 seconds) dgapW: should be small, equivalent to a few seconds (3-4 seconds) \"network\": { \u201cmax_fp\": 74797, # Max fingerprint index over all stations \u201ddt_fp\": 1.0, # Fingerprint lag (s) \"dgapL\": 3, # Longest allowed along-diagonal time gap (samples) \u201ddgapW\": 3, # Longest allowed cross-diagonal time gap (samples) \u201dnum_pass\": 2, # Adjacent diagonal merge iterations }, Event-Pair Extraction Parameters (1 Station) dgapL , dgapW : determine whether to keep as 1 cluster or split into 2 clusters Multiply dgapL , dgapW by dt_fp to get values in seconds num_pass =2 is good default (3 is also ok, but takes longer)","title":"Event-Pair Extraction Parameters"},{"location":"network_detection/#event-pair-extraction-samples","text":"\"network\": { \u201divals_thresh\": 6, # Minimum similarity (number of votes) \u201cmin_dets\": 4, # Minimum number of fingerprint-pairs in a cluster \u201dmin_sum_multiplier\": 1, # Minimum total similarity multiplier for a cluster \"max_width\": 8, # Maximum bounding box width (samples) }, Event-Pair Pruning Parameters (1 Station) Set higher thresholds on similarity in order to identify an event-pair cluster Minimum total similarity threshold: ivals_thresh * min_dets * min_sum_multiplier max_width : 8 is a good default value, probably don\u2019t need to change multiply by dt_fp to get value in seconds","title":"Event-Pair Extraction Samples"},{"location":"network_detection/#network-detection-performance-parameter-guidance","text":"\"performance\": { \"partition_size\": 2147483648, \"num_cores\": 4 } partition_size : Maximum size of each partition (bytes), if entire list of similarity search output pairs does not fit into memory num_cores : Number of threads for parallel processing (event-pair extraction only)","title":"Network Detection Performance Parameter Guidance"},{"location":"network_detection/#pseudo-association-parameters-multiple-stations","text":"\u201dnetwork\": { \u201dnsta_thresh\": 2, # Minimum number of stations for detection \u201cinput_offset\": 3, # Arrival time constraint: maximum time gap (samples) }, Set nsta_thresh low to begin, can increase threshold later n sta_thresh =1: single station detection not yet thoroughly tested Set input_offset to be largest expected time gap between S wave at 1 station and P wave at another station Multiply by dt_fp to get value in seconds input_offset : arrival time constraint: maximum time gap (samples) input_offset is the longest time period that can elapse with no active detections (for a given \u2013 event-pair): after a gap of more than input_offset samples within a network event-pair, pseudo- association will automatically create a new network event-pair. A reasonable upper-bound on input_offset is the largest expected S-P time for any station in the network, or the largest difference in P arrival times between any pair of stations in the network, whichever is larger. Usually, input_offset can be shorter than this upper-bound, but the value should not be smaller than the time gap parameter used in event-pair extraction: input_offset > dgapL . Note that because all event-pairs are only grouped together into network event-pairs only if they have nearly identical inter-event times, there is limited risk of falsely associating event-pairs or of being unable to resolve overlapping events (with detections separated by a time interval of less than input_offset ) due to selecting the value of input_offset that is somewhat longer than necessary. However, input_offset should not be set to a value that is unnecessarily large (e.g. 60+ seconds) because this does increase the chance of spurious associations of unrelated event-pairs observed at different stations in the network. For most data sets, the value of network time gap parameter should lie within the range, input_offset = 15-40 seconds","title":"Pseudo-Association Parameters (Multiple stations)"},{"location":"network_detection/#event-resolution-implementation","text":"Event resolution is applied separately to each station using detections from each station that meet network detection threshold (e.g. observed at minimum number of station) In this implementation, event resolution method is relatively simple to minimize memory usage for large data sets. Specifically event resolution does not keep information about structure of pairwise detections, only whether there was a detection (in any event-pair) for each time stamp. Thus in this version of the code, events that are overlapping in time at a single station with be resolved to a single event. In order to tease out two separate events that overlap in time at a single station, the user will need to go back to the network detection output from pairwise pseudo-association. Two events overlapping in time at a single station will belong to different network event-pairs (if there are two detections at the same station in the same network event-pair, then these are not overlapping events, but different phases of the same event).","title":"Event Resolution Implementation"},{"location":"network_detection/#event-resolution-implementation-algorithm","text":"","title":"Event Resolution Implementation Algorithm:"},{"location":"network_detection/#sample-parameter-settings-2014-m82-iquique-foreshock-sequence","text":"(from Bergen & Beroza, 2018)","title":"Sample Parameter Settings: 2014 M8.2 Iquique Foreshock Sequence"},{"location":"newzealand_dataset/","text":"0.10 New Zealand, Year 2010 \u00b6 Info The objective of this study is to detect small earthquakes in New Zealand to test earthquake triggering hypothesis. Detection results, with input parameters, are described in Rong et al. [2018]. 1 year continuous data (2010), 5 seismic stations LTZ, MQZ, KHZ, THZ, OXZ (Figure 16, black triangles), vertical components only, sampled at 100 Hz. Detections were compared against the GeoNet catalog, and visually inspected. FAST detected 11419 events: 4916 catalog events (Figure 16, red circles), 355 teleseismic events, 6123 new local earthquakes and 25 false positives (noise waveforms). Figure 16: New Zealand map: 5 stations (black triangles) used for FAST detection (except GVZ which was not used), and locations of GeoNet catalog events (circles). 4916 catalog events were detected by FAST (red circles). Catalog events missed by FAST are displayed as green circles.","title":"0.10 New Zealand, Year 2010"},{"location":"newzealand_dataset/#010-new-zealand-year-2010","text":"Info The objective of this study is to detect small earthquakes in New Zealand to test earthquake triggering hypothesis. Detection results, with input parameters, are described in Rong et al. [2018]. 1 year continuous data (2010), 5 seismic stations LTZ, MQZ, KHZ, THZ, OXZ (Figure 16, black triangles), vertical components only, sampled at 100 Hz. Detections were compared against the GeoNet catalog, and visually inspected. FAST detected 11419 events: 4916 catalog events (Figure 16, red circles), 355 teleseismic events, 6123 new local earthquakes and 25 false positives (noise waveforms). Figure 16: New Zealand map: 5 stations (black triangles) used for FAST detection (except GVZ which was not used), and locations of GeoNet catalog events (circles). 4916 catalog events were detected by FAST (red circles). Catalog events missed by FAST are displayed as green circles.","title":"0.10 New Zealand, Year 2010"},{"location":"ometepec_dataset/","text":"0.6 Ometepec, Mexico, January - April 2012 \u00b6 Figure 9: Map of 1 station in southern Mexico (black triangle) used for FAST detection of small earthquakes from 2012-01-01 to 2012-04-21. The SSN catalog (http://www2.ssn.unam.mx:8080/catalogo/) had 558 earthquakes (circles colored by depth, sized by relative magnitudes 2.8 \u2264 M \u2264 7.5) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.5 Ometepec earthquake on 2012-03-20. Info The objective of this study is to identify repeating earthquake sequences as tools to measure deep aseismic slip rates [Dominguez et al., 2016], and characterize the unusually active aftershock sequence of the Mw 7.5 Omepetec, Mexico earthquake on 2012-03-20 [UNAM, 2013] (Figure 9). 112 days of continuous data (2012-01-01 to 2012-04-21) at 1 station, 3 components, provided by Luis Dominguez of Universidad Nacional Autonoma de Mexico (UNAM)-Morelia. For all 3 channels, I applied a 3-20 Hz bandpass filter, and kept the original sampling rate of 100 Hz. FAST detected a total of 31,970 earthquakes during these 4 months. 30,923 were earthquakes (Figure 10), and 1,047 were noise, as determined by visual inspection. ***NOTE: postprocessing and elimination of duplicate detection pairs was done with the old MATLAB code from [Yoon et al., 2015] and [Yoon et al., 2017]. Single-station event-pair extraction with network FAST was not yet available. These were the events I sent to Luis, who performed single-station location using P-wave polarization analysis (Figure 10). Table S17: FAST input parameters for Ometepec, Mexico earthquake detection, applied to each component at station IG.PNIG. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 4,795,140. Figure 10: Ometepec, Mexico earthquake detections from 2012-01-01 to 2012-04-21. The blue dots indicate the total 3-component FAST similarity (left y-axis) of the 30,923 FAST detections as a function of time. The red dots indicate the magnitudes (right y-axis) of the 558 catalog events as a function of time. Following the Mw 7.5 earthquake on 2012-03-20, aftershocks are abundant.","title":"0.6 Ometepec, Mexico, January - April 2012"},{"location":"ometepec_dataset/#06-ometepec-mexico-january-april-2012","text":"Figure 9: Map of 1 station in southern Mexico (black triangle) used for FAST detection of small earthquakes from 2012-01-01 to 2012-04-21. The SSN catalog (http://www2.ssn.unam.mx:8080/catalogo/) had 558 earthquakes (circles colored by depth, sized by relative magnitudes 2.8 \u2264 M \u2264 7.5) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.5 Ometepec earthquake on 2012-03-20. Info The objective of this study is to identify repeating earthquake sequences as tools to measure deep aseismic slip rates [Dominguez et al., 2016], and characterize the unusually active aftershock sequence of the Mw 7.5 Omepetec, Mexico earthquake on 2012-03-20 [UNAM, 2013] (Figure 9). 112 days of continuous data (2012-01-01 to 2012-04-21) at 1 station, 3 components, provided by Luis Dominguez of Universidad Nacional Autonoma de Mexico (UNAM)-Morelia. For all 3 channels, I applied a 3-20 Hz bandpass filter, and kept the original sampling rate of 100 Hz. FAST detected a total of 31,970 earthquakes during these 4 months. 30,923 were earthquakes (Figure 10), and 1,047 were noise, as determined by visual inspection. ***NOTE: postprocessing and elimination of duplicate detection pairs was done with the old MATLAB code from [Yoon et al., 2015] and [Yoon et al., 2017]. Single-station event-pair extraction with network FAST was not yet available. These were the events I sent to Luis, who performed single-station location using P-wave polarization analysis (Figure 10). Table S17: FAST input parameters for Ometepec, Mexico earthquake detection, applied to each component at station IG.PNIG. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 4,795,140. Figure 10: Ometepec, Mexico earthquake detections from 2012-01-01 to 2012-04-21. The blue dots indicate the total 3-component FAST similarity (left y-axis) of the 30,923 FAST detections as a function of time. The red dots indicate the magnitudes (right y-axis) of the 558 catalog events as a function of time. Following the Mw 7.5 earthquake on 2012-03-20, aftershocks are abundant.","title":"0.6 Ometepec, Mexico, January - April 2012"},{"location":"params_section/","text":"How to Set Parameters \u00b6","title":"How to Set Parameters"},{"location":"params_section/#how-to-set-parameters","text":"","title":"How to Set Parameters"},{"location":"phase_picking/","text":"Phase Picking \u00b6 The FAST output is interfaced with SeisBench to pick the arrival time of phases automatically with machine learning models. SeisBench is an open-source python toolbox for machine learning in seismology. Learn more about SeisBench here . Cut SAC Files \u00b6 In cut_event_files.py , change the station list on line 14 to list the stations in your dataset and the name of the final detection list on line 16. Example in cut_event_files : 14 15 16 17 stations = [ 'CDY' , 'CPM' , 'GTM' , 'HEC' , 'RMM' , 'RMR' , 'TPC' ] # Change station list in_mseed_dir = '../../data/' in_FINAL_Detection_List = 'network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt' # Change final detection list out_dir = 'event_ids' Your continuous seismic data should be found in /FAST/data/waveforms*/Deci5.Pick.* Pick Phases Over All Input \u00b6 Note If stations in your dataset do not have 3 channels, you will need to alter run_seisbench.py to make .sac file copies for stations without 3 channels. In the Hector Mine dataset, only the HEC station has 3 channels. On line 20 of run_seisbench.py , the stations that only have one component are in a list, which is iterated through to make channel copies for phase picking. 20 stations = [ 'CDY' , 'CPM' , 'GTM' , 'RMM' , 'RMR' , 'TPC' ] # List of stations that do not have 3 components To make sure run_seisbench.py runs correctly on your dataset, edit the following code in the script to account for missing station channels: 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 if stream [ i ] . stats . station in stations : st_temp = Stream () tr_temp_e = stream [ i ] . copy () tr_temp_n = stream [ i ] . copy () tr_temp_z = stream [ i ] . copy () tr_temp_e . stats . channel = 'EHE' st_temp . append ( tr_temp_e ) tr_temp_n . stats . channel = 'EHN' st_temp . append ( tr_temp_n ) tr_temp_z . stats . channel = 'EHZ' st_temp . append ( tr_temp_z ) st += st_temp else : st += stream [ i ] Run the SeisBench script: ~/FAST/utils/events$ cd .. ~/FAST/utils$ cd picking ~/FAST/utils/picking$ python run_seisbench.py The plotted annotations with each station's waveform and EQTransformer's picks and detections for every event is found in: ~/quake_tutorial/data/seisbench_picks Example annotated plot from one event in the Hector Mine dataset: The phase pick information found from SeisBench is found in: ~/quake_tutorial/utils/picking/event_picks.json/ Example output: \"peak_time\": Arrival time of pick \"peak_value\": Probability of pick","title":"Phase Picking"},{"location":"phase_picking/#phase-picking","text":"The FAST output is interfaced with SeisBench to pick the arrival time of phases automatically with machine learning models. SeisBench is an open-source python toolbox for machine learning in seismology. Learn more about SeisBench here .","title":"Phase Picking"},{"location":"phase_picking/#cut-sac-files","text":"In cut_event_files.py , change the station list on line 14 to list the stations in your dataset and the name of the final detection list on line 16. Example in cut_event_files : 14 15 16 17 stations = [ 'CDY' , 'CPM' , 'GTM' , 'HEC' , 'RMM' , 'RMR' , 'TPC' ] # Change station list in_mseed_dir = '../../data/' in_FINAL_Detection_List = 'network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt' # Change final detection list out_dir = 'event_ids' Your continuous seismic data should be found in /FAST/data/waveforms*/Deci5.Pick.*","title":"Cut SAC Files"},{"location":"phase_picking/#pick-phases-over-all-input","text":"Note If stations in your dataset do not have 3 channels, you will need to alter run_seisbench.py to make .sac file copies for stations without 3 channels. In the Hector Mine dataset, only the HEC station has 3 channels. On line 20 of run_seisbench.py , the stations that only have one component are in a list, which is iterated through to make channel copies for phase picking. 20 stations = [ 'CDY' , 'CPM' , 'GTM' , 'RMM' , 'RMR' , 'TPC' ] # List of stations that do not have 3 components To make sure run_seisbench.py runs correctly on your dataset, edit the following code in the script to account for missing station channels: 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 if stream [ i ] . stats . station in stations : st_temp = Stream () tr_temp_e = stream [ i ] . copy () tr_temp_n = stream [ i ] . copy () tr_temp_z = stream [ i ] . copy () tr_temp_e . stats . channel = 'EHE' st_temp . append ( tr_temp_e ) tr_temp_n . stats . channel = 'EHN' st_temp . append ( tr_temp_n ) tr_temp_z . stats . channel = 'EHZ' st_temp . append ( tr_temp_z ) st += st_temp else : st += stream [ i ] Run the SeisBench script: ~/FAST/utils/events$ cd .. ~/FAST/utils$ cd picking ~/FAST/utils/picking$ python run_seisbench.py The plotted annotations with each station's waveform and EQTransformer's picks and detections for every event is found in: ~/quake_tutorial/data/seisbench_picks Example annotated plot from one event in the Hector Mine dataset: The phase pick information found from SeisBench is found in: ~/quake_tutorial/utils/picking/event_picks.json/ Example output: \"peak_time\": Arrival time of pick \"peak_value\": Probability of pick","title":"Pick Phases Over All Input"},{"location":"references/","text":"References \u00b6 (FAST Overview) C. Yoon, O. O\u2019Reilly, K. Bergen and G. C. Beroza (2015) Earthquake detection through computationally efficient similarity search , Sci. Adv. 1, e1501057. (Fingerprint) K. Bergen, C. Yoon and G. C. Beroza (2016) Scalable Similarity Search in Seismology: A New Approach to Large-Scale Earthquake Detection , 9th International Conference on Similarity Search and Applications, Tokyo, Japan, 1-8. (Network Detection) K. Bergen and G.C. Beroza (2018) Detecting Earthquakes over a Seismic Network using Single-Station Similarity Measures , Geophys. J. Int., doi:10.1093/gji/ggy100 (Application of FAST) C. Yoon, Y. Huang, W. L. Ellsworth and G. C. Beroza (2017) Seismicity During the Initial Stages of the Guy\u2010Greenbrier, Arkansas, Earthquake Sequence , J. Geophys. Res., doi:10.1002/2017JB014946 (Implementation and Performance) K. Rong, C. Yoon, K. Bergen, H. Elezabi, P. Bailis, P. Levis and G. C. Beroza (2018) Locality-Sensitive Hashing for Earthquake Detection: A Case Study Scaling Data-Driven Science , arXiv:1803.09835.","title":"References"},{"location":"references/#references","text":"(FAST Overview) C. Yoon, O. O\u2019Reilly, K. Bergen and G. C. Beroza (2015) Earthquake detection through computationally efficient similarity search , Sci. Adv. 1, e1501057. (Fingerprint) K. Bergen, C. Yoon and G. C. Beroza (2016) Scalable Similarity Search in Seismology: A New Approach to Large-Scale Earthquake Detection , 9th International Conference on Similarity Search and Applications, Tokyo, Japan, 1-8. (Network Detection) K. Bergen and G.C. Beroza (2018) Detecting Earthquakes over a Seismic Network using Single-Station Similarity Measures , Geophys. J. Int., doi:10.1093/gji/ggy100 (Application of FAST) C. Yoon, Y. Huang, W. L. Ellsworth and G. C. Beroza (2017) Seismicity During the Initial Stages of the Guy\u2010Greenbrier, Arkansas, Earthquake Sequence , J. Geophys. Res., doi:10.1002/2017JB014946 (Implementation and Performance) K. Rong, C. Yoon, K. Bergen, H. Elezabi, P. Bailis, P. Levis and G. C. Beroza (2018) Locality-Sensitive Hashing for Earthquake Detection: A Case Study Scaling Data-Driven Science , arXiv:1803.09835.","title":"References"},{"location":"saudi_dataset/","text":"0.4 Saudi Arabia, May 2014 \u00b6 Figure 5: Map of 19 stations (white triangles) in Saudi Arabia used for FAST detection from 2014-05-01 to 2014-06-01. Catalog earthquakes are colored by depth; mantle earthquakes are circled. This figure was created by Alex Blanchette. Info Seismic network from Saudi Arabia to study dike swarms in volcanic area, and deep mantle earthquakes. 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations (Figure 5), 55 channels (3 components per station, except LNY11 where only HHN was used), provided by Alex Blanchette of Stanford Geophysics. Table S7: Preprocessing parameters for Saudi Arabia May 2014 earthquake detection, for each station (same filter applied to all components), 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations, decimate to 25 Hz. Also, all time gaps with 0\u2019s were filled with uncorrelated random noise. For station LNY11, only HHN component was used in similarity search, as the HHE and HHZ components had too much correlated noise. Table S8: FAST input parameters for Saudi Arabia May 2014 earthquake detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989. Table S9: Network detection input parameters for Saudi Arabia May 2014 earthquake detection at 19 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S10: Final thresholds for Saudi Arabia May 2014 earthquake detection, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta , a different threshold for peaksum can be applied. Figure 6: Saudi Arabia earthquake detections from 2014-05-01 to 2014-06-01. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S10). FAST detected a total of 1,837 earthquakes during this month.","title":"0.4 Saudi Arabia, May 2014"},{"location":"saudi_dataset/#04-saudi-arabia-may-2014","text":"Figure 5: Map of 19 stations (white triangles) in Saudi Arabia used for FAST detection from 2014-05-01 to 2014-06-01. Catalog earthquakes are colored by depth; mantle earthquakes are circled. This figure was created by Alex Blanchette. Info Seismic network from Saudi Arabia to study dike swarms in volcanic area, and deep mantle earthquakes. 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations (Figure 5), 55 channels (3 components per station, except LNY11 where only HHN was used), provided by Alex Blanchette of Stanford Geophysics. Table S7: Preprocessing parameters for Saudi Arabia May 2014 earthquake detection, for each station (same filter applied to all components), 1 month continuous data (2014-05-01 to 2014-06-01), at 19 stations, decimate to 25 Hz. Also, all time gaps with 0\u2019s were filled with uncorrelated random noise. For station LNY11, only HHN component was used in similarity search, as the HHE and HHZ components had too much correlated noise. Table S8: FAST input parameters for Saudi Arabia May 2014 earthquake detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989. Table S9: Network detection input parameters for Saudi Arabia May 2014 earthquake detection at 19 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S10: Final thresholds for Saudi Arabia May 2014 earthquake detection, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta , a different threshold for peaksum can be applied. Figure 6: Saudi Arabia earthquake detections from 2014-05-01 to 2014-06-01. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S10). FAST detected a total of 1,837 earthquakes during this month.","title":"0.4 Saudi Arabia, May 2014"},{"location":"saudifull_dataset/","text":"0.5 SaudiFull Data Set: Saudi Arabia, January - May 2017 \u00b6 Location: Saudi Arabia, January - May 2017 (volcanic area with dikes) Duration: up to 5 months (151 days): 2017-01-01 to 2017-05-30 Network: 36 stations, 3 components each (HHE, HHN, HHZ) = 106 channels. (Station SA.UMJ02: only HHE channel) Sampling rate: 100 Hz Provided by: Mohammad Youssof (KAUST) 0.5.1 Preprocessing \u00b6 Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/continuous_data_times_SaudiFull.sh The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_SaudiFull.py to plot the duration of available continuous data at each station and channel (Figure 7). Figure 7: Duration of SaudiFull continuous data at 36 stations (change colors with each station), 3 components each (except SA.UMJ02 which has only HHE). White sections indicate time gaps. Detected zero-filled time-gap sections of continuous data in all 106 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py), and filled them with random uncorrelated noise: ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Only stations SA.UMJ03, SA.UMJ05, SA.UMJ08 had zero-filled time-gap sections, which were filled with random noise and saved as files starting with the Filled.* string. The majority of continuous data files had no zero-filled time gaps, so we used original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/sample_spectrograms_SaudiFull.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/bandpass_filter_decimate_SaudiFull.sh Based on sample spectrograms, apply a station-specific bandpass filter (Table S11). Decimate by a factor of 2 to a sampling rate of 50 Hz. Filtered continuous data files start with Deci2.bpXtoY.* , where X is the lower frequency and Y is the higher frequency, which are input to the fingerprint step. Table S11: Preprocessing parameters for SaudiFull earthquake detection, for each station (same filter applied to all components), 5 months continuous data (2017-01-01 to 2017-05-31), at 36 stations, decimate to 50 Hz. 0.5.2 Fingerprint \u00b6 Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/SaudiFull/run_fp_SaudiFull.sh Example script to generate fingerprints on one channel (HHZ) at one station (LNY03), called by the master script run_fp_SaudiFull.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/SaudiFull/fp_input_SA_LNY03_HHZ.json \"fingerprint\": { \"sampling_rate\": 50, \"min_freq\": 4.0, \"max_freq\": 15.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 0.1, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"LNY03\", \"channel\": \"HHZ\", \"start_time\": \"17-01-01T00:00:00.0\", \"end_time\": \"17-05-31T00:00:00.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/\", There are a total of 106 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S12. Median/MAD output files: mad/mad*.txt Table S12: Fingerprint input parameters for SaudiFull earthquake detection: 3-component at 36 stations (except for SA.UMJ02), after applying station-specific bandpass filter (Table S11), and sampled at 50 Hz. The fingerprint sampling period is dt_fp = 1.2 seconds. Fingerprints (binary files): fingerprints/LNY03.HHZ.fp Timestamps at each fingerprint index (text files): timestamps/LNY03.HHZ.ts Finally, to create global indices for the SaudiFull data set, so that fingerprint indices from different channels (all 106) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/SaudiFull/global_indices_SaudiFull.json The common starting time is in global_idx_stats.txt : 2017-01-01T00:00:06.840000 UTC 0.5.3 Similarity Search \u00b6 Master script to run similarity search on each channel (out of 106 total): ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/run_simsearch_SaudiFull.sh Table S13: Similarity search input parameters for SaudiFull earthquake detection: 106 channels at 36 stations (3 components each, except SA.UMJ02). The occurrence filter, specified by the FREQ_NOISE parameter, was applied only for selected stations and channels (Table S14). Example script to run similarity search on one channel (HHZ) at one station (LNY03), called by the master script run_simsearch_SaudiFull.sh : ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/simsearch_input_SaudiFull.sh LNY03 HHZ NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 We first ran similarity search with the same input parameters on all 106 channels, without the occurrence filter. For 18 selected channels (Table S14), where the candidate_pairs similarity search outputs were especially large because of correlated noise, we ran similarity search with the occurrence filter (FREQ_NOISE=0.01), which significantly reduced the similarity search output file sizes. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. For example, the occurrence filter was applied for station LNY01 channel HHZ by calling the script filt_simsearch_input_SaudiFull.sh from the master script run_simsearch_SaudiFull.sh : ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/filt_simsearch_input_SaudiFull.sh LNY03 HHZ NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 FREQ_NOISE=0.01 Table S14: Selected stations and channels from SaudiFull data set where we applied the occurrence filter with FREQ_ NOISE=0.01. 0.5.4 Postprocessing \u00b6 First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (106 total): ~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/output_SaudiFull_pairs.sh For example, on one channel (HHZ) at one station (LNY03), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/ -p candidate_pairs_LNY03_HHZ -i /lfs/1/ceyoon/TimeSeries/SaudiFull/global_indices/LNY03_HHZ_idx_mapping.txt Output file for example (large size at channel level): /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/candidate_pairs_LNY03_HHZ_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for all 36 stations: ~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/combine_SaudiFull_pairs.sh Example For example, on three channels (HHE, HHN, HHZ) at one station (LNY03), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/ $ mv candidate_pairs_LNY03_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S13). Note: this step will delete the c andidate_ pairs_LNY03_HH*_merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ -p candidate_pairs_LNY03 --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ candidate_pairs_LNY03_combined.txt For station SA.UMJ02, which has only 1 component (HHE), multiply the similarity sim by 3 to give this station an equal weight as the other 3-component stations: ~/FAST/postprocessing/$ awk \u2019{print $1, $2, 3*$3}\u2019 /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_HHE_merged.txt > /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_combined.txt Finally , detect similar fingerprints across the network of 36 stations, using the input parameters in Table S15: ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/SaudiFull/36sta_3stathresh_network_params.json \"network\": { \"max_fp\": 10736786, \"dt_fp\": 1.2, (seconds) \"dgapL\": 10, (12 s) \"dgapW\": 3, (3.6 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (9.6 s) \"ivals_thresh\": 6, \"nsta_thresh\": 3, \"input_offset\": 15 (18 s) }, Network detection output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/SaudiFull/ network_detection/36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events) At this point, FAST earthquake detection processing is done . Table S15: Network detection input parameters for SaudiFull at 36 stations. max_fp = 10736786 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.2 seconds is the fingerprint sampling period from Table S12. 0.5.5 Remove Duplicates After Network Detection \u00b6 Info The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.) First , save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind). ~/FAST/utils/network/$ python arrange_network_detection_results.py Output: NetworkDetectionTimes_36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events) Second , remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity). ~/FAST/utils/network/$ ./remove_duplicates_after_network.sh Output: uniquestart_sorted_no_duplicates.txt (15,054 events) Third , remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum. ~/FAST/utils/network/$ python delete_overlap_network_detections.py Output: 36sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (11,597 events) Fourth , since different channels in the network have different durations (for example, in Figure 7, stations UMJ01-UMJ12 were active only during May 2017, while many of the other stations were active from January to May 2017), we calculate a normalized measure of the number of stations that detected the event: frac_ch, which is the fraction of channels that were active at each detection time. This is done by reading in files that were generated during preprocessing by get_continuous_data_times.py. This normalization step would not be necessary if all stations and channels in the network recorded the same duration of data. ~/FAST/utils/network/$ python get_station_count_detections.py Output: 36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt (11,597 events) Finally , sort remaining events in descending order of num_sta, then frac_ch, then peaksum, for the final detection list. ~/FAST/utils/network/$ ./final_network_sort_nsta_fracch_peaksum.sh Output: sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt (11,597 events) 0.5.6 Visual Inspection and Final Detections \u00b6 Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table S16). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_SaudiFull.py 0 11597 Output: .png image files in 36sta_3stathresh_NetworkWaveformPlots/ Table S16: Final thresholds for SaudiFull applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied. After visual inspection, 4634 events are above thresholds in Table S16. EQ_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt : 4543 events that look like earthquake waveforms FALSE_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt : 91 false detections above thresholds that do not look like earthquakes For the 4543 earthquake events, output an event catalog (Figure 8): ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_SaudiFull_36sta_3stathresh.txt (4543 events) Figure 8: Saudi Arabia earthquake detections from 2017-01-01 to 2017-05-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S16). FAST detected a total of 4,543 earthquakes during this month.","title":"0.5 SaudiFull Data Set: Saudi Arabia, January - May 2017"},{"location":"saudifull_dataset/#05-saudifull-data-set-saudi-arabia-january-may-2017","text":"Location: Saudi Arabia, January - May 2017 (volcanic area with dikes) Duration: up to 5 months (151 days): 2017-01-01 to 2017-05-30 Network: 36 stations, 3 components each (HHE, HHN, HHZ) = 106 channels. (Station SA.UMJ02: only HHE channel) Sampling rate: 100 Hz Provided by: Mohammad Youssof (KAUST)","title":"0.5 SaudiFull Data Set: Saudi Arabia, January - May 2017"},{"location":"saudifull_dataset/#051-preprocessing","text":"Output continuous data duration: different stations used for detection have different durations and time gaps (need to modify paths in get_continuous_data_times.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/continuous_data_times_SaudiFull.sh The output files in continuous_duration/ can be read into a custom script called plot_continuous_ duration_SaudiFull.py to plot the duration of available continuous data at each station and channel (Figure 7). Figure 7: Duration of SaudiFull continuous data at 36 stations (change colors with each station), 3 components each (except SA.UMJ02 which has only HHE). White sections indicate time gaps. Detected zero-filled time-gap sections of continuous data in all 106 channels (need to modify paths in fill_ time_gaps_with_uncorrelated_noise.py), and filled them with random uncorrelated noise: ~/FAST/utils/preprocess/$ python fill_time_gaps_with_uncorrelated_noise.py Only stations SA.UMJ03, SA.UMJ05, SA.UMJ08 had zero-filled time-gap sections, which were filled with random noise and saved as files starting with the Filled.* string. The majority of continuous data files had no zero-filled time gaps, so we used original mseed data files. Output sample spectrograms on each channel and station to determine bandpass filter range (need to modify paths in plot_sample_spectrograms.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/sample_spectrograms_SaudiFull.sh Apply bandpass filter and decimate (need to modify paths in bandpass_filter_decimate.py): ~/FAST/utils/preprocess/$ ../../parameters/preprocess/SaudiFull/bandpass_filter_decimate_SaudiFull.sh Based on sample spectrograms, apply a station-specific bandpass filter (Table S11). Decimate by a factor of 2 to a sampling rate of 50 Hz. Filtered continuous data files start with Deci2.bpXtoY.* , where X is the lower frequency and Y is the higher frequency, which are input to the fingerprint step. Table S11: Preprocessing parameters for SaudiFull earthquake detection, for each station (same filter applied to all components), 5 months continuous data (2017-01-01 to 2017-05-31), at 36 stations, decimate to 50 Hz.","title":"0.5.1 Preprocessing"},{"location":"saudifull_dataset/#052-fingerprint","text":"Master script to create fingerprints on each channel, then generate global indices at the end: ~/FAST/fingerprint/$ ../parameters/fingerprint/SaudiFull/run_fp_SaudiFull.sh Example script to generate fingerprints on one channel (HHZ) at one station (LNY03), called by the master script run_fp_SaudiFull.sh: ~/FAST/fingerprint/$ python gen_fp.py ../parameters/fingerprint/SaudiFull/fp_input_SA_LNY03_HHZ.json \"fingerprint\": { \"sampling_rate\": 50, \"min_freq\": 4.0, \"max_freq\": 15.0, \"spec_length\": 6.0, \"spec_lag\": 0.12, \"fp_length\": 64, \"fp_lag\": 10, \"k_coef\": 400, \"nfreq\": 32, \"mad_sampling_rate\": 0.1, \"mad_sample_interval\": 86400 \"data\": { \"station\": \"LNY03\", \"channel\": \"HHZ\", \"start_time\": \"17-01-01T00:00:00.0\", \"end_time\": \"17-05-31T00:00:00.0\", \"folder\": \"/lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/\", There are a total of 106 fp_input_NETWORK_STATION_CHANNEL.json fingerprint input files, one for each channel and station, all with the same input fingerprint parameters in Table S12. Median/MAD output files: mad/mad*.txt Table S12: Fingerprint input parameters for SaudiFull earthquake detection: 3-component at 36 stations (except for SA.UMJ02), after applying station-specific bandpass filter (Table S11), and sampled at 50 Hz. The fingerprint sampling period is dt_fp = 1.2 seconds. Fingerprints (binary files): fingerprints/LNY03.HHZ.fp Timestamps at each fingerprint index (text files): timestamps/LNY03.HHZ.ts Finally, to create global indices for the SaudiFull data set, so that fingerprint indices from different channels (all 106) and stations are referenced to a common starting time: $ python global_index.py ../parameters/fingerprint/SaudiFull/global_indices_SaudiFull.json The common starting time is in global_idx_stats.txt : 2017-01-01T00:00:06.840000 UTC","title":"0.5.2 Fingerprint"},{"location":"saudifull_dataset/#053-similarity-search","text":"Master script to run similarity search on each channel (out of 106 total): ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/run_simsearch_SaudiFull.sh Table S13: Similarity search input parameters for SaudiFull earthquake detection: 106 channels at 36 stations (3 components each, except SA.UMJ02). The occurrence filter, specified by the FREQ_NOISE parameter, was applied only for selected stations and channels (Table S14). Example script to run similarity search on one channel (HHZ) at one station (LNY03), called by the master script run_simsearch_SaudiFull.sh : ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/simsearch_input_SaudiFull.sh LNY03 HHZ NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 We first ran similarity search with the same input parameters on all 106 channels, without the occurrence filter. For 18 selected channels (Table S14), where the candidate_pairs similarity search outputs were especially large because of correlated noise, we ran similarity search with the occurrence filter (FREQ_NOISE=0.01), which significantly reduced the similarity search output file sizes. A fingerprint that matches over 1% of other fingerprints is excluded from the similarity search, in order to avoid detecting noise that repeats often in time. For example, the occurrence filter was applied for station LNY01 channel HHZ by calling the script filt_simsearch_input_SaudiFull.sh from the master script run_simsearch_SaudiFull.sh : ~/FAST/simsearch/$ ../parameters/simsearch/SaudiFull/filt_simsearch_input_SaudiFull.sh LNY03 HHZ NTBLS=100 NHASH=4 NREPEAT=5 NVOTES=2 NTHREAD=56 NUM_PART=1 FREQ_NOISE=0.01 Table S14: Selected stations and channels from SaudiFull data set where we applied the occurrence filter with FREQ_ NOISE=0.01.","title":"0.5.3 Similarity Search"},{"location":"saudifull_dataset/#054-postprocessing","text":"First , run the master script to convert similarity search output from binary format to text format (3 columns: dt = idx1 \u2212 idx2, idx1, sim, sorted in increasing dt order) for each channel (106 total): ~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/output_SaudiFull_pairs.sh For example, on one channel (HHZ) at one station (LNY03), all on one line: ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/ -p candidate_pairs_LNY03_HHZ -i /lfs/1/ceyoon/TimeSeries/SaudiFull/global_indices/LNY03_HHZ_idx_mapping.txt Output file for example (large size at channel level): /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/candidate_pairs_LNY03_HHZ_merged.txt Second , run the master script to combine similarity output from all 3 components at a given station, for all 36 stations: ~/FAST/postprocessing/$ ../parameters/postprocess/SaudiFull/combine_SaudiFull_pairs.sh Example For example, on three channels (HHE, HHN, HHZ) at one station (LNY03), first move the similarity output text files to the inputs_network/ directory: $ cd /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.LNY03/fingerprints/ $ mv candidate_pairs_LNY03_HH*_merged.txt ../../../inputs_network/ Then for each similar fingerprint pair, add the similarity from all 3 components at the same station, with a similarity threshold of 6 = (3 components)*(v=2 votes/component, Table S13). Note: this step will delete the c andidate_ pairs_LNY03_HH*_merged.txt files. ~/FAST/postprocessing/$ python parse_results.py -d /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ -p candidate_pairs_LNY03 --sort true --parse false -c true -t 6 Output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/SaudiFull/inputs_network/ candidate_pairs_LNY03_combined.txt For station SA.UMJ02, which has only 1 component (HHE), multiply the similarity sim by 3 to give this station an equal weight as the other 3-component stations: ~/FAST/postprocessing/$ awk \u2019{print $1, $2, 3*$3}\u2019 /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_HHE_merged.txt > /lfs/1/ceyoon/TimeSeries/SaudiFull/SA.UMJ02/fingerprints/candidate_pairs_UMJ02_combined.txt Finally , detect similar fingerprints across the network of 36 stations, using the input parameters in Table S15: ~/FAST/postprocessing/$ python scr_run_network_det.py ../parameters/postprocess/SaudiFull/36sta_3stathresh_network_params.json \"network\": { \"max_fp\": 10736786, \"dt_fp\": 1.2, (seconds) \"dgapL\": 10, (12 s) \"dgapW\": 3, (3.6 s) \"num_pass\": 2, \"min_dets\": 3, \"min_sum_multiplier\": 1, \"max_width\": 8, (9.6 s) \"ivals_thresh\": 6, \"nsta_thresh\": 3, \"input_offset\": 15 (18 s) }, Network detection output file for example (smaller size at station level): /lfs/1/ceyoon/TimeSeries/SaudiFull/ network_detection/36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events) At this point, FAST earthquake detection processing is done . Table S15: Network detection input parameters for SaudiFull at 36 stations. max_fp = 10736786 is the largest fingerprint index over all channels from *mapping.txt files in the global_indices directory. dt_fp = 1.2 seconds is the fingerprint sampling period from Table S12.","title":"0.5.4 Postprocessing"},{"location":"saudifull_dataset/#055-remove-duplicates-after-network-detection","text":"Info The network detection output still contains many duplicate events, so we need to remove these using a few scripts, where you need to modify the hard-coded paths. (These are scripts I quickly came up with on the fly to help me analyze the detection output. Feel free to come up with improved scripts that would better suit your needs.) First , save only first and last time indices for each detection. For the last 2 columns: output the number of stations that detected event (num_sta) and difference between first and last index (diff_ind). ~/FAST/utils/network/$ python arrange_network_detection_results.py Output: NetworkDetectionTimes_36sta_3stathresh_detlist_rank_by_peaksum.txt (21,498 events) Second , remove duplicate events. First remove events with exact first and last detection time indices. Then remove events with duplicate start times; for each start time, keep only the event with the highest num_sta (number of stations that detected the event) and peaksum (peak similarity). ~/FAST/utils/network/$ ./remove_duplicates_after_network.sh Output: uniquestart_sorted_no_duplicates.txt (15,054 events) Third , remove events that overlap between the first and last detection time indices, keeping the event with the highest num_sta and peaksum. ~/FAST/utils/network/$ python delete_overlap_network_detections.py Output: 36sta_3stathresh_FinalUniqueNetworkDetectionTimes.txt (11,597 events) Fourth , since different channels in the network have different durations (for example, in Figure 7, stations UMJ01-UMJ12 were active only during May 2017, while many of the other stations were active from January to May 2017), we calculate a normalized measure of the number of stations that detected the event: frac_ch, which is the fraction of channels that were active at each detection time. This is done by reading in files that were generated during preprocessing by get_continuous_data_times.py. This normalization step would not be necessary if all stations and channels in the network recorded the same duration of data. ~/FAST/utils/network/$ python get_station_count_detections.py Output: 36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt (11,597 events) Finally , sort remaining events in descending order of num_sta, then frac_ch, then peaksum, for the final detection list. ~/FAST/utils/network/$ ./final_network_sort_nsta_fracch_peaksum.sh Output: sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt (11,597 events)","title":"0.5.5 Remove Duplicates After Network Detection"},{"location":"saudifull_dataset/#056-visual-inspection-and-final-detections","text":"Plot event waveforms in the final detection list, ranked in descending order of num_sta, then peaksum, for visual inspection. Need to verify by looking at the waveforms that these are indeed earthquakes, and also enables setting final detection thresholds (Table S16). ~/FAST/utils/events/$ python PARTIALplot_detected_waveforms_SaudiFull.py 0 11597 Output: .png image files in 36sta_3stathresh_NetworkWaveformPlots/ Table S16: Final thresholds for SaudiFull applied to network detection parameters num_sta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of num_sta, a different threshold for peaksum can be applied. After visual inspection, 4634 events are above thresholds in Table S16. EQ_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt : 4543 events that look like earthquake waveforms FALSE_sort_nsta_peaksum_36sta_3stathresh_ChannelCount_FinalUniqueNetworkDetectionTimes.txt : 91 false detections above thresholds that do not look like earthquakes For the 4543 earthquake events, output an event catalog (Figure 8): ~/FAST/utils/events/$ python output_final_detection_list.py Output: FINAL_Detection_List_SaudiFull_36sta_3stathresh.txt (4543 events) Figure 8: Saudi Arabia earthquake detections from 2017-01-01 to 2017-05-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S16). FAST detected a total of 4,543 earthquakes during this month.","title":"0.5.6 Visual Inspection and Final Detections"},{"location":"setup_colab/","text":"Installation for Google Colab \u00b6 Info If you are new to FAST, testing out FAST in Google Colab is a great way to get an overview of the software and learn how to test your own data. What is Colab? \u00b6 Colab is a free Jupyter notebook environment that runs entirely in the cloud. It lets you and your team members edit documents the way you work with Google Docs and also run code on a data set and visualize the results. Colab supports many popular machine learning libraries which can be easily loaded in your notebook. The relationship between iPython, Jupyter Notebook, and Google Colab. ( Source ) Run FAST in Colab \u00b6 To run FAST in Google Colab, copy this Google Colab FAST example using data from the Hector Mine into your Google drive. The Colab uses a small example data set from the Hector Mine with 7 stations and less than one day long. With the Hector Mine data set, you can run the end-to-end FAST pipeline, from fingerprint to output list of detection times, in just a few minutes, since it is a small data set. If you want to learn how to use FAST as a beginner, using the Hector Mine example data set is suggested since a bigger data set might take hours, which is not useful. Use the instructions in the How to Set Parameters section to prepare and test your own data set.","title":"Google Colab"},{"location":"setup_colab/#installation-for-google-colab","text":"Info If you are new to FAST, testing out FAST in Google Colab is a great way to get an overview of the software and learn how to test your own data.","title":"Installation for Google Colab"},{"location":"setup_colab/#what-is-colab","text":"Colab is a free Jupyter notebook environment that runs entirely in the cloud. It lets you and your team members edit documents the way you work with Google Docs and also run code on a data set and visualize the results. Colab supports many popular machine learning libraries which can be easily loaded in your notebook. The relationship between iPython, Jupyter Notebook, and Google Colab. ( Source )","title":"What is Colab?"},{"location":"setup_colab/#run-fast-in-colab","text":"To run FAST in Google Colab, copy this Google Colab FAST example using data from the Hector Mine into your Google drive. The Colab uses a small example data set from the Hector Mine with 7 stations and less than one day long. With the Hector Mine data set, you can run the end-to-end FAST pipeline, from fingerprint to output list of detection times, in just a few minutes, since it is a small data set. If you want to learn how to use FAST as a beginner, using the Hector Mine example data set is suggested since a bigger data set might take hours, which is not useful. Use the instructions in the How to Set Parameters section to prepare and test your own data set.","title":"Run FAST in Colab"},{"location":"setup_docker/","text":"Installation for Docker \u00b6 Docker is an open-source project for automating the deployment of applications as portable, self-sufficient containers that can run on the cloud or on-premises. ( Source ) Docker lets you run FAST on a non-Linux operating system, so it is recommended for Mac or Windows users. Install Docker \u00b6 Install Docker on your machine here . To get started, make sure Docker has been successfully installed by running: $ docker run hello-world You should see the Hello from Docker! message displayed. Otherwise, refer to Docker's documentation for getting started here . Warning By default, Docker for Mac allocates 2.00GB of RAM . The more memory available on Docker, the faster FAST will run. Please refer to Docker's Docker Desktop for Mac user manual for more information on how to increase the allocated memory. Setting up Docker for FAST \u00b6 Create a directory for FAST code and outputs $ mkdir DockerFAST Change permissions so that Docker can write to this directory $ chmod 777 DockerFAST Clone the FAST repository from GitHub into a local directory named ./FAST/ $ cd DockerFAST $ git clone https://github.com/stanford-futuredata/FAST.git ./FAST/ Build the Docker image Note Building the Docker image with Dockerfile with set up all FAST dependencies (Linux Ubuntu 18.04, CMake compiler, C++ boost, conda for python virtual environment and libraries). $ cd FAST/ $ docker build -f Dockerfile -t fast_image:0.1 . -f - Name of the Dockerfile -t - Tag name Run the Docker image in a Docker container $ docker run -v ${PWD}:/app -it fast_image:0.1 /bin/bash -v - Bind mount a volume. The current directory in ${PWD} is mounted inside the container into the directory /app, so that any changes to files made inside the container are saved to disk and persist after exiting the container. -it - Short for --interactive + --tty, which takes you inside the container in interactive mode, allowing you to run commands on the command line in the container, which we need to run FAST. Now we are in the Docker container, in the eq_fast conda environment. We are ready to run FAST now. (eq_fast) root@555d364b63d7:/app/FAST# Running FAST with Docker \u00b6 Refer to the Tutorial for more detailed information about FAST parameters, inputs, and outputs. Generate fingerprints for the data set \u00b6 (eq_fast) root@555d364b63d7:/app/FAST# python run_fp.py -c config.json Search for Similar Earthquakes \u00b6 (eq_fast) root@555d364b63d7:/app/FAST# cd simsearch/ (eq_fast) root@555d364b63d7:/app/FAST/simsearch# cmake . (eq_fast) root@555d364b63d7:/app/FAST/simsearch# make (eq_fast) root@555d364b63d7:/app/FAST/simsearch# cd .. (eq_fast) root@555d364b63d7:/app/FAST# python run_simsearch.py -c config.json Postprocess: Parse FAST Similarity Search Output \u00b6 (eq_fast) root@555d364b63d7:/app/FAST# cd postprocessing/ (eq_fast) root@555d364b63d7:/app/FAST/postprocessing# ../parameters/postprocess/output_HectorMine_pairs.sh (eq_fast) root@555d364b63d7:/app/FAST/postprocessing# ../parameters/postprocess/combine_HectorMine_pairs.sh Postprocess: Network Detection \u00b6 (eq_fast) root@555d364b63d7:/app/FAST/postprocessing# python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json Postprocess: Clean Network Detection Results \u00b6 Need to modify inputs within each script file to your data set. (eq_fast) root@555d364b63d7:/app/FAST/postprocessing# cd ../utils/network/ (eq_fast) root@555d364b63d7:/app/FAST/utils/network# python arrange_network_detection_results.py (eq_fast) root@555d364b63d7:/app/FAST/utils/network# ./remove_duplicates_after_network.sh (eq_fast) root@555d364b63d7:/app/FAST/utils/network# python delete_overlap_network_detections.py (eq_fast) root@555d364b63d7:/app/FAST/utils/network# ./final_network_sort_nsta_peaksum.sh Visualize the FAST Output \u00b6 (eq_fast) root@555d364b63d7:/app/FAST/utils/network# cat ../../data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Display Waveforms for FAST Detections in Descending Order of \"peaksum\" Similarity \u00b6 This example outputs png images for 100 event waveforms. The plot file names are sorted in descending order by: num_sta (number of stations that detected this event), peaksum (peak total similarity) (eq_fast) root@555d364b63d7:/app/FAST/utils/network# cd .. (eq_fast) root@555d364b63d7:/app/FAST/utils# cd events/ (eq_fast) root@555d364b63d7:/app/FAST/utils/events# python PARTIALplot_detected_waveforms_HectorMine.py 0 100 Note View images outside Docker container \u2014 to manually determine detection threshold $ ls ../../data/network_detection/7sta_2stathresh_NetworkWaveformPlots/ event_rank00000_nsta7_peaksum1015_ind6204_time6204.0_1999-10-15T14:43:24.676000.png event_rank00001_nsta7_peaksum1015_ind3842_time3842.0_1999-10-15T14:04:02.676000.png event_rank00002_nsta7_peaksum920_ind7488_time7488.0_1999-10-15T15:04:48.676000.png event_rank00003_nsta7_peaksum823_ind5286_time5286.0_1999-10-15T14:28:06.676000.png event_rank00004_nsta7_peaksum718_ind20202_time20202.0_1999-10-15T18:36:42.676000.png event_rank00005_nsta7_peaksum713_ind46536_time46536.0_1999-10-16T01:55:36.676000.png ... Set Detection Threshold \u00b6 Note Everything above the detection threshold is deemed an earthquake. In this example, the first 50 events with the highest \"peaksum\" similarity are identified as earthquakes, while the remaining events are not earthquakes. (eq_fast) root@555d364b63d7:/app/FAST/utils/events# cd ../../data/network_detection/ (eq_fast) root@555d364b63d7:/app/FAST/data/network_detection# head -50 sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt > EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Output Final FAST Detected Event List \u00b6 (eq_fast) root@555d364b63d7:/app/FAST/data/network_detection# cd ../../utils/events/ (eq_fast) root@555d364b63d7:/app/FAST/utils/events# python output_final_detection_list.py (eq_fast) root@555d364b63d7:/app/FAST/utils/events# cat ../../data/network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt Phase Picking, Earthquake Location, Map Visualization \u00b6 Refer to the Tutorial for more information and detailed commands for optional next steps to take after running FAST: Phase Picking with SeisBench Earthquake Location with HYPOINVERSE Mapping and Visualization with PyGMT Exiting the Docker Container \u00b6 (pygmt) root@555d364b63d7:/app/FAST/utils/mapping# exit exit After exiting the Docker container, all files created within the container should still be accessible on your disk since the current directory was mounted inside the container with docker run -v ${PWD}:/app . View status of the Docker Container \u00b6 $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 555d364b63d7 fast_image:0.1 \"/bin/bash\" 6 days ago Exited (1) 25 seconds ago pensive_ramanujan Enter Docker Container again \u00b6 We can pick up where we left off after entering the same Docker container again. Notice that the pygmt conda environment is still there. $ docker start -i 555d364b63d7 (eq_fast) root@555d364b63d7:/# cd app (eq_fast) root@555d364b63d7:/app# ls Calipatria FAST_userguide_v0.pdf __pycache__ changes data fingerprint parse_config.py run_fp.py utils Calipatria.zip LICENSE calipatria_client.ipynb config.json docs mkdocs.yml postprocessing run_simsearch.py Dockerfile README.md calipatria_massdownloader.ipynb config_calipatria.json environment.yml parameters requirements.txt simsearch (eq_fast) root@6006660926e5:/app# conda env list # conda environments: # base /root/miniconda3 eq_fast * /root/miniconda3/envs/eq_fast pygmt /root/miniconda3/envs/pygmt Remove all Docker Containers and Images \u00b6 Warning ONLY DO THIS WHEN YOU WANT TO REMOVE ALL DOCKER CONTAINERS AND IMAGES!!! This step will free up lots of space on your computer. $ docker system prune WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all dangling images - all dangling build cache","title":"Docker"},{"location":"setup_docker/#installation-for-docker","text":"Docker is an open-source project for automating the deployment of applications as portable, self-sufficient containers that can run on the cloud or on-premises. ( Source ) Docker lets you run FAST on a non-Linux operating system, so it is recommended for Mac or Windows users.","title":"Installation for Docker"},{"location":"setup_docker/#install-docker","text":"Install Docker on your machine here . To get started, make sure Docker has been successfully installed by running: $ docker run hello-world You should see the Hello from Docker! message displayed. Otherwise, refer to Docker's documentation for getting started here . Warning By default, Docker for Mac allocates 2.00GB of RAM . The more memory available on Docker, the faster FAST will run. Please refer to Docker's Docker Desktop for Mac user manual for more information on how to increase the allocated memory.","title":"Install Docker"},{"location":"setup_docker/#setting-up-docker-for-fast","text":"Create a directory for FAST code and outputs $ mkdir DockerFAST Change permissions so that Docker can write to this directory $ chmod 777 DockerFAST Clone the FAST repository from GitHub into a local directory named ./FAST/ $ cd DockerFAST $ git clone https://github.com/stanford-futuredata/FAST.git ./FAST/ Build the Docker image Note Building the Docker image with Dockerfile with set up all FAST dependencies (Linux Ubuntu 18.04, CMake compiler, C++ boost, conda for python virtual environment and libraries). $ cd FAST/ $ docker build -f Dockerfile -t fast_image:0.1 . -f - Name of the Dockerfile -t - Tag name Run the Docker image in a Docker container $ docker run -v ${PWD}:/app -it fast_image:0.1 /bin/bash -v - Bind mount a volume. The current directory in ${PWD} is mounted inside the container into the directory /app, so that any changes to files made inside the container are saved to disk and persist after exiting the container. -it - Short for --interactive + --tty, which takes you inside the container in interactive mode, allowing you to run commands on the command line in the container, which we need to run FAST. Now we are in the Docker container, in the eq_fast conda environment. We are ready to run FAST now. (eq_fast) root@555d364b63d7:/app/FAST#","title":"Setting up Docker for FAST"},{"location":"setup_docker/#running-fast-with-docker","text":"Refer to the Tutorial for more detailed information about FAST parameters, inputs, and outputs.","title":"Running FAST with Docker"},{"location":"setup_docker/#generate-fingerprints-for-the-data-set","text":"(eq_fast) root@555d364b63d7:/app/FAST# python run_fp.py -c config.json","title":"Generate fingerprints for the data set"},{"location":"setup_docker/#search-for-similar-earthquakes","text":"(eq_fast) root@555d364b63d7:/app/FAST# cd simsearch/ (eq_fast) root@555d364b63d7:/app/FAST/simsearch# cmake . (eq_fast) root@555d364b63d7:/app/FAST/simsearch# make (eq_fast) root@555d364b63d7:/app/FAST/simsearch# cd .. (eq_fast) root@555d364b63d7:/app/FAST# python run_simsearch.py -c config.json","title":"Search for Similar Earthquakes"},{"location":"setup_docker/#postprocess-parse-fast-similarity-search-output","text":"(eq_fast) root@555d364b63d7:/app/FAST# cd postprocessing/ (eq_fast) root@555d364b63d7:/app/FAST/postprocessing# ../parameters/postprocess/output_HectorMine_pairs.sh (eq_fast) root@555d364b63d7:/app/FAST/postprocessing# ../parameters/postprocess/combine_HectorMine_pairs.sh","title":"Postprocess: Parse FAST Similarity Search Output"},{"location":"setup_docker/#postprocess-network-detection","text":"(eq_fast) root@555d364b63d7:/app/FAST/postprocessing# python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json","title":"Postprocess: Network Detection"},{"location":"setup_docker/#postprocess-clean-network-detection-results","text":"Need to modify inputs within each script file to your data set. (eq_fast) root@555d364b63d7:/app/FAST/postprocessing# cd ../utils/network/ (eq_fast) root@555d364b63d7:/app/FAST/utils/network# python arrange_network_detection_results.py (eq_fast) root@555d364b63d7:/app/FAST/utils/network# ./remove_duplicates_after_network.sh (eq_fast) root@555d364b63d7:/app/FAST/utils/network# python delete_overlap_network_detections.py (eq_fast) root@555d364b63d7:/app/FAST/utils/network# ./final_network_sort_nsta_peaksum.sh","title":"Postprocess: Clean Network Detection Results"},{"location":"setup_docker/#visualize-the-fast-output","text":"(eq_fast) root@555d364b63d7:/app/FAST/utils/network# cat ../../data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt","title":"Visualize the FAST Output"},{"location":"setup_docker/#display-waveforms-for-fast-detections-in-descending-order-of-peaksum-similarity","text":"This example outputs png images for 100 event waveforms. The plot file names are sorted in descending order by: num_sta (number of stations that detected this event), peaksum (peak total similarity) (eq_fast) root@555d364b63d7:/app/FAST/utils/network# cd .. (eq_fast) root@555d364b63d7:/app/FAST/utils# cd events/ (eq_fast) root@555d364b63d7:/app/FAST/utils/events# python PARTIALplot_detected_waveforms_HectorMine.py 0 100 Note View images outside Docker container \u2014 to manually determine detection threshold $ ls ../../data/network_detection/7sta_2stathresh_NetworkWaveformPlots/ event_rank00000_nsta7_peaksum1015_ind6204_time6204.0_1999-10-15T14:43:24.676000.png event_rank00001_nsta7_peaksum1015_ind3842_time3842.0_1999-10-15T14:04:02.676000.png event_rank00002_nsta7_peaksum920_ind7488_time7488.0_1999-10-15T15:04:48.676000.png event_rank00003_nsta7_peaksum823_ind5286_time5286.0_1999-10-15T14:28:06.676000.png event_rank00004_nsta7_peaksum718_ind20202_time20202.0_1999-10-15T18:36:42.676000.png event_rank00005_nsta7_peaksum713_ind46536_time46536.0_1999-10-16T01:55:36.676000.png ...","title":"Display Waveforms for FAST Detections in Descending Order of \"peaksum\" Similarity"},{"location":"setup_docker/#set-detection-threshold","text":"Note Everything above the detection threshold is deemed an earthquake. In this example, the first 50 events with the highest \"peaksum\" similarity are identified as earthquakes, while the remaining events are not earthquakes. (eq_fast) root@555d364b63d7:/app/FAST/utils/events# cd ../../data/network_detection/ (eq_fast) root@555d364b63d7:/app/FAST/data/network_detection# head -50 sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt > EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt","title":"Set Detection Threshold"},{"location":"setup_docker/#output-final-fast-detected-event-list","text":"(eq_fast) root@555d364b63d7:/app/FAST/data/network_detection# cd ../../utils/events/ (eq_fast) root@555d364b63d7:/app/FAST/utils/events# python output_final_detection_list.py (eq_fast) root@555d364b63d7:/app/FAST/utils/events# cat ../../data/network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt","title":"Output Final FAST Detected Event List"},{"location":"setup_docker/#phase-picking-earthquake-location-map-visualization","text":"Refer to the Tutorial for more information and detailed commands for optional next steps to take after running FAST: Phase Picking with SeisBench Earthquake Location with HYPOINVERSE Mapping and Visualization with PyGMT","title":"Phase Picking, Earthquake Location, Map Visualization"},{"location":"setup_docker/#exiting-the-docker-container","text":"(pygmt) root@555d364b63d7:/app/FAST/utils/mapping# exit exit After exiting the Docker container, all files created within the container should still be accessible on your disk since the current directory was mounted inside the container with docker run -v ${PWD}:/app .","title":"Exiting the Docker Container"},{"location":"setup_docker/#view-status-of-the-docker-container","text":"$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 555d364b63d7 fast_image:0.1 \"/bin/bash\" 6 days ago Exited (1) 25 seconds ago pensive_ramanujan","title":"View status of the Docker Container"},{"location":"setup_docker/#enter-docker-container-again","text":"We can pick up where we left off after entering the same Docker container again. Notice that the pygmt conda environment is still there. $ docker start -i 555d364b63d7 (eq_fast) root@555d364b63d7:/# cd app (eq_fast) root@555d364b63d7:/app# ls Calipatria FAST_userguide_v0.pdf __pycache__ changes data fingerprint parse_config.py run_fp.py utils Calipatria.zip LICENSE calipatria_client.ipynb config.json docs mkdocs.yml postprocessing run_simsearch.py Dockerfile README.md calipatria_massdownloader.ipynb config_calipatria.json environment.yml parameters requirements.txt simsearch (eq_fast) root@6006660926e5:/app# conda env list # conda environments: # base /root/miniconda3 eq_fast * /root/miniconda3/envs/eq_fast pygmt /root/miniconda3/envs/pygmt","title":"Enter Docker Container again"},{"location":"setup_docker/#remove-all-docker-containers-and-images","text":"Warning ONLY DO THIS WHEN YOU WANT TO REMOVE ALL DOCKER CONTAINERS AND IMAGES!!! This step will free up lots of space on your computer. $ docker system prune WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all dangling images - all dangling build cache","title":"Remove all Docker Containers and Images"},{"location":"setup_linux/","text":"Installation for Linux \u00b6 Requirements \u00b6 FAST is written in Python and C++ and is designed to run on Linux clusters. Install instructions might not work for Windows and macOS machines. Refer to the installation instructions for Google Colab or Docker if you want to run FAST on a machine other than Linux. The code will benefit from running on machines with more memory and CPUs. Consider using instances from Amazon AWS or Google Cloud Install FAST \u00b6 Clone the FAST repository from GitHub into a local directory named ./FAST/ (base) ~$ git clone https://github.com/stanford-futuredata/FAST.git ./FAST/ Install utilities (if not already installed) (base) ~$ sudo apt-get install -y wget (base) ~$ sudo apt-get install -y jq Install C++ dependencies (base) ~$ sudo apt-get install -y cmake (base) ~$ sudo apt-get install -y build-essential (base) ~$ sudo apt-get install -y libboost-all-dev Install Python dependencies in the eq_fast conda environment This requires having Anaconda or Miniconda already installed on your computer (base) ~$ cd FAST/ (base) ~/FAST$ conda env create -f environment.yml -n eq_fast Activate eq_fast conda environment before running FAST (base) ~/FAST$ conda activate eq_fast (eq_fast) ~/FAST$ Run FAST \u00b6 Refer to the Tutorial for more detailed information about FAST parameters, inputs, and outputs. Dataset \u00b6 Raw SAC files for each station are stored under data/waveforms${STATION} . Station \"HEC\" has 3 components so it should have 3 time series data files; the other stations have only 1 component. Fingerprint \u00b6 Parameters for each station are under parameters/fingerprint/ . To fingerprint all stations and generate the global index, you can call the wrapper script (Python): (eq_fast) ~/FAST$ python run_fp.py -c config.json An alternate option for the fingerprint wrapper script (bash): (eq_fast) ~/FAST$ cd fingerprint/ (eq_fast) ~/FAST/fingerprint$ ../parameters/fingerprint/run_fp_HectorMine.sh The fingerprinting step takes less than 1 minute per waveform file on a 2.60GHz CPU. The generated fingerprints can be found at data/waveforms${STATION}/fingerprints/${STATION}${CHANNEL}.fp . The json file data/waveforms${STATION}/${STATION}_${CHANNEL}.json contains information about the fingerprint file, including number of fingerprints ( nfp ) and dimension of each fingerprint ( ndim ). To fingerprint a specific channel/station, call the fingerprint script with the corresponding fingerprint parameter file (this is one line from run_fp_HectorMine.sh ): (eq_fast) ~/FAST$ cd fingerprint/ (eq_fast) ~/FAST/fingerprint$ python gen_fp.py ../parameters/fingerprint/fp_input_CI_CDY_EHZ.json In addition to generating fingerprints, the wrapper script calls the global index generation script automatically. The global index (as opposed to index with a single component) is a consistent way to refer to fingerprint times at different components and stations. Global index generation should only be performed after you've generated fingerprints for every component and station that is used in the detection: (eq_fast) ~/FAST/fingerprint$ python global_index.py ../parameters/fingerprint/global_indices.json The resulting global index mapping for each component is stored at data/global_indices/${STATION}_${CHANNEL}_idx_mapping.txt , where line i in the file represents the global index for fingerprint i-1 in this component. Similarity Search \u00b6 Compile and build the code for similarity search: (eq_fast) ~/FAST$ cd simsearch (eq_fast) ~/FAST/simsearch$ cmake . (eq_fast) ~/FAST/simsearch$ make Call the wrapper script to run similarity search for all stations: (eq_fast) ~/FAST/simsearch$ cd .. (eq_fast) ~/FAST$ python run_simsearch.py -c config.json An alternate option for the similarity search wrapper script (bash): (eq_fast) ~/FAST$ cd simsearch/ (eq_fast) ~/FAST/simsearch$ ../parameters/simsearch/run_simsearch_HectorMine.sh To run the similarity search for each channel/station individually: (eq_fast) ~/FAST$ cd simsearch/ (eq_fast) ~/FAST/simsearch$ ../parameters/simsearch/simsearch_input_HectorMine.sh CDY EHZ Postprocess: Parse FAST Similarity Search Output \u00b6 The following scripts parse the binary output from similarity search to text files, and combine the three channel results for station HEC to a single output. Finally, it copies the parsed outputs to directory ../data/inputs_network/ . (eq_fast) ~/FAST$ cd postprocessing/ (eq_fast) ~/FAST/postprocessing$ ../parameters/postprocess/output_HectorMine_pairs.sh (eq_fast) ~/FAST/postprocessing$ ../parameters/postprocess/combine_HectorMine_pairs.sh Postprocess: Network detection \u00b6 (eq_fast) ~/FAST/postprocessing$ python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json Results from the network detection are under data/network_detection/7sta_2stathresh_detlist* . The file contains a list of potential detections including information about starting fingerprint index (global index, or time) at each station, number of stations where we found other events similar to this event ( nsta ), total number of similar fingerprint pairs mapped to the event ( tot_ndets ), total sum of the similarity values ( tot_vol ). Detailed format of the output can be found in the user guide. Postprocess: Clean Network Detection Results \u00b6 Need to modify inputs within each script file to your data set. (eq_fast) ~/FAST$ cd utils/network/ (eq_fast) ~/FAST/utils/network$ python arrange_network_detection_results.py (eq_fast) ~/FAST/utils/network$ ./remove_duplicates_after_network.sh (eq_fast) ~/FAST/utils/network$ python delete_overlap_network_detections.py (eq_fast) ~/FAST/utils/network$ ./final_network_sort_nsta_peaksum.sh The results from the above scripts can be found at data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt The above section only works with detection results with multiple stations . For single station detections, you can parse the results in the output file . The schema of the output file is: event_start (starting fingerprint index), event_dt, ndets (total number of event-pairs that include this event), peaksum (peak total similarity), and volume (sum of all similarity values for all event-pairs containing this event). Large peaksums usually correspond to higher confidence. Visualize the FAST Output \u00b6 (eq_fast) ~/FAST/utils/network$ cat ../../data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Display Waveforms for FAST Detections in Descending Order of \"peaksum\" Similarity \u00b6 This example outputs png images for 100 event waveforms. The plot file names are sorted in descending order by: num_sta (number of stations that detected this event), peaksum (peak total similarity) (eq_fast) ~/FAST/utils/network$ cd .. (eq_fast) ~/FAST/utils$ cd events/ (eq_fast) ~/FAST/utils/events$ python PARTIALplot_detected_waveforms_HectorMine.py 0 100 Note View waveform images \u2014 to manually determine detection threshold $ ls ../../data/network_detection/7sta_2stathresh_NetworkWaveformPlots/ event_rank00000_nsta7_peaksum1015_ind6204_time6204.0_1999-10-15T14:43:24.676000.png event_rank00001_nsta7_peaksum1015_ind3842_time3842.0_1999-10-15T14:04:02.676000.png event_rank00002_nsta7_peaksum920_ind7488_time7488.0_1999-10-15T15:04:48.676000.png event_rank00003_nsta7_peaksum823_ind5286_time5286.0_1999-10-15T14:28:06.676000.png event_rank00004_nsta7_peaksum718_ind20202_time20202.0_1999-10-15T18:36:42.676000.png event_rank00005_nsta7_peaksum713_ind46536_time46536.0_1999-10-16T01:55:36.676000.png ... Similarly, to plot results for single station detection, we need a global start time (t0) from global_idx_stats.txt, dt_fp in seconds: Event time = t0 + dt_fp * (start fingerprint index) Set Detection Threshold \u00b6 Note Everything above the detection threshold is deemed an earthquake. In this example, the first 50 events with the highest \"peaksum\" similarity are identified as earthquakes, while the remaining events are not earthquakes. (eq_fast) ~/FAST/utils/events$ cd ../../data/network_detection/ (eq_fast) ~/FAST/data/network_detection$ head -50 sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt > EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Output Final FAST Detected Event List \u00b6 (eq_fast) ~/FAST/data/network_detection$ cd ../../utils/events/ (eq_fast) ~/FAST/utils/events$ python output_final_detection_list.py (eq_fast) ~/FAST/utils/events$ cat ../../data/network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt Phase Picking, Earthquake Location, Map Visualization \u00b6 Refer to the Tutorial for more information and detailed commands for optional next steps to take after running FAST: Phase Picking with SeisBench Earthquake Location with HYPOINVERSE Mapping and Visualization with PyGMT","title":"Linux"},{"location":"setup_linux/#installation-for-linux","text":"","title":"Installation for Linux"},{"location":"setup_linux/#requirements","text":"FAST is written in Python and C++ and is designed to run on Linux clusters. Install instructions might not work for Windows and macOS machines. Refer to the installation instructions for Google Colab or Docker if you want to run FAST on a machine other than Linux. The code will benefit from running on machines with more memory and CPUs. Consider using instances from Amazon AWS or Google Cloud","title":"Requirements"},{"location":"setup_linux/#install-fast","text":"Clone the FAST repository from GitHub into a local directory named ./FAST/ (base) ~$ git clone https://github.com/stanford-futuredata/FAST.git ./FAST/ Install utilities (if not already installed) (base) ~$ sudo apt-get install -y wget (base) ~$ sudo apt-get install -y jq Install C++ dependencies (base) ~$ sudo apt-get install -y cmake (base) ~$ sudo apt-get install -y build-essential (base) ~$ sudo apt-get install -y libboost-all-dev Install Python dependencies in the eq_fast conda environment This requires having Anaconda or Miniconda already installed on your computer (base) ~$ cd FAST/ (base) ~/FAST$ conda env create -f environment.yml -n eq_fast Activate eq_fast conda environment before running FAST (base) ~/FAST$ conda activate eq_fast (eq_fast) ~/FAST$","title":"Install FAST"},{"location":"setup_linux/#run-fast","text":"Refer to the Tutorial for more detailed information about FAST parameters, inputs, and outputs.","title":"Run FAST"},{"location":"setup_linux/#dataset","text":"Raw SAC files for each station are stored under data/waveforms${STATION} . Station \"HEC\" has 3 components so it should have 3 time series data files; the other stations have only 1 component.","title":"Dataset"},{"location":"setup_linux/#fingerprint","text":"Parameters for each station are under parameters/fingerprint/ . To fingerprint all stations and generate the global index, you can call the wrapper script (Python): (eq_fast) ~/FAST$ python run_fp.py -c config.json An alternate option for the fingerprint wrapper script (bash): (eq_fast) ~/FAST$ cd fingerprint/ (eq_fast) ~/FAST/fingerprint$ ../parameters/fingerprint/run_fp_HectorMine.sh The fingerprinting step takes less than 1 minute per waveform file on a 2.60GHz CPU. The generated fingerprints can be found at data/waveforms${STATION}/fingerprints/${STATION}${CHANNEL}.fp . The json file data/waveforms${STATION}/${STATION}_${CHANNEL}.json contains information about the fingerprint file, including number of fingerprints ( nfp ) and dimension of each fingerprint ( ndim ). To fingerprint a specific channel/station, call the fingerprint script with the corresponding fingerprint parameter file (this is one line from run_fp_HectorMine.sh ): (eq_fast) ~/FAST$ cd fingerprint/ (eq_fast) ~/FAST/fingerprint$ python gen_fp.py ../parameters/fingerprint/fp_input_CI_CDY_EHZ.json In addition to generating fingerprints, the wrapper script calls the global index generation script automatically. The global index (as opposed to index with a single component) is a consistent way to refer to fingerprint times at different components and stations. Global index generation should only be performed after you've generated fingerprints for every component and station that is used in the detection: (eq_fast) ~/FAST/fingerprint$ python global_index.py ../parameters/fingerprint/global_indices.json The resulting global index mapping for each component is stored at data/global_indices/${STATION}_${CHANNEL}_idx_mapping.txt , where line i in the file represents the global index for fingerprint i-1 in this component.","title":"Fingerprint"},{"location":"setup_linux/#similarity-search","text":"Compile and build the code for similarity search: (eq_fast) ~/FAST$ cd simsearch (eq_fast) ~/FAST/simsearch$ cmake . (eq_fast) ~/FAST/simsearch$ make Call the wrapper script to run similarity search for all stations: (eq_fast) ~/FAST/simsearch$ cd .. (eq_fast) ~/FAST$ python run_simsearch.py -c config.json An alternate option for the similarity search wrapper script (bash): (eq_fast) ~/FAST$ cd simsearch/ (eq_fast) ~/FAST/simsearch$ ../parameters/simsearch/run_simsearch_HectorMine.sh To run the similarity search for each channel/station individually: (eq_fast) ~/FAST$ cd simsearch/ (eq_fast) ~/FAST/simsearch$ ../parameters/simsearch/simsearch_input_HectorMine.sh CDY EHZ","title":"Similarity Search"},{"location":"setup_linux/#postprocess-parse-fast-similarity-search-output","text":"The following scripts parse the binary output from similarity search to text files, and combine the three channel results for station HEC to a single output. Finally, it copies the parsed outputs to directory ../data/inputs_network/ . (eq_fast) ~/FAST$ cd postprocessing/ (eq_fast) ~/FAST/postprocessing$ ../parameters/postprocess/output_HectorMine_pairs.sh (eq_fast) ~/FAST/postprocessing$ ../parameters/postprocess/combine_HectorMine_pairs.sh","title":"Postprocess: Parse FAST Similarity Search Output"},{"location":"setup_linux/#postprocess-network-detection","text":"(eq_fast) ~/FAST/postprocessing$ python scr_run_network_det.py ../parameters/postprocess/7sta_2stathresh_network_params.json Results from the network detection are under data/network_detection/7sta_2stathresh_detlist* . The file contains a list of potential detections including information about starting fingerprint index (global index, or time) at each station, number of stations where we found other events similar to this event ( nsta ), total number of similar fingerprint pairs mapped to the event ( tot_ndets ), total sum of the similarity values ( tot_vol ). Detailed format of the output can be found in the user guide.","title":"Postprocess: Network detection"},{"location":"setup_linux/#postprocess-clean-network-detection-results","text":"Need to modify inputs within each script file to your data set. (eq_fast) ~/FAST$ cd utils/network/ (eq_fast) ~/FAST/utils/network$ python arrange_network_detection_results.py (eq_fast) ~/FAST/utils/network$ ./remove_duplicates_after_network.sh (eq_fast) ~/FAST/utils/network$ python delete_overlap_network_detections.py (eq_fast) ~/FAST/utils/network$ ./final_network_sort_nsta_peaksum.sh The results from the above scripts can be found at data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt The above section only works with detection results with multiple stations . For single station detections, you can parse the results in the output file . The schema of the output file is: event_start (starting fingerprint index), event_dt, ndets (total number of event-pairs that include this event), peaksum (peak total similarity), and volume (sum of all similarity values for all event-pairs containing this event). Large peaksums usually correspond to higher confidence.","title":"Postprocess: Clean Network Detection Results"},{"location":"setup_linux/#visualize-the-fast-output","text":"(eq_fast) ~/FAST/utils/network$ cat ../../data/network_detection/sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt","title":"Visualize the FAST Output"},{"location":"setup_linux/#display-waveforms-for-fast-detections-in-descending-order-of-peaksum-similarity","text":"This example outputs png images for 100 event waveforms. The plot file names are sorted in descending order by: num_sta (number of stations that detected this event), peaksum (peak total similarity) (eq_fast) ~/FAST/utils/network$ cd .. (eq_fast) ~/FAST/utils$ cd events/ (eq_fast) ~/FAST/utils/events$ python PARTIALplot_detected_waveforms_HectorMine.py 0 100 Note View waveform images \u2014 to manually determine detection threshold $ ls ../../data/network_detection/7sta_2stathresh_NetworkWaveformPlots/ event_rank00000_nsta7_peaksum1015_ind6204_time6204.0_1999-10-15T14:43:24.676000.png event_rank00001_nsta7_peaksum1015_ind3842_time3842.0_1999-10-15T14:04:02.676000.png event_rank00002_nsta7_peaksum920_ind7488_time7488.0_1999-10-15T15:04:48.676000.png event_rank00003_nsta7_peaksum823_ind5286_time5286.0_1999-10-15T14:28:06.676000.png event_rank00004_nsta7_peaksum718_ind20202_time20202.0_1999-10-15T18:36:42.676000.png event_rank00005_nsta7_peaksum713_ind46536_time46536.0_1999-10-16T01:55:36.676000.png ... Similarly, to plot results for single station detection, we need a global start time (t0) from global_idx_stats.txt, dt_fp in seconds: Event time = t0 + dt_fp * (start fingerprint index)","title":"Display Waveforms for FAST Detections in Descending Order of \"peaksum\" Similarity"},{"location":"setup_linux/#set-detection-threshold","text":"Note Everything above the detection threshold is deemed an earthquake. In this example, the first 50 events with the highest \"peaksum\" similarity are identified as earthquakes, while the remaining events are not earthquakes. (eq_fast) ~/FAST/utils/events$ cd ../../data/network_detection/ (eq_fast) ~/FAST/data/network_detection$ head -50 sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt > EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt","title":"Set Detection Threshold"},{"location":"setup_linux/#output-final-fast-detected-event-list","text":"(eq_fast) ~/FAST/data/network_detection$ cd ../../utils/events/ (eq_fast) ~/FAST/utils/events$ python output_final_detection_list.py (eq_fast) ~/FAST/utils/events$ cat ../../data/network_detection/FINAL_Detection_List_HectorMine_7sta_2stathresh.txt","title":"Output Final FAST Detected Event List"},{"location":"setup_linux/#phase-picking-earthquake-location-map-visualization","text":"Refer to the Tutorial for more information and detailed commands for optional next steps to take after running FAST: Phase Picking with SeisBench Earthquake Location with HYPOINVERSE Mapping and Visualization with PyGMT","title":"Phase Picking, Earthquake Location, Map Visualization"},{"location":"sim_search/","text":"Similarity Search \u00b6 Hashing \u00b6 Min-Hash* \u00b6 Example: Min-Hash Signature (MHS) \u00b6 LSH Example: Constructing Database \u00b6 Similarity Search in Fingerprint Database \u00b6 Probability of Detection \u00b6 \"lsh_param\": { \"ntbl\": 100, # b: Number of hash tables \"nhash\": 4, # r: Number of hash functions per table \"nvote\": 2, # v: Number of votes \"nthread\": 8, # Number of threads for parallel processing \"npart\": 1, # Number of partitions for the database \"repeat\": 5 # Near-repeat exclusion parameter (samples) }, Jaccard Similarity LSH Parameter Guidance \u00b6 ntbl (b): Number of hash tables 100 is good default value nhash (r): Number of hash functions per table Most sensitive parameter; significant effect on detection performance Lower values: fewer missed detections, more false detections, longer runtime Higher values: more missed detections, fewer false detections, shorter runtime Suggested values (only possibilities are 1,2,3,4,5,6,7,8): nhash =4 for shorter duration data sets (days \u2013 weeks) nhash =5 for longer data sets (months \u2013 year) nhash =6 for longest data sets (5-10 years) nvote (v): Number of votes (pair of similar fingerprints must be in same hash bucket in at least v out of b hash tables) Can use nvote as threshold for single station detection nvote =2 is good starting value; initially set low, can increase threshold later during network detection repeat : Near-repeat exclusion parameter Avoid detecting any fingerprint with itself (or slight offset to itself), which is guaranteed to be similar 5 samples is good default value (Multiply by dt_fp to get value in seconds) The Jaccard similarity threshold (fast increasing part of the S-curve) increases with the increase of number of hash functions (r), number of votes (v) and the decrease of number of tables (b) Performance Impact of LSH Parameters \u00b6 Performance Impact of LSH Parameters (Explanation) \u00b6 Larger nfuncs --> more non-empty hash buckets Larger \u201cnfuncs\u201d --> more non-empty hash buckets, but \u201clargest\u201d hash buckets are smaller (i.e. fingerprints are more \u201cspread out\u201d within hash table) --> faster runtime for similarity search but lower detection threshold (fingerprints must have higher Jaccard similarity for hash collisions). LSH Parameters and Detection Results \u00b6 The sensitivity of the FAST detector depends on the combination of nfuncs and nvotes . The table below shows how the number of detections identified by multi-station FAST on the Iquique foreshock data set from Bergen & Beroza (2018a) changes as the nfuncs and nvotes parameters are varied. The first row (highlighted in blue) gives the parameter values used in Bergen & Beroza (2018a). The size of the output (# of fingerprint-pairs, i.e. # non-zeros in sparse similarity matrix) of the FAST detector depends on the combination of nfuncs and nvotes . Increasing nvotes decreases the output size by increasing the detection threshold, while increasing nfuncs decreases the output size by lowering the detection threshold. Even though the number of detections for (nfuncs 5, nvotes 3) is slightly larger than for (nfuncs 8, nvotes 1), the latter has an output size that is an order of magnitude larger \u2013 this is due to a higher chance of spurious hash collisions associated with requiring only a single \u201cvote\u201d or collision out of 100 hash tables. Table shows output size for FAST detection results in Iquique case study from Bergen & Beroza (2018a). Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 5 , nvotes: 3 Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 8 , nvotes: 3 Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 8 , nvotes: 1 LSH Parameter Guidance (Performance related) \u00b6 ncores : Number of processes for parallel processing For large continuous data sets (>months): use as many as your machine allows Runtime decreases inverse proportionally with the increase of number of threads num_partitions : Number of partitions for LSH database LSH database can be enormous, especially for large continuous data sets FAST is intended to run on Linux clusters with lots of memory (> 64 GB); figure out how much memory is on your machine If data set is small (days-weeks), use num_partitions = 1 (entire database fit in memory) Use num_partitions > 1 for larger data sets, so that each partition fits in memory # partitions noise_freq : ( Occurrence filter ) Frequency threshold above which fingerprints will be filtered out as correlated noise Consider turning on this filter if some of the stations/channels produce orders of magnitude more outputs or take significant longer than its counterparts The slow down might be caused by the large number of matches generated from persistent background noise (see figure below as an example) Example of correlated noise Increase num_partitions to capture correlated noise that only appear in short segments of the input data Example parameters Input: 1 year of time series data noise_freq =0.01 num_partitions =12 Filter out fingerprints that matches over 1% of other fingerprints in the current partition (partition length = 1 year / 12 = 1 month ) Input: 1 month of time series data noise_freq =0.005 num_partitions =30 Filter out fingerprints that matches over 0.5% of other fingerprints in the current partition (partition length = 1 month / 30 = 1 day ) Performance benefits Can reduce the similarity search output size by orders of magnitude as well as improve runtime Reduced output size further improves the postprocessing runtime FAST Similarity Search Output Format \u00b6 Naming convention for text output files One file, regardless of npart: candidate_pairs_${STATION}_${CHANNEL}_merged.txt Example text file (output): candidate_pairs_CDY_EHZ_merged.txt Content of output file: list of pairs of similar fingerprints and their similarity, sorted in increasing dt order: dt = index1-index2 , index1 , sim index1 is index of first fingerprint (according to global index) index2 is index of second fingerprint (according to global index) sim is \u201cFAST similarity\u201d: Number of hash tables (out of b=ntbl) containing fingerprints index1 and index2 in same bucket; should be \u2265 (v=nvote). Note: not normalized as the fraction divided by b. To get fingerprint times get global start time t0 from global_idx_stats.txt, fingerprint lag dt_fp in seconds time1 = t0 + dt_fp * index1, time2 = t0 + dt_fp * index2","title":"Similarity Search"},{"location":"sim_search/#similarity-search","text":"","title":"Similarity Search"},{"location":"sim_search/#hashing","text":"","title":"Hashing"},{"location":"sim_search/#min-hash","text":"","title":"Min-Hash*"},{"location":"sim_search/#example-min-hash-signature-mhs","text":"","title":"Example: Min-Hash Signature (MHS)"},{"location":"sim_search/#lsh-example-constructing-database","text":"","title":"LSH Example: Constructing Database"},{"location":"sim_search/#similarity-search-in-fingerprint-database","text":"","title":"Similarity Search in Fingerprint Database"},{"location":"sim_search/#probability-of-detection","text":"\"lsh_param\": { \"ntbl\": 100, # b: Number of hash tables \"nhash\": 4, # r: Number of hash functions per table \"nvote\": 2, # v: Number of votes \"nthread\": 8, # Number of threads for parallel processing \"npart\": 1, # Number of partitions for the database \"repeat\": 5 # Near-repeat exclusion parameter (samples) }, Jaccard Similarity","title":"Probability of Detection"},{"location":"sim_search/#lsh-parameter-guidance","text":"ntbl (b): Number of hash tables 100 is good default value nhash (r): Number of hash functions per table Most sensitive parameter; significant effect on detection performance Lower values: fewer missed detections, more false detections, longer runtime Higher values: more missed detections, fewer false detections, shorter runtime Suggested values (only possibilities are 1,2,3,4,5,6,7,8): nhash =4 for shorter duration data sets (days \u2013 weeks) nhash =5 for longer data sets (months \u2013 year) nhash =6 for longest data sets (5-10 years) nvote (v): Number of votes (pair of similar fingerprints must be in same hash bucket in at least v out of b hash tables) Can use nvote as threshold for single station detection nvote =2 is good starting value; initially set low, can increase threshold later during network detection repeat : Near-repeat exclusion parameter Avoid detecting any fingerprint with itself (or slight offset to itself), which is guaranteed to be similar 5 samples is good default value (Multiply by dt_fp to get value in seconds) The Jaccard similarity threshold (fast increasing part of the S-curve) increases with the increase of number of hash functions (r), number of votes (v) and the decrease of number of tables (b)","title":"LSH Parameter Guidance"},{"location":"sim_search/#performance-impact-of-lsh-parameters","text":"","title":"Performance Impact of LSH Parameters"},{"location":"sim_search/#performance-impact-of-lsh-parameters-explanation","text":"Larger nfuncs --> more non-empty hash buckets Larger \u201cnfuncs\u201d --> more non-empty hash buckets, but \u201clargest\u201d hash buckets are smaller (i.e. fingerprints are more \u201cspread out\u201d within hash table) --> faster runtime for similarity search but lower detection threshold (fingerprints must have higher Jaccard similarity for hash collisions).","title":"Performance Impact of LSH Parameters (Explanation)"},{"location":"sim_search/#lsh-parameters-and-detection-results","text":"The sensitivity of the FAST detector depends on the combination of nfuncs and nvotes . The table below shows how the number of detections identified by multi-station FAST on the Iquique foreshock data set from Bergen & Beroza (2018a) changes as the nfuncs and nvotes parameters are varied. The first row (highlighted in blue) gives the parameter values used in Bergen & Beroza (2018a). The size of the output (# of fingerprint-pairs, i.e. # non-zeros in sparse similarity matrix) of the FAST detector depends on the combination of nfuncs and nvotes . Increasing nvotes decreases the output size by increasing the detection threshold, while increasing nfuncs decreases the output size by lowering the detection threshold. Even though the number of detections for (nfuncs 5, nvotes 3) is slightly larger than for (nfuncs 8, nvotes 1), the latter has an output size that is an order of magnitude larger \u2013 this is due to a higher chance of spurious hash collisions associated with requiring only a single \u201cvote\u201d or collision out of 100 hash tables. Table shows output size for FAST detection results in Iquique case study from Bergen & Beroza (2018a). Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 5 , nvotes: 3 Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 8 , nvotes: 3 Locations of FAST detections in Kato et al (2016) template matching catalog or in local seismicity catalog (CSN) for detection with LSH parameter values: nfuncs: 8 , nvotes: 1","title":"LSH Parameters and Detection Results"},{"location":"sim_search/#lsh-parameter-guidance-performance-related","text":"ncores : Number of processes for parallel processing For large continuous data sets (>months): use as many as your machine allows Runtime decreases inverse proportionally with the increase of number of threads num_partitions : Number of partitions for LSH database LSH database can be enormous, especially for large continuous data sets FAST is intended to run on Linux clusters with lots of memory (> 64 GB); figure out how much memory is on your machine If data set is small (days-weeks), use num_partitions = 1 (entire database fit in memory) Use num_partitions > 1 for larger data sets, so that each partition fits in memory # partitions noise_freq : ( Occurrence filter ) Frequency threshold above which fingerprints will be filtered out as correlated noise Consider turning on this filter if some of the stations/channels produce orders of magnitude more outputs or take significant longer than its counterparts The slow down might be caused by the large number of matches generated from persistent background noise (see figure below as an example) Example of correlated noise Increase num_partitions to capture correlated noise that only appear in short segments of the input data Example parameters Input: 1 year of time series data noise_freq =0.01 num_partitions =12 Filter out fingerprints that matches over 1% of other fingerprints in the current partition (partition length = 1 year / 12 = 1 month ) Input: 1 month of time series data noise_freq =0.005 num_partitions =30 Filter out fingerprints that matches over 0.5% of other fingerprints in the current partition (partition length = 1 month / 30 = 1 day ) Performance benefits Can reduce the similarity search output size by orders of magnitude as well as improve runtime Reduced output size further improves the postprocessing runtime","title":"LSH Parameter Guidance (Performance related)"},{"location":"sim_search/#fast-similarity-search-output-format","text":"Naming convention for text output files One file, regardless of npart: candidate_pairs_${STATION}_${CHANNEL}_merged.txt Example text file (output): candidate_pairs_CDY_EHZ_merged.txt Content of output file: list of pairs of similar fingerprints and their similarity, sorted in increasing dt order: dt = index1-index2 , index1 , sim index1 is index of first fingerprint (according to global index) index2 is index of second fingerprint (according to global index) sim is \u201cFAST similarity\u201d: Number of hash tables (out of b=ntbl) containing fingerprints index1 and index2 in same bucket; should be \u2265 (v=nvote). Note: not normalized as the fraction divided by b. To get fingerprint times get global start time t0 from global_idx_stats.txt, fingerprint lag dt_fp in seconds time1 = t0 + dt_fp * index1, time2 = t0 + dt_fp * index2","title":"FAST Similarity Search Output Format"},{"location":"tanzania_dataset/","text":"0.3 Tanzania, August 2016 \u00b6 Temporary dense deployment of seismic stations in Tanzania to identify previously unknown faults and infer their dimensions. 1 month continuous data (2016-07-31 to 2016-08-31), at 5 stations, 15 channels (3 components per station), provided by Laura Parisi of King Abdullah University of Science and Technology (KAUST). The stations are located about 10 km apart, at the base of a volcanic caldera called Ngorongoro Crater. For all 15 channels, we applied the following preprocessing: 4-12 Hz bandpass filter, then decimated to 25 Hz (factor of 8, from original 200 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise (only on station CES04). Table S4: FAST input parameters for Tanzania earthquake detection, applied to each component at all 5 stations. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989. Table S5: Network detection input parameters for Tanzania earthquakes at 5 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HNE,HNN,HNZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S6: Final thresholds for Tanzania earthquakes, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta , a different threshold for peaksum can be applied. Figure 4: Tanzania earthquake detections from 2016-07-31 to 2016-08-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S6). FAST detected a total of 1,156 earthquakes during this month. Some false positive detections had to be removed manually, especially detections on only 2 out of 5 stations.","title":"0.3 Tanzania, August 2016"},{"location":"tanzania_dataset/#03-tanzania-august-2016","text":"Temporary dense deployment of seismic stations in Tanzania to identify previously unknown faults and infer their dimensions. 1 month continuous data (2016-07-31 to 2016-08-31), at 5 stations, 15 channels (3 components per station), provided by Laura Parisi of King Abdullah University of Science and Technology (KAUST). The stations are located about 10 km apart, at the base of a volcanic caldera called Ngorongoro Crater. For all 15 channels, we applied the following preprocessing: 4-12 Hz bandpass filter, then decimated to 25 Hz (factor of 8, from original 200 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise (only on station CES04). Table S4: FAST input parameters for Tanzania earthquake detection, applied to each component at all 5 stations. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 2,231,989. Table S5: Network detection input parameters for Tanzania earthquakes at 5 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HNE,HNN,HNZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S6: Final thresholds for Tanzania earthquakes, applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta , a different threshold for peaksum can be applied. Figure 4: Tanzania earthquake detections from 2016-07-31 to 2016-08-31. The vertical axis indicates a measure of network FAST similarity: nsta*peaksum (Table S6). FAST detected a total of 1,156 earthquakes during this month. Some false positive detections had to be removed manually, especially detections on only 2 out of 5 stations.","title":"0.3 Tanzania, August 2016"},{"location":"tutorial/","text":"Tutorial \u00b6 Example Data: Hector Mine Foreshocks \u00b6 Decimated filtered waveform data (20 Hz sampling rate) to use for FAST: data/waveforms${STATION}/Deci5* Original unfiltered waveform data (20 to 100 Hz sampling rate) to use for phase picking: data/waveforms${STATION}/19991015* File Structure Overview \u00b6 Code \u00b6 fingerprint/ # Fingerprint simsearch/ # Similarity Search postprocessing/ # Postprocessing utils/ # Utility Functions preprocess/ network/ events/ run_fp.py run_simsearch.py Configuration and Parameters \u00b6 parameters/ fingerprint/ simsearch/ postprocess/ Data \u00b6 data/ waveforms ${ STATION } / Deci5* ${ STATION } *.sac 19991015* ${ STATION } *.sac Feature Extraction \u00b6 Generate Fingerprints \u00b6 Create fingerprints for each of the 9 channels (7 stations) + global index, using wrapper ~/quake_tutorial$ python run_fp.py -c config.json Alternatively, to fingerprint a specific station, call the fingerprint script with the corresponding fingerprint parameter file: ~/quake_tutorial$ cd fingerprint/ ~/quake_tutorial/fingerprint$ python gen_fp.py ../parameters/fingerprint/fp_input_CI_CDY_EHZ.json Global Index \u00b6 Note Global index is already called by run_fp.py wrapper Complete this step only after you have finished computing fingerprints for every component and station you want to use for detection. $ python global_index.py global indices.json global_index.py in fingerprint/ global_indices.json in parameters/fingerprint/ Continuous data start/end times may be different, and time gaps may happen at different times, at different components and stations. Global index: consistent way to refer to times of fingerprints at different components and stations. Similarity Search \u00b6 Search for Similar Earthquake Pairs \u00b6 Compile and build C++ similarity search code. ~/quake_tutorial$ cd simsearch/ ~/quake_tutorial$ cmake . ~/quake_tutorial$ make Similarity search for each of the 9 channels (7 stations), using wrapper ~/quake_tutorial/simsearch$ cd .. ~/quake_tutorial$ python run_simsearch.py -c config.json Alternatively, to use similarity search for a specific station, call the similarity search script with the corresponding similarity search parameter file: ~/quake_tutorial$ cd simsearch/ ~/quake_tutorial$ cp ../parameters/simsearch/simsearch_input_HectorMine.sh . ~/quake_tutorial$ ./simsearch_input_HectorMine.sh FAST Similarity Search Output (1 Channel) \u00b6 data/waveforms${STATION}/fingerprints \u2014 MinHash Signatures (can delete these later) \u2022 mh_${STATION}_${CHANNEL}_${nhash}.bin \u2022 Example: mh_CDY_EHZ_4.bin \u2014 Binary files with similarity search output (npart files, one per partition, with first and last fingerprint index for the partition in filename): \u2022 candidate_pairs_${STATION}_${CHANNEL}_${nhash},${ntbl}(${FIRST_FP_INDEX},${LAST_FP_INDEX}) \u2022 Example: andiate_pairs_CDY_EHZ_4,2(0,74793) \u2022 For efficiency, the output is binary format; need parsing to convert similarity search output to text files Parse FAST Similarity Search Output: [Binary --> Text File] \u00b6 Use the wrapper script to parse all 9 channels (7 stations) ~/quake_tutorial$ cd postprocessing ~/quake_tutorial/postprocessing$ cp ../parameters/postprocess/*.sh . ~/quake_tutorial/postprocessing$ ./output_HectorMine_pairs.sh Parse a Specific Channel python parse_results.py \u2013d <folder_with_binary_sim_search_files> -p <sim_search_filename_prefix> -i <global_index_file> Example input file: candidate_pairs_CDY_EHZ_4,2(0,74793) Example command: $ python parse_results.py \u2013d ../data/waveformsCDY/fingerprints/ candidate_pairs_CDY_EHZ \u2013i ../data/global_indices/CDY_EHZ_idx_mapping.txt Postprocessing \u00b6 Postprocess: Combine FAST Similarity Search Output (3 Components @ 1 Station) \u00b6 Combine similarity matrix from all components in each station, and copy outputs to ../data/inputs_network/ using wrapper script: ~/quake_tutorial/postprocessing$ cp ../parameters/postprocess/*.sh . ~/quake_tutorial/postprocessing$ ./combine_HectorMine_pairs.sh Alternatively, to combine outputs (add \u201cFAST similarity\u201d for same fingerprint pair (index1, index2) ) from a specific station: $ python parse_results.py \u2013d <folder_with_text_sim_search_files> -p <text_sim_search_file_prefix> --sort true \u2013parse false \u2013c true \u2013t <threshold> Example: $ python parse_results.py \u2013d ../data/inputs_network/ -p candidate_pairs_HEC --sort true \u2013parse false \u2013c true \u2013t 6 Adds FAST similarity for same fingerprint pairs on HEC components: candidate_pairs_HEC_BHE_merged.txt , candidate_pairs_HEC_BHN_merged.txt , candidate_pairs_HEC_BHZ_merged.txt Output (one file per station): candidate_pairs_HEC_combined.txt Warning By default, the *merged.txt files for all 3 components are deleted after combining! Copy them before this step if you want to keep them. Usually set threshold=number of components * v, where v=nvote at a single component The threshold helps filter out matches generated from noise, since we require either strong matches at a single component, or weak matches at multiple components May want to set threshold slightly lower (e.g., 2*v) if the output size is too small after combining Postprocess: Weight Stations Equally \u00b6 \u2018Equalize\u2019 across network: weighting stations with different number of components equally Hector Mine example: one 3-component station (HEC) with similarity threshold at 6 votes, and 6 1-component stations with similarity threshold at 2 votes. Want to weight each station equally, so multiply similarity in each 1-component station by 3 $ awk \u2018{print$1,$2,3*$3}\u2019 candidate_pairs_CDY_EHZ_merged.txt > candidate_pairs_CDY_combined.txt Another option: use only part of the data (e.g. vertical component at each station) Postprocess: Network Detection \u00b6 Run network detection (combine FAST results from all 7 stations): ~/quake_tutorial/postprocessing$ cp ../parameters/network/* . ~/quake_tutorial/postprocessing$ python scr_run_network_det.py 7sta_2stathresh_network_params.json Input file: 7sta_2stathresh_network_params.json \"io\": { \"channel_vars\": [\"CDY\", \"CPM\", \"GTM\", \"HEC\", \"RMM\", \"RMR\", \"TPC\"], # Station names \"fname_template\": \"candidate_pairs_%s_combined.txt\", # Input file (to fill w/station name) \"base_dir\": \u201d../data/\", # Base directory \"data_folder\": \"inputs_network/\", # Input file directory \"out_folder\": \"network_detection/\" # Output file directory } Network Detection Outputs \u00b6 Network Detection Output (text file with labeled columns) Example (ranked in descending order of \u2018peaksum\u2019): 7sta_2stathresh_detlist_rank_by_peaksum.txt First (num_sta=number of stations) columns: starting fingerprint index at each station (time information) Outputs \u201cnan\u201d if not observed at a particular station dL : Maximum length (samples) along diagonal, over all event-pairs containing this event nevents : Number of other events \u2018linked\u2019 to (similar to) this event nsta : Number of stations over which other events are similar to this event tot_ndets : Total number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations max_ndets : Maximum number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations tot_vol : Total sum (or \u2018volume\u2019) of all similarity values (added over all stations), over all event-pairs containing this event max_vol: Maximum sum (or \u2018volume\u2019) of all similarity values (added over all stations), over all event-pairs containing this event max_peaksum : Maximum similarity value (added over all stations), over all event-pairs containing this event Example Custom Scripts to Clean up and Visualize Network Detection Results \u00b6 Depending on the parameters, network detection output text file might still have duplicate events We provide some example post-processing scripts to remove these duplicate events and come up with a final list of event detections cp ../utils/network/* . Note These have not been fully tested. You may want to write your own instead! Need to modify input/output parameters within each script. 4 scripts: outputs of each script are inputs to the next script. ~/quake_tutorial/postprocessing$ python arrange_network_detection_results.py Save only start and end fingerprint indices for each event (Firstnum_stacolumns --> 2 columns) Output 2 more columns at end Num_sta : number of stations that detected event Diff_ind : Difference between first and last fingerprint index Example output: NetworkDetectionTimes_7sta_2stathresh_detlist_rank_by_peaksum.txt ~/quake_tutorial/postprocessing$ ./remove_duplicates_after_network.sh Remove events with duplicate start fingerprint index (keep events with highest num_sta then peaksum) Example output: uniquestart_sorted_no_duplicates.txt ~/quake_tutorial/postprocessing$ python delete_overlap_network_detections.py Remove events with overlapping times: where start time of one event is before end time of another event Example output: 7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt ~/quake_tutorial/postprocessing$ ./final_network_sort_nsta_peaksum.sh Sort events in descending order of num_sta (number of stations that detected event), then peaksum (maximum similarity for this event) Should no longer have duplicate events Example output: sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Final Thresholds: Visual/Manual Inspection \u00b6 Now we have a list of detections \u2014 but are they actually earthquakes? We need to plot and visually inspect them. Example script, view first 100 events: ~/quake_tutorial/utils/events$ python PARTIALplot_hector_detected_waveforms.py 0 100 Input finger indices from sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Need global start time (t0) from global_idx_stats.txt, dt_fp in seconds Here t0 = UTCDateTime('1999-10-15T13:00:00.676000') Event time = t0 + dt_fp * (start finger print index) Cut short time window around event waveform in filtered data, plot across all stations, save image to png file with names ordered in descending order of num_sta, peaksum \u2013 does it look like an earthquake? Set final thresholds for num_sta, peaksum Example Output (first 50 events): EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Additional post-processing scripts to remove false positive detections? Final Event Detection List \u00b6 Example Script: ~/quake_tutorial/utils/events$ python output_final_detection_list.py Example Input: EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Example Output: FINAL_Detection_List_HectorMine_7sta_2stathresh.txt Column 1 : Event ID Column 2 : YYYY-MM-DDTHH:MM:SS.SSSS for event detection time. This is an approximate arrival time for the event (NOT origin time) Column 3 : Event detection time (seconds) since the start time for the first fingerprint, which for this data set is UTCDateTime('1999-10-15T13:00:00.676000') Column 4 : First fingerprint index (integer) for this event. Multiply by dt_fp = 1 second to get the time in column 2. Columns 1, 2, 3 basically represent the same information. Column 5 : Last fingerprint index (integer) for this event from the network-detection Column 6 : Fingerprint index duration; column5 = column4-column3. Some sense of event duration Column 7 : Number of stations at which the event was similar enough for a detection, the higher the better (nsta_thresh = 2) Column 8 : Peak sum of similarity for this event over all stations where it was detected, the higher the better (more similar to some other event). Detection list is ordered in descending order of number of stations (Column 6), then in descending order of peaksum similarity (Column 7). Further processing is required for P/S phase picking and location: Cut SAC files Pick phases (automatic or manual) Locate earthquakes Compute magnitudes Info The following tutorials are not a part of FAST, but are optional next steps to take for phase picking with SeisBench, earthquake location with HYPOINVERSE, and mapping/visualization with PyGMT. The same commands below should run within the Docker container , but replace the path ~/FAST/ with root@555d364b63d7:/app/FAST/ Phase Picking \u00b6 Cut SAC Files \u00b6 Cut short event waveform files in SAC format from the continuous seismic data at all stations, based on the detection results from FAST. Cut from the original unfiltered continuous seismic data at full sampling rate (usually 100 sps), not the decimated filtered continuous seismic data used to run FAST. In this example, the event waveform time windows are 180 seconds long, 60 seconds before detection time, 120 seconds after detection time. (eq_fast) ~/FAST/utils/events$ python cut_event_files.py Check for cut files in: (eq_fast) ~/FAST/data/event_ids Example: Install SeisBench \u00b6 (eq_fast) ~/FAST/utils/events$ cd ../.. (eq_fast) ~/FAST$ pip install seisbench Pick Phases (automatically) \u00b6 Run SeisBench script for all events and all stations. This can take a few minutes to finish running. (eq_fast) ~/FAST$ cd utils/picking (eq_fast) ~/FAST/utils/picking$ python run_seisbench.py Annotated plots are found in: (eq_fast) ~/FAST/data/seisbench_picks/ Example annotated plot from event 00000000: Output saved in: (eq_fast) ~/FAST/data/seisbench_picks/event_picks.json Example output: \"peak_time\": Arrival time of pick \"peak_value\": Probability of pick Earthquake Location \u00b6 The output from run_seisbench.py in the event_picks.json file contains the information needed to locate the detected earthquakes from the FAST final detection list. We use HYPOINVERSE to locate earthquakes from the picks found with run_seisbench.py . HYPOINVERSE is the standard location program supplied with the Earthworm seismic acquisition and processing system (AQMS). Read more about it here . Formatting input data for HYPOINVERSE \u00b6 To begin earthquake location run the following to format the phase picks for HYPOINVERSE: (eq_fast) ~/FAST/utils/picking$ cd ../location/ (eq_fast) ~/FAST/utils/location$ python SeisBench2hypoinverse.py Output: ~/FAST/data/location_hypoinverse/EQT_19991015_test.txt The script SeisBench2hypoinverse.py will also copy the following files from ~/FAST/utils/location/ to the directory ~/FAST/data/location_hypoinverse/ where we will run HYPOINVERSE: * hadley.crh * locate_events.hyp Get Hector Mine Station List as a json file: (eq_fast) ~/FAST/utils/location$ cd ../preprocess/ (eq_fast) ~/FAST/utils/preprocess$ python get_station_list.py Output: ~/FAST/data/stations/station_list.json Convert station_list.json to HYPOINVERSE station input format in station_list.sta : (eq_fast) ~/FAST/utils/preprocess$ cd ../location/ (eq_fast) ~/FAST/utils/location$ python output_station_file.py Output: ~/FAST/data/location_hypoinverse/station_list.sta Install and Run HYPOINVERSE \u00b6 Check that GFortran is installed, since it is required to compile the HYPOINVERSE program from source: (eq_fast) ~/FAST$ gfortran --version Example expected output: GNU Fortran (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0 If GFortran is not installed, run: (eq_fast) ~/FAST$ apt-get update && apt-get upgrade (eq_fast) ~/FAST$ apt-get install gfortran Download HYPOINVERSE here , expand the hyp1.40.tar file, move the resulting hyp1.40/ directory to ~/FAST/utils/location/hyp1.40/ . This can be done with the following commands: (eq_fast) ~/FAST/utils/location$ wget -c https://escweb.wr.usgs.gov/content/software/HYPOINVERSE/hyp1.40.tar (eq_fast) ~/FAST/utils/location$ mkdir hyp1.40 (eq_fast) ~/FAST/utils/location$ cd hyp1.40 (eq_fast) ~/FAST/utils/location/hyp1.40$ tar -xvf ../hyp1.40.tar (eq_fast) ~/FAST/utils/location/hyp1.40$ ls -l drwxr-xr-x 4 10003 124 128 Sep 10 2014 doc -rw-r--r-- 1 root root 77392 Sep 10 2014 hyp1.40-release-notes.pdf -rw-r--r-- 1 root root 3258 Sep 10 2014 hyp1.40-release-notes.txt drwxr-xr-x 54 10003 124 1728 Sep 10 2014 source drwxr-xr-x 13 10003 124 416 Aug 26 2014 testone Before compiling HYPOINVERSE, we need to make changes to makefile in ~/FAST/utils/location/hyp1.40/source/ : (eq_fast) ~/FAST/utils/location/hyp1.40$ cd source (eq_fast) ~/FAST/utils/location/hyp1.40/source$ sed -i '/calnet/d' makefile (eq_fast) ~/FAST/utils/location/hyp1.40/source$ sed -i 's/g77/gfortran/g' makefile Remove lines 16 and 230 16 cp hyp1 .40 / home / calnet / klein / bin 230 cp p2sdly / home / calnet / klein / bin Find and replace: g77 with gfortran Check that HYPOINVERSE runs : Compile HYPOINVERSE: (eq_fast) ~/FAST/utils/location/hyp1.40/source$ make Make it executable: (eq_fast) ~/FAST/utils/location/hyp1.40/source$ chmod +x hyp1.40 Run HYPOINVERSE: (eq_fast) ~/FAST/utils/location/hyp1.40/source$ ./hyp1.40 Expected output: HYPOINVERSE 2000 STARTING 6/2014 VERSION 1.40 (geoid depth possible) COMMAND? If you have this output, HYPOINVERSE is running correctly. Press ctrl-c to exit. Run HYPOINVERSE \u00b6 Run HYPOINVERSE within the directory ~/FAST/data/location_hypoinverse/ : (eq_fast) ~/FAST/utils/location$ cd ../../data/location_hypoinverse/ (eq_fast) ~/FAST/data/location_hypoinverse$ ../../utils/location/hyp1.40/source/hyp1.40 Use @locate_events.hyp as input: HYPOINVERSE 2000 STARTING 6/2014 VERSION 1.40 (geoid depth possible) COMMAND? @locate_events.hyp Expected output: You should see output files called locate_events.sum and locate_events.arc in HYPOINVERSE Y2000 summary format, but these are difficult to read. Note locate_events.arc has the event info, and phase pick info for each event. locate_events.sum has only the event info, no phase pick info. Use output_hypoinverse_as_text.py to output locate_events.sum in a more readable format to use for plotting and visualization. (eq_fast) ~/FAST/data/location_hypoinverse$ cd ../../utils/location/ (eq_fast) ~/FAST/utils/location$ python output_hypoinverse_as_text.py Plotting Earthquake Locations with PyGMT \u00b6 Install PyGMT \u00b6 IMPORTANT - PyGMT needs to be installed and run in a separate pygmt conda environment, since it is incompatible with the eq_fast conda environment. First, exit the eq_fast conda environment (eq_fast) ~/FAST/utils/location$ conda deactivate Next, create the pygmt conda environment with its dependencies, as described in the PyGMT install page (base) ~/FAST/utils/location$ conda config --prepend channels conda-forge (base) ~/FAST/utils/location$ conda create --name pygmt python=3.9 numpy pandas xarray netcdf4 packaging gmt Finally, enter the pygmt conda environment and install PyGMT (base) ~/FAST/utils/location$ conda activate pygmt (pygmt) ~/FAST/utils/location$ conda install pygmt Create a PyGMT map of earthquake locations and seismic stations \u00b6 (pygmt) ~/FAST/utils/location$ cd ../mapping/ (pygmt) ~/FAST/utils/mapping$ python hypoinverse_to_pygmt.py Figure saved as pygmt_hectormine_map.png in ~/FAST/data/mapping_pygmt/ Map Output : \u00b6","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"tutorial/#example-data-hector-mine-foreshocks","text":"Decimated filtered waveform data (20 Hz sampling rate) to use for FAST: data/waveforms${STATION}/Deci5* Original unfiltered waveform data (20 to 100 Hz sampling rate) to use for phase picking: data/waveforms${STATION}/19991015*","title":"Example Data: Hector Mine Foreshocks"},{"location":"tutorial/#file-structure-overview","text":"","title":"File Structure Overview"},{"location":"tutorial/#code","text":"fingerprint/ # Fingerprint simsearch/ # Similarity Search postprocessing/ # Postprocessing utils/ # Utility Functions preprocess/ network/ events/ run_fp.py run_simsearch.py","title":"Code"},{"location":"tutorial/#configuration-and-parameters","text":"parameters/ fingerprint/ simsearch/ postprocess/","title":"Configuration and Parameters"},{"location":"tutorial/#data","text":"data/ waveforms ${ STATION } / Deci5* ${ STATION } *.sac 19991015* ${ STATION } *.sac","title":"Data"},{"location":"tutorial/#feature-extraction","text":"","title":"Feature Extraction"},{"location":"tutorial/#generate-fingerprints","text":"Create fingerprints for each of the 9 channels (7 stations) + global index, using wrapper ~/quake_tutorial$ python run_fp.py -c config.json Alternatively, to fingerprint a specific station, call the fingerprint script with the corresponding fingerprint parameter file: ~/quake_tutorial$ cd fingerprint/ ~/quake_tutorial/fingerprint$ python gen_fp.py ../parameters/fingerprint/fp_input_CI_CDY_EHZ.json","title":"Generate Fingerprints"},{"location":"tutorial/#global-index","text":"Note Global index is already called by run_fp.py wrapper Complete this step only after you have finished computing fingerprints for every component and station you want to use for detection. $ python global_index.py global indices.json global_index.py in fingerprint/ global_indices.json in parameters/fingerprint/ Continuous data start/end times may be different, and time gaps may happen at different times, at different components and stations. Global index: consistent way to refer to times of fingerprints at different components and stations.","title":"Global Index"},{"location":"tutorial/#similarity-search","text":"","title":"Similarity Search"},{"location":"tutorial/#search-for-similar-earthquake-pairs","text":"Compile and build C++ similarity search code. ~/quake_tutorial$ cd simsearch/ ~/quake_tutorial$ cmake . ~/quake_tutorial$ make Similarity search for each of the 9 channels (7 stations), using wrapper ~/quake_tutorial/simsearch$ cd .. ~/quake_tutorial$ python run_simsearch.py -c config.json Alternatively, to use similarity search for a specific station, call the similarity search script with the corresponding similarity search parameter file: ~/quake_tutorial$ cd simsearch/ ~/quake_tutorial$ cp ../parameters/simsearch/simsearch_input_HectorMine.sh . ~/quake_tutorial$ ./simsearch_input_HectorMine.sh","title":"Search for Similar Earthquake Pairs"},{"location":"tutorial/#fast-similarity-search-output-1-channel","text":"data/waveforms${STATION}/fingerprints \u2014 MinHash Signatures (can delete these later) \u2022 mh_${STATION}_${CHANNEL}_${nhash}.bin \u2022 Example: mh_CDY_EHZ_4.bin \u2014 Binary files with similarity search output (npart files, one per partition, with first and last fingerprint index for the partition in filename): \u2022 candidate_pairs_${STATION}_${CHANNEL}_${nhash},${ntbl}(${FIRST_FP_INDEX},${LAST_FP_INDEX}) \u2022 Example: andiate_pairs_CDY_EHZ_4,2(0,74793) \u2022 For efficiency, the output is binary format; need parsing to convert similarity search output to text files","title":"FAST Similarity Search Output (1 Channel)"},{"location":"tutorial/#parse-fast-similarity-search-output-binary-text-file","text":"Use the wrapper script to parse all 9 channels (7 stations) ~/quake_tutorial$ cd postprocessing ~/quake_tutorial/postprocessing$ cp ../parameters/postprocess/*.sh . ~/quake_tutorial/postprocessing$ ./output_HectorMine_pairs.sh Parse a Specific Channel python parse_results.py \u2013d <folder_with_binary_sim_search_files> -p <sim_search_filename_prefix> -i <global_index_file> Example input file: candidate_pairs_CDY_EHZ_4,2(0,74793) Example command: $ python parse_results.py \u2013d ../data/waveformsCDY/fingerprints/ candidate_pairs_CDY_EHZ \u2013i ../data/global_indices/CDY_EHZ_idx_mapping.txt","title":"Parse FAST Similarity Search Output: [Binary --&gt; Text File]"},{"location":"tutorial/#postprocessing","text":"","title":"Postprocessing"},{"location":"tutorial/#postprocess-combine-fast-similarity-search-output-3-components-1-station","text":"Combine similarity matrix from all components in each station, and copy outputs to ../data/inputs_network/ using wrapper script: ~/quake_tutorial/postprocessing$ cp ../parameters/postprocess/*.sh . ~/quake_tutorial/postprocessing$ ./combine_HectorMine_pairs.sh Alternatively, to combine outputs (add \u201cFAST similarity\u201d for same fingerprint pair (index1, index2) ) from a specific station: $ python parse_results.py \u2013d <folder_with_text_sim_search_files> -p <text_sim_search_file_prefix> --sort true \u2013parse false \u2013c true \u2013t <threshold> Example: $ python parse_results.py \u2013d ../data/inputs_network/ -p candidate_pairs_HEC --sort true \u2013parse false \u2013c true \u2013t 6 Adds FAST similarity for same fingerprint pairs on HEC components: candidate_pairs_HEC_BHE_merged.txt , candidate_pairs_HEC_BHN_merged.txt , candidate_pairs_HEC_BHZ_merged.txt Output (one file per station): candidate_pairs_HEC_combined.txt Warning By default, the *merged.txt files for all 3 components are deleted after combining! Copy them before this step if you want to keep them. Usually set threshold=number of components * v, where v=nvote at a single component The threshold helps filter out matches generated from noise, since we require either strong matches at a single component, or weak matches at multiple components May want to set threshold slightly lower (e.g., 2*v) if the output size is too small after combining","title":"Postprocess: Combine FAST Similarity Search Output (3 Components @ 1 Station)"},{"location":"tutorial/#postprocess-weight-stations-equally","text":"\u2018Equalize\u2019 across network: weighting stations with different number of components equally Hector Mine example: one 3-component station (HEC) with similarity threshold at 6 votes, and 6 1-component stations with similarity threshold at 2 votes. Want to weight each station equally, so multiply similarity in each 1-component station by 3 $ awk \u2018{print$1,$2,3*$3}\u2019 candidate_pairs_CDY_EHZ_merged.txt > candidate_pairs_CDY_combined.txt Another option: use only part of the data (e.g. vertical component at each station)","title":"Postprocess: Weight Stations Equally"},{"location":"tutorial/#postprocess-network-detection","text":"Run network detection (combine FAST results from all 7 stations): ~/quake_tutorial/postprocessing$ cp ../parameters/network/* . ~/quake_tutorial/postprocessing$ python scr_run_network_det.py 7sta_2stathresh_network_params.json Input file: 7sta_2stathresh_network_params.json \"io\": { \"channel_vars\": [\"CDY\", \"CPM\", \"GTM\", \"HEC\", \"RMM\", \"RMR\", \"TPC\"], # Station names \"fname_template\": \"candidate_pairs_%s_combined.txt\", # Input file (to fill w/station name) \"base_dir\": \u201d../data/\", # Base directory \"data_folder\": \"inputs_network/\", # Input file directory \"out_folder\": \"network_detection/\" # Output file directory }","title":"Postprocess: Network Detection"},{"location":"tutorial/#network-detection-outputs","text":"Network Detection Output (text file with labeled columns) Example (ranked in descending order of \u2018peaksum\u2019): 7sta_2stathresh_detlist_rank_by_peaksum.txt First (num_sta=number of stations) columns: starting fingerprint index at each station (time information) Outputs \u201cnan\u201d if not observed at a particular station dL : Maximum length (samples) along diagonal, over all event-pairs containing this event nevents : Number of other events \u2018linked\u2019 to (similar to) this event nsta : Number of stations over which other events are similar to this event tot_ndets : Total number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations max_ndets : Maximum number of fingerprint-pairs (pixels) containing this event, over all event-pair clusters, over all stations tot_vol : Total sum (or \u2018volume\u2019) of all similarity values (added over all stations), over all event-pairs containing this event max_vol: Maximum sum (or \u2018volume\u2019) of all similarity values (added over all stations), over all event-pairs containing this event max_peaksum : Maximum similarity value (added over all stations), over all event-pairs containing this event","title":"Network Detection Outputs"},{"location":"tutorial/#example-custom-scripts-to-clean-up-and-visualize-network-detection-results","text":"Depending on the parameters, network detection output text file might still have duplicate events We provide some example post-processing scripts to remove these duplicate events and come up with a final list of event detections cp ../utils/network/* . Note These have not been fully tested. You may want to write your own instead! Need to modify input/output parameters within each script. 4 scripts: outputs of each script are inputs to the next script. ~/quake_tutorial/postprocessing$ python arrange_network_detection_results.py Save only start and end fingerprint indices for each event (Firstnum_stacolumns --> 2 columns) Output 2 more columns at end Num_sta : number of stations that detected event Diff_ind : Difference between first and last fingerprint index Example output: NetworkDetectionTimes_7sta_2stathresh_detlist_rank_by_peaksum.txt ~/quake_tutorial/postprocessing$ ./remove_duplicates_after_network.sh Remove events with duplicate start fingerprint index (keep events with highest num_sta then peaksum) Example output: uniquestart_sorted_no_duplicates.txt ~/quake_tutorial/postprocessing$ python delete_overlap_network_detections.py Remove events with overlapping times: where start time of one event is before end time of another event Example output: 7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt ~/quake_tutorial/postprocessing$ ./final_network_sort_nsta_peaksum.sh Sort events in descending order of num_sta (number of stations that detected event), then peaksum (maximum similarity for this event) Should no longer have duplicate events Example output: sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt","title":"Example Custom Scripts to Clean up and Visualize Network Detection Results"},{"location":"tutorial/#final-thresholds-visualmanual-inspection","text":"Now we have a list of detections \u2014 but are they actually earthquakes? We need to plot and visually inspect them. Example script, view first 100 events: ~/quake_tutorial/utils/events$ python PARTIALplot_hector_detected_waveforms.py 0 100 Input finger indices from sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Need global start time (t0) from global_idx_stats.txt, dt_fp in seconds Here t0 = UTCDateTime('1999-10-15T13:00:00.676000') Event time = t0 + dt_fp * (start finger print index) Cut short time window around event waveform in filtered data, plot across all stations, save image to png file with names ordered in descending order of num_sta, peaksum \u2013 does it look like an earthquake? Set final thresholds for num_sta, peaksum Example Output (first 50 events): EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Additional post-processing scripts to remove false positive detections?","title":"Final Thresholds: Visual/Manual Inspection"},{"location":"tutorial/#final-event-detection-list","text":"Example Script: ~/quake_tutorial/utils/events$ python output_final_detection_list.py Example Input: EQ_sort_nsta_peaksum_7sta_2stathresh_FinalUniqueNetworkDetectionTimes.txt Example Output: FINAL_Detection_List_HectorMine_7sta_2stathresh.txt Column 1 : Event ID Column 2 : YYYY-MM-DDTHH:MM:SS.SSSS for event detection time. This is an approximate arrival time for the event (NOT origin time) Column 3 : Event detection time (seconds) since the start time for the first fingerprint, which for this data set is UTCDateTime('1999-10-15T13:00:00.676000') Column 4 : First fingerprint index (integer) for this event. Multiply by dt_fp = 1 second to get the time in column 2. Columns 1, 2, 3 basically represent the same information. Column 5 : Last fingerprint index (integer) for this event from the network-detection Column 6 : Fingerprint index duration; column5 = column4-column3. Some sense of event duration Column 7 : Number of stations at which the event was similar enough for a detection, the higher the better (nsta_thresh = 2) Column 8 : Peak sum of similarity for this event over all stations where it was detected, the higher the better (more similar to some other event). Detection list is ordered in descending order of number of stations (Column 6), then in descending order of peaksum similarity (Column 7). Further processing is required for P/S phase picking and location: Cut SAC files Pick phases (automatic or manual) Locate earthquakes Compute magnitudes Info The following tutorials are not a part of FAST, but are optional next steps to take for phase picking with SeisBench, earthquake location with HYPOINVERSE, and mapping/visualization with PyGMT. The same commands below should run within the Docker container , but replace the path ~/FAST/ with root@555d364b63d7:/app/FAST/","title":"Final Event Detection List"},{"location":"tutorial/#phase-picking","text":"","title":"Phase Picking"},{"location":"tutorial/#cut-sac-files","text":"Cut short event waveform files in SAC format from the continuous seismic data at all stations, based on the detection results from FAST. Cut from the original unfiltered continuous seismic data at full sampling rate (usually 100 sps), not the decimated filtered continuous seismic data used to run FAST. In this example, the event waveform time windows are 180 seconds long, 60 seconds before detection time, 120 seconds after detection time. (eq_fast) ~/FAST/utils/events$ python cut_event_files.py Check for cut files in: (eq_fast) ~/FAST/data/event_ids Example:","title":"Cut SAC Files"},{"location":"tutorial/#install-seisbench","text":"(eq_fast) ~/FAST/utils/events$ cd ../.. (eq_fast) ~/FAST$ pip install seisbench","title":"Install SeisBench"},{"location":"tutorial/#pick-phases-automatically","text":"Run SeisBench script for all events and all stations. This can take a few minutes to finish running. (eq_fast) ~/FAST$ cd utils/picking (eq_fast) ~/FAST/utils/picking$ python run_seisbench.py Annotated plots are found in: (eq_fast) ~/FAST/data/seisbench_picks/ Example annotated plot from event 00000000: Output saved in: (eq_fast) ~/FAST/data/seisbench_picks/event_picks.json Example output: \"peak_time\": Arrival time of pick \"peak_value\": Probability of pick","title":"Pick Phases (automatically)"},{"location":"tutorial/#earthquake-location","text":"The output from run_seisbench.py in the event_picks.json file contains the information needed to locate the detected earthquakes from the FAST final detection list. We use HYPOINVERSE to locate earthquakes from the picks found with run_seisbench.py . HYPOINVERSE is the standard location program supplied with the Earthworm seismic acquisition and processing system (AQMS). Read more about it here .","title":"Earthquake Location"},{"location":"tutorial/#formatting-input-data-for-hypoinverse","text":"To begin earthquake location run the following to format the phase picks for HYPOINVERSE: (eq_fast) ~/FAST/utils/picking$ cd ../location/ (eq_fast) ~/FAST/utils/location$ python SeisBench2hypoinverse.py Output: ~/FAST/data/location_hypoinverse/EQT_19991015_test.txt The script SeisBench2hypoinverse.py will also copy the following files from ~/FAST/utils/location/ to the directory ~/FAST/data/location_hypoinverse/ where we will run HYPOINVERSE: * hadley.crh * locate_events.hyp Get Hector Mine Station List as a json file: (eq_fast) ~/FAST/utils/location$ cd ../preprocess/ (eq_fast) ~/FAST/utils/preprocess$ python get_station_list.py Output: ~/FAST/data/stations/station_list.json Convert station_list.json to HYPOINVERSE station input format in station_list.sta : (eq_fast) ~/FAST/utils/preprocess$ cd ../location/ (eq_fast) ~/FAST/utils/location$ python output_station_file.py Output: ~/FAST/data/location_hypoinverse/station_list.sta","title":"Formatting input data for HYPOINVERSE"},{"location":"tutorial/#install-and-run-hypoinverse","text":"Check that GFortran is installed, since it is required to compile the HYPOINVERSE program from source: (eq_fast) ~/FAST$ gfortran --version Example expected output: GNU Fortran (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0 If GFortran is not installed, run: (eq_fast) ~/FAST$ apt-get update && apt-get upgrade (eq_fast) ~/FAST$ apt-get install gfortran Download HYPOINVERSE here , expand the hyp1.40.tar file, move the resulting hyp1.40/ directory to ~/FAST/utils/location/hyp1.40/ . This can be done with the following commands: (eq_fast) ~/FAST/utils/location$ wget -c https://escweb.wr.usgs.gov/content/software/HYPOINVERSE/hyp1.40.tar (eq_fast) ~/FAST/utils/location$ mkdir hyp1.40 (eq_fast) ~/FAST/utils/location$ cd hyp1.40 (eq_fast) ~/FAST/utils/location/hyp1.40$ tar -xvf ../hyp1.40.tar (eq_fast) ~/FAST/utils/location/hyp1.40$ ls -l drwxr-xr-x 4 10003 124 128 Sep 10 2014 doc -rw-r--r-- 1 root root 77392 Sep 10 2014 hyp1.40-release-notes.pdf -rw-r--r-- 1 root root 3258 Sep 10 2014 hyp1.40-release-notes.txt drwxr-xr-x 54 10003 124 1728 Sep 10 2014 source drwxr-xr-x 13 10003 124 416 Aug 26 2014 testone Before compiling HYPOINVERSE, we need to make changes to makefile in ~/FAST/utils/location/hyp1.40/source/ : (eq_fast) ~/FAST/utils/location/hyp1.40$ cd source (eq_fast) ~/FAST/utils/location/hyp1.40/source$ sed -i '/calnet/d' makefile (eq_fast) ~/FAST/utils/location/hyp1.40/source$ sed -i 's/g77/gfortran/g' makefile Remove lines 16 and 230 16 cp hyp1 .40 / home / calnet / klein / bin 230 cp p2sdly / home / calnet / klein / bin Find and replace: g77 with gfortran Check that HYPOINVERSE runs : Compile HYPOINVERSE: (eq_fast) ~/FAST/utils/location/hyp1.40/source$ make Make it executable: (eq_fast) ~/FAST/utils/location/hyp1.40/source$ chmod +x hyp1.40 Run HYPOINVERSE: (eq_fast) ~/FAST/utils/location/hyp1.40/source$ ./hyp1.40 Expected output: HYPOINVERSE 2000 STARTING 6/2014 VERSION 1.40 (geoid depth possible) COMMAND? If you have this output, HYPOINVERSE is running correctly. Press ctrl-c to exit.","title":"Install and Run HYPOINVERSE"},{"location":"tutorial/#run-hypoinverse","text":"Run HYPOINVERSE within the directory ~/FAST/data/location_hypoinverse/ : (eq_fast) ~/FAST/utils/location$ cd ../../data/location_hypoinverse/ (eq_fast) ~/FAST/data/location_hypoinverse$ ../../utils/location/hyp1.40/source/hyp1.40 Use @locate_events.hyp as input: HYPOINVERSE 2000 STARTING 6/2014 VERSION 1.40 (geoid depth possible) COMMAND? @locate_events.hyp Expected output: You should see output files called locate_events.sum and locate_events.arc in HYPOINVERSE Y2000 summary format, but these are difficult to read. Note locate_events.arc has the event info, and phase pick info for each event. locate_events.sum has only the event info, no phase pick info. Use output_hypoinverse_as_text.py to output locate_events.sum in a more readable format to use for plotting and visualization. (eq_fast) ~/FAST/data/location_hypoinverse$ cd ../../utils/location/ (eq_fast) ~/FAST/utils/location$ python output_hypoinverse_as_text.py","title":"Run HYPOINVERSE"},{"location":"tutorial/#plotting-earthquake-locations-with-pygmt","text":"","title":"Plotting Earthquake Locations with PyGMT"},{"location":"tutorial/#install-pygmt","text":"IMPORTANT - PyGMT needs to be installed and run in a separate pygmt conda environment, since it is incompatible with the eq_fast conda environment. First, exit the eq_fast conda environment (eq_fast) ~/FAST/utils/location$ conda deactivate Next, create the pygmt conda environment with its dependencies, as described in the PyGMT install page (base) ~/FAST/utils/location$ conda config --prepend channels conda-forge (base) ~/FAST/utils/location$ conda create --name pygmt python=3.9 numpy pandas xarray netcdf4 packaging gmt Finally, enter the pygmt conda environment and install PyGMT (base) ~/FAST/utils/location$ conda activate pygmt (pygmt) ~/FAST/utils/location$ conda install pygmt","title":"Install PyGMT"},{"location":"tutorial/#create-a-pygmt-map-of-earthquake-locations-and-seismic-stations","text":"(pygmt) ~/FAST/utils/location$ cd ../mapping/ (pygmt) ~/FAST/utils/mapping$ python hypoinverse_to_pygmt.py Figure saved as pygmt_hectormine_map.png in ~/FAST/data/mapping_pygmt/ Map Output :","title":"Create a PyGMT map of earthquake locations and seismic stations"},{"location":"tutorial/#_1","text":"","title":""},{"location":"wenchuan_dataset/","text":"0.7 SeismOlympics: Wenchuan Aftershocks \u00b6 Info Alibaba Cloud and the China Earthquake Administration sponsored a \u201dSeismOlympics\u201d programming competition to detect aftershocks of the deadly May 12, 2008 Mw 7.9 Wenchuan, China, earthquake [Fang et al., 2017], similar to the Netflix Prize or the Kaggle data science competitions. Competitors from seismology, machine learning, signal processing, computer science, and other backgrounds developed algorithms that automatically detect and pick phases on aftershock waveforms while avoiding false positive detections. Performance was evaluated against phases picked by human analysts. This was a great opportunity to test how the FAST earthquake detection algorithm measured up against other methods. Other members of my team, all from Stanford Geophysics (Mostafa Mousavi, Yixiao Sheng, Weiqiang Zhu) used machine learning to pick phases and recognize false detections. We finished in 27th place in the first round of competition, and 16th place in the second round. Figure 11: Map of 15 stations in Wenchuan, China used for FAST detection of small earthquakes in 3 months of continuous data. The ComCat catalog had 1039 aftershocks (circles colored by depth, sized by relative magnitudes 3.2 \u2264 M \u2264 6.1) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.9 Wenchuan earthquake on 2008-05-12. After the competition, I applied FAST to detect earthquakes within the entire continuous data set provided in both rounds of competition. 3 months of seismic data: April 1-22, 2008 (foreshocks), July 1-August 31, 2008 (aftershocks), at 15 stations (Figure 11) with 3 components each, although some stations only have data for part of this time. For all 45 channels, I applied the following preprocessing: 1-20 Hz bandpass filter, then decimated to 50 Hz (factor of 2, from original 100 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise. FAST detected about 12,000 earthquakes; some of them are teleseismic because the 1-20 Hz filter includes lower frequencies. Table S18: FAST input parameters for Wenchuan 2008 aftershock detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 3,612,972. Table S19: Network detection input parameters for Wenchuan 2008 aftershock detection at 15 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S20: Final thresholds for Wenchuan 2008 aftershock detection applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.","title":"0.7 SeismOlympics: Wenchuan Aftershocks"},{"location":"wenchuan_dataset/#07-seismolympics-wenchuan-aftershocks","text":"Info Alibaba Cloud and the China Earthquake Administration sponsored a \u201dSeismOlympics\u201d programming competition to detect aftershocks of the deadly May 12, 2008 Mw 7.9 Wenchuan, China, earthquake [Fang et al., 2017], similar to the Netflix Prize or the Kaggle data science competitions. Competitors from seismology, machine learning, signal processing, computer science, and other backgrounds developed algorithms that automatically detect and pick phases on aftershock waveforms while avoiding false positive detections. Performance was evaluated against phases picked by human analysts. This was a great opportunity to test how the FAST earthquake detection algorithm measured up against other methods. Other members of my team, all from Stanford Geophysics (Mostafa Mousavi, Yixiao Sheng, Weiqiang Zhu) used machine learning to pick phases and recognize false detections. We finished in 27th place in the first round of competition, and 16th place in the second round. Figure 11: Map of 15 stations in Wenchuan, China used for FAST detection of small earthquakes in 3 months of continuous data. The ComCat catalog had 1039 aftershocks (circles colored by depth, sized by relative magnitudes 3.2 \u2264 M \u2264 6.1) inside the boundaries of this map during the detection time period. The yellow star denotes the location of the Mw 7.9 Wenchuan earthquake on 2008-05-12. After the competition, I applied FAST to detect earthquakes within the entire continuous data set provided in both rounds of competition. 3 months of seismic data: April 1-22, 2008 (foreshocks), July 1-August 31, 2008 (aftershocks), at 15 stations (Figure 11) with 3 components each, although some stations only have data for part of this time. For all 45 channels, I applied the following preprocessing: 1-20 Hz bandpass filter, then decimated to 50 Hz (factor of 2, from original 100 Hz); also, all time gaps with 0\u2019s were filled with uncorrelated random noise. FAST detected about 12,000 earthquakes; some of them are teleseismic because the 1-20 Hz filter includes lower frequencies. Table S18: FAST input parameters for Wenchuan 2008 aftershock detection, applied to each component at each station. For the median statistics calculation (for wavelet coefficient selection), we randomly sampled 10% of the data, once per day. Total number of fingerprints (largest number over all channels): 3,612,972. Table S19: Network detection input parameters for Wenchuan 2008 aftershock detection at 15 stations, after getting similar pairs of fingerprints from FAST for each station \u2014 added similarity from all 3 [HHE,HHN,HHZ] components at a given station and set station-pair threshold of (v=2)*(3 components) = 6. Table S20: Final thresholds for Wenchuan 2008 aftershock detection applied to network detection parameters nsta (number of stations that detected event pair) and peaksum (total similarity score at all stations) to determine list of earthquakes, set empirically after visual inspection. For each value of nsta, a different threshold for peaksum can be applied.","title":"0.7 SeismOlympics: Wenchuan Aftershocks"}]}